function lw(e, t) {
  for (var n = 0; n < t.length; n++) {
      const r = t[n];
      if (typeof r != "string" && !Array.isArray(r)) {
          for (const i in r)
              if (i !== "default" && !(i in e)) {
                  const s = Object.getOwnPropertyDescriptor(r, i);
                  s && Object.defineProperty(e, i, s.get ? s : {
                      enumerable: !0,
                      get: () => r[i]
                  })
              }
      }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
  }))
}
(function() {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload"))
      return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
      r(i);
  new MutationObserver(i => {
      for (const s of i)
          if (s.type === "childList")
              for (const a of s.addedNodes)
                  a.tagName === "LINK" && a.rel === "modulepreload" && r(a)
  }
  ).observe(document, {
      childList: !0,
      subtree: !0
  });
  function n(i) {
      const s = {};
      return i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
      s
  }
  function r(i) {
      if (i.ep)
          return;
      i.ep = !0;
      const s = n(i);
      fetch(i.href, s)
  }
}
)();
var Mn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function gi(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
function cw(e) {
  if (e.__esModule)
      return e;
  var t = e.default;
  if (typeof t == "function") {
      var n = function r() {
          return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
      };
      n.prototype = t.prototype
  } else
      n = {};
  return Object.defineProperty(n, "__esModule", {
      value: !0
  }),
  Object.keys(e).forEach(function(r) {
      var i = Object.getOwnPropertyDescriptor(e, r);
      Object.defineProperty(n, r, i.get ? i : {
          enumerable: !0,
          get: function() {
              return e[r]
          }
      })
  }),
  n
}
var fw = {
  exports: {}
}
, Jl = {}
, dw = {
  exports: {}
}
, ue = {};
/**
* @license React
* react.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var oo = Symbol.for("react.element")
, f6 = Symbol.for("react.portal")
, d6 = Symbol.for("react.fragment")
, p6 = Symbol.for("react.strict_mode")
, h6 = Symbol.for("react.profiler")
, m6 = Symbol.for("react.provider")
, y6 = Symbol.for("react.context")
, g6 = Symbol.for("react.forward_ref")
, v6 = Symbol.for("react.suspense")
, w6 = Symbol.for("react.memo")
, b6 = Symbol.for("react.lazy")
, Qy = Symbol.iterator;
function x6(e) {
  return e === null || typeof e != "object" ? null : (e = Qy && e[Qy] || e["@@iterator"],
  typeof e == "function" ? e : null)
}
var pw = {
  isMounted: function() {
      return !1
  },
  enqueueForceUpdate: function() {},
  enqueueReplaceState: function() {},
  enqueueSetState: function() {}
}
, hw = Object.assign
, mw = {};
function gs(e, t, n) {
  this.props = e,
  this.context = t,
  this.refs = mw,
  this.updater = n || pw
}
gs.prototype.isReactComponent = {};
gs.prototype.setState = function(e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, e, t, "setState")
}
;
gs.prototype.forceUpdate = function(e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate")
}
;
function yw() {}
yw.prototype = gs.prototype;
function Dh(e, t, n) {
  this.props = e,
  this.context = t,
  this.refs = mw,
  this.updater = n || pw
}
var Ih = Dh.prototype = new yw;
Ih.constructor = Dh;
hw(Ih, gs.prototype);
Ih.isPureReactComponent = !0;
var Yy = Array.isArray
, gw = Object.prototype.hasOwnProperty
, Ah = {
  current: null
}
, vw = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};
function ww(e, t, n) {
  var r, i = {}, s = null, a = null;
  if (t != null)
      for (r in t.ref !== void 0 && (a = t.ref),
      t.key !== void 0 && (s = "" + t.key),
      t)
          gw.call(t, r) && !vw.hasOwnProperty(r) && (i[r] = t[r]);
  var o = arguments.length - 2;
  if (o === 1)
      i.children = n;
  else if (1 < o) {
      for (var u = Array(o), l = 0; l < o; l++)
          u[l] = arguments[l + 2];
      i.children = u
  }
  if (e && e.defaultProps)
      for (r in o = e.defaultProps,
      o)
          i[r] === void 0 && (i[r] = o[r]);
  return {
      $$typeof: oo,
      type: e,
      key: s,
      ref: a,
      props: i,
      _owner: Ah.current
  }
}
function E6(e, t) {
  return {
      $$typeof: oo,
      type: e.type,
      key: t,
      ref: e.ref,
      props: e.props,
      _owner: e._owner
  }
}
function $h(e) {
  return typeof e == "object" && e !== null && e.$$typeof === oo
}
function S6(e) {
  var t = {
      "=": "=0",
      ":": "=2"
  };
  return "$" + e.replace(/[=:]/g, function(n) {
      return t[n]
  })
}
var Xy = /\/+/g;
function wf(e, t) {
  return typeof e == "object" && e !== null && e.key != null ? S6("" + e.key) : t.toString(36)
}
function Su(e, t, n, r, i) {
  var s = typeof e;
  (s === "undefined" || s === "boolean") && (e = null);
  var a = !1;
  if (e === null)
      a = !0;
  else
      switch (s) {
      case "string":
      case "number":
          a = !0;
          break;
      case "object":
          switch (e.$$typeof) {
          case oo:
          case f6:
              a = !0
          }
      }
  if (a)
      return a = e,
      i = i(a),
      e = r === "" ? "." + wf(a, 0) : r,
      Yy(i) ? (n = "",
      e != null && (n = e.replace(Xy, "$&/") + "/"),
      Su(i, t, n, "", function(l) {
          return l
      })) : i != null && ($h(i) && (i = E6(i, n + (!i.key || a && a.key === i.key ? "" : ("" + i.key).replace(Xy, "$&/") + "/") + e)),
      t.push(i)),
      1;
  if (a = 0,
  r = r === "" ? "." : r + ":",
  Yy(e))
      for (var o = 0; o < e.length; o++) {
          s = e[o];
          var u = r + wf(s, o);
          a += Su(s, t, n, u, i)
      }
  else if (u = x6(e),
  typeof u == "function")
      for (e = u.call(e),
      o = 0; !(s = e.next()).done; )
          s = s.value,
          u = r + wf(s, o++),
          a += Su(s, t, n, u, i);
  else if (s === "object")
      throw t = String(e),
      Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
  return a
}
function Fo(e, t, n) {
  if (e == null)
      return e;
  var r = []
    , i = 0;
  return Su(e, r, "", "", function(s) {
      return t.call(n, s, i++)
  }),
  r
}
function C6(e) {
  if (e._status === -1) {
      var t = e._result;
      t = t(),
      t.then(function(n) {
          (e._status === 0 || e._status === -1) && (e._status = 1,
          e._result = n)
      }, function(n) {
          (e._status === 0 || e._status === -1) && (e._status = 2,
          e._result = n)
      }),
      e._status === -1 && (e._status = 0,
      e._result = t)
  }
  if (e._status === 1)
      return e._result.default;
  throw e._result
}
var St = {
  current: null
}
, Cu = {
  transition: null
}
, _6 = {
  ReactCurrentDispatcher: St,
  ReactCurrentBatchConfig: Cu,
  ReactCurrentOwner: Ah
};
ue.Children = {
  map: Fo,
  forEach: function(e, t, n) {
      Fo(e, function() {
          t.apply(this, arguments)
      }, n)
  },
  count: function(e) {
      var t = 0;
      return Fo(e, function() {
          t++
      }),
      t
  },
  toArray: function(e) {
      return Fo(e, function(t) {
          return t
      }) || []
  },
  only: function(e) {
      if (!$h(e))
          throw Error("React.Children.only expected to receive a single React element child.");
      return e
  }
};
ue.Component = gs;
ue.Fragment = d6;
ue.Profiler = h6;
ue.PureComponent = Dh;
ue.StrictMode = p6;
ue.Suspense = v6;
ue.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _6;
ue.cloneElement = function(e, t, n) {
  if (e == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
  var r = hw({}, e.props)
    , i = e.key
    , s = e.ref
    , a = e._owner;
  if (t != null) {
      if (t.ref !== void 0 && (s = t.ref,
      a = Ah.current),
      t.key !== void 0 && (i = "" + t.key),
      e.type && e.type.defaultProps)
          var o = e.type.defaultProps;
      for (u in t)
          gw.call(t, u) && !vw.hasOwnProperty(u) && (r[u] = t[u] === void 0 && o !== void 0 ? o[u] : t[u])
  }
  var u = arguments.length - 2;
  if (u === 1)
      r.children = n;
  else if (1 < u) {
      o = Array(u);
      for (var l = 0; l < u; l++)
          o[l] = arguments[l + 2];
      r.children = o
  }
  return {
      $$typeof: oo,
      type: e.type,
      key: i,
      ref: s,
      props: r,
      _owner: a
  }
}
;
ue.createContext = function(e) {
  return e = {
      $$typeof: y6,
      _currentValue: e,
      _currentValue2: e,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null
  },
  e.Provider = {
      $$typeof: m6,
      _context: e
  },
  e.Consumer = e
}
;
ue.createElement = ww;
ue.createFactory = function(e) {
  var t = ww.bind(null, e);
  return t.type = e,
  t
}
;
ue.createRef = function() {
  return {
      current: null
  }
}
;
ue.forwardRef = function(e) {
  return {
      $$typeof: g6,
      render: e
  }
}
;
ue.isValidElement = $h;
ue.lazy = function(e) {
  return {
      $$typeof: b6,
      _payload: {
          _status: -1,
          _result: e
      },
      _init: C6
  }
}
;
ue.memo = function(e, t) {
  return {
      $$typeof: w6,
      type: e,
      compare: t === void 0 ? null : t
  }
}
;
ue.startTransition = function(e) {
  var t = Cu.transition;
  Cu.transition = {};
  try {
      e()
  } finally {
      Cu.transition = t
  }
}
;
ue.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.")
}
;
ue.useCallback = function(e, t) {
  return St.current.useCallback(e, t)
}
;
ue.useContext = function(e) {
  return St.current.useContext(e)
}
;
ue.useDebugValue = function() {}
;
ue.useDeferredValue = function(e) {
  return St.current.useDeferredValue(e)
}
;
ue.useEffect = function(e, t) {
  return St.current.useEffect(e, t)
}
;
ue.useId = function() {
  return St.current.useId()
}
;
ue.useImperativeHandle = function(e, t, n) {
  return St.current.useImperativeHandle(e, t, n)
}
;
ue.useInsertionEffect = function(e, t) {
  return St.current.useInsertionEffect(e, t)
}
;
ue.useLayoutEffect = function(e, t) {
  return St.current.useLayoutEffect(e, t)
}
;
ue.useMemo = function(e, t) {
  return St.current.useMemo(e, t)
}
;
ue.useReducer = function(e, t, n) {
  return St.current.useReducer(e, t, n)
}
;
ue.useRef = function(e) {
  return St.current.useRef(e)
}
;
ue.useState = function(e) {
  return St.current.useState(e)
}
;
ue.useSyncExternalStore = function(e, t, n) {
  return St.current.useSyncExternalStore(e, t, n)
}
;
ue.useTransition = function() {
  return St.current.useTransition()
}
;
ue.version = "18.2.0";
dw.exports = ue;
var _ = dw.exports;
const We = gi(_)
, P6 = lw({
  __proto__: null,
  default: We
}, [_]);
/**
* @license React
* react-jsx-runtime.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var T6 = _
, O6 = Symbol.for("react.element")
, k6 = Symbol.for("react.fragment")
, D6 = Object.prototype.hasOwnProperty
, I6 = T6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
, A6 = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};
function bw(e, t, n) {
  var r, i = {}, s = null, a = null;
  n !== void 0 && (s = "" + n),
  t.key !== void 0 && (s = "" + t.key),
  t.ref !== void 0 && (a = t.ref);
  for (r in t)
      D6.call(t, r) && !A6.hasOwnProperty(r) && (i[r] = t[r]);
  if (e && e.defaultProps)
      for (r in t = e.defaultProps,
      t)
          i[r] === void 0 && (i[r] = t[r]);
  return {
      $$typeof: O6,
      type: e,
      key: s,
      ref: a,
      props: i,
      _owner: I6.current
  }
}
Jl.Fragment = k6;
Jl.jsx = bw;
Jl.jsxs = bw;
fw.exports = Jl;
var D = fw.exports
, Ku = {}
, xw = {
  exports: {}
}
, Ut = {}
, Ew = {
  exports: {}
}
, Sw = {};
/**
* @license React
* scheduler.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
(function(e) {
  function t(I, W) {
      var B = I.length;
      I.push(W);
      e: for (; 0 < B; ) {
          var ee = B - 1 >>> 1
            , z = I[ee];
          if (0 < i(z, W))
              I[ee] = W,
              I[B] = z,
              B = ee;
          else
              break e
      }
  }
  function n(I) {
      return I.length === 0 ? null : I[0]
  }
  function r(I) {
      if (I.length === 0)
          return null;
      var W = I[0]
        , B = I.pop();
      if (B !== W) {
          I[0] = B;
          e: for (var ee = 0, z = I.length, N = z >>> 1; ee < N; ) {
              var F = 2 * (ee + 1) - 1
                , K = I[F]
                , k = F + 1
                , Q = I[k];
              if (0 > i(K, B))
                  k < z && 0 > i(Q, K) ? (I[ee] = Q,
                  I[k] = B,
                  ee = k) : (I[ee] = K,
                  I[F] = B,
                  ee = F);
              else if (k < z && 0 > i(Q, B))
                  I[ee] = Q,
                  I[k] = B,
                  ee = k;
              else
                  break e
          }
      }
      return W
  }
  function i(I, W) {
      var B = I.sortIndex - W.sortIndex;
      return B !== 0 ? B : I.id - W.id
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      e.unstable_now = function() {
          return s.now()
      }
  } else {
      var a = Date
        , o = a.now();
      e.unstable_now = function() {
          return a.now() - o
      }
  }
  var u = []
    , l = []
    , c = 1
    , f = null
    , d = 3
    , y = !1
    , m = !1
    , v = !1
    , b = typeof setTimeout == "function" ? setTimeout : null
    , w = typeof clearTimeout == "function" ? clearTimeout : null
    , h = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function g(I) {
      for (var W = n(l); W !== null; ) {
          if (W.callback === null)
              r(l);
          else if (W.startTime <= I)
              r(l),
              W.sortIndex = W.expirationTime,
              t(u, W);
          else
              break;
          W = n(l)
      }
  }
  function x(I) {
      if (v = !1,
      g(I),
      !m)
          if (n(u) !== null)
              m = !0,
              A(S);
          else {
              var W = n(l);
              W !== null && $(x, W.startTime - I)
          }
  }
  function S(I, W) {
      m = !1,
      v && (v = !1,
      w(C),
      C = -1),
      y = !0;
      var B = d;
      try {
          for (g(W),
          f = n(u); f !== null && (!(f.expirationTime > W) || I && !R()); ) {
              var ee = f.callback;
              if (typeof ee == "function") {
                  f.callback = null,
                  d = f.priorityLevel;
                  var z = ee(f.expirationTime <= W);
                  W = e.unstable_now(),
                  typeof z == "function" ? f.callback = z : f === n(u) && r(u),
                  g(W)
              } else
                  r(u);
              f = n(u)
          }
          if (f !== null)
              var N = !0;
          else {
              var F = n(l);
              F !== null && $(x, F.startTime - W),
              N = !1
          }
          return N
      } finally {
          f = null,
          d = B,
          y = !1
      }
  }
  var E = !1
    , p = null
    , C = -1
    , T = 5
    , O = -1;
  function R() {
      return !(e.unstable_now() - O < T)
  }
  function j() {
      if (p !== null) {
          var I = e.unstable_now();
          O = I;
          var W = !0;
          try {
              W = p(!0, I)
          } finally {
              W ? L() : (E = !1,
              p = null)
          }
      } else
          E = !1
  }
  var L;
  if (typeof h == "function")
      L = function() {
          h(j)
      }
      ;
  else if (typeof MessageChannel < "u") {
      var M = new MessageChannel
        , P = M.port2;
      M.port1.onmessage = j,
      L = function() {
          P.postMessage(null)
      }
  } else
      L = function() {
          b(j, 0)
      }
      ;
  function A(I) {
      p = I,
      E || (E = !0,
      L())
  }
  function $(I, W) {
      C = b(function() {
          I(e.unstable_now())
      }, W)
  }
  e.unstable_IdlePriority = 5,
  e.unstable_ImmediatePriority = 1,
  e.unstable_LowPriority = 4,
  e.unstable_NormalPriority = 3,
  e.unstable_Profiling = null,
  e.unstable_UserBlockingPriority = 2,
  e.unstable_cancelCallback = function(I) {
      I.callback = null
  }
  ,
  e.unstable_continueExecution = function() {
      m || y || (m = !0,
      A(S))
  }
  ,
  e.unstable_forceFrameRate = function(I) {
      0 > I || 125 < I ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : T = 0 < I ? Math.floor(1e3 / I) : 5
  }
  ,
  e.unstable_getCurrentPriorityLevel = function() {
      return d
  }
  ,
  e.unstable_getFirstCallbackNode = function() {
      return n(u)
  }
  ,
  e.unstable_next = function(I) {
      switch (d) {
      case 1:
      case 2:
      case 3:
          var W = 3;
          break;
      default:
          W = d
      }
      var B = d;
      d = W;
      try {
          return I()
      } finally {
          d = B
      }
  }
  ,
  e.unstable_pauseExecution = function() {}
  ,
  e.unstable_requestPaint = function() {}
  ,
  e.unstable_runWithPriority = function(I, W) {
      switch (I) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
          break;
      default:
          I = 3
      }
      var B = d;
      d = I;
      try {
          return W()
      } finally {
          d = B
      }
  }
  ,
  e.unstable_scheduleCallback = function(I, W, B) {
      var ee = e.unstable_now();
      switch (typeof B == "object" && B !== null ? (B = B.delay,
      B = typeof B == "number" && 0 < B ? ee + B : ee) : B = ee,
      I) {
      case 1:
          var z = -1;
          break;
      case 2:
          z = 250;
          break;
      case 5:
          z = 1073741823;
          break;
      case 4:
          z = 1e4;
          break;
      default:
          z = 5e3
      }
      return z = B + z,
      I = {
          id: c++,
          callback: W,
          priorityLevel: I,
          startTime: B,
          expirationTime: z,
          sortIndex: -1
      },
      B > ee ? (I.sortIndex = B,
      t(l, I),
      n(u) === null && I === n(l) && (v ? (w(C),
      C = -1) : v = !0,
      $(x, B - ee))) : (I.sortIndex = z,
      t(u, I),
      m || y || (m = !0,
      A(S))),
      I
  }
  ,
  e.unstable_shouldYield = R,
  e.unstable_wrapCallback = function(I) {
      var W = d;
      return function() {
          var B = d;
          d = W;
          try {
              return I.apply(this, arguments)
          } finally {
              d = B
          }
      }
  }
}
)(Sw);
Ew.exports = Sw;
var $6 = Ew.exports;
/**
* @license React
* react-dom.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var Cw = _
, Ft = $6;
function H(e) {
  for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)
      t += "&args[]=" + encodeURIComponent(arguments[n]);
  return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var _w = new Set
, ma = {};
function vi(e, t) {
  is(e, t),
  is(e + "Capture", t)
}
function is(e, t) {
  for (ma[e] = t,
  e = 0; e < t.length; e++)
      _w.add(t[e])
}
var Hn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
, _d = Object.prototype.hasOwnProperty
, R6 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
, Jy = {}
, Zy = {};
function N6(e) {
  return _d.call(Zy, e) ? !0 : _d.call(Jy, e) ? !1 : R6.test(e) ? Zy[e] = !0 : (Jy[e] = !0,
  !1)
}
function j6(e, t, n, r) {
  if (n !== null && n.type === 0)
      return !1;
  switch (typeof t) {
  case "function":
  case "symbol":
      return !0;
  case "boolean":
      return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5),
      e !== "data-" && e !== "aria-");
  default:
      return !1
  }
}
function M6(e, t, n, r) {
  if (t === null || typeof t > "u" || j6(e, t, n, r))
      return !0;
  if (r)
      return !1;
  if (n !== null)
      switch (n.type) {
      case 3:
          return !t;
      case 4:
          return t === !1;
      case 5:
          return isNaN(t);
      case 6:
          return isNaN(t) || 1 > t
      }
  return !1
}
function Ct(e, t, n, r, i, s, a) {
  this.acceptsBooleans = t === 2 || t === 3 || t === 4,
  this.attributeName = r,
  this.attributeNamespace = i,
  this.mustUseProperty = n,
  this.propertyName = e,
  this.type = t,
  this.sanitizeURL = s,
  this.removeEmptyString = a
}
var nt = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
  nt[e] = new Ct(e,0,!1,e,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
  var t = e[0];
  nt[t] = new Ct(t,1,!1,e[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
  nt[e] = new Ct(e,2,!1,e.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
  nt[e] = new Ct(e,2,!1,e,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
  nt[e] = new Ct(e,3,!1,e.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(e) {
  nt[e] = new Ct(e,3,!0,e,null,!1,!1)
});
["capture", "download"].forEach(function(e) {
  nt[e] = new Ct(e,4,!1,e,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(e) {
  nt[e] = new Ct(e,6,!1,e,null,!1,!1)
});
["rowSpan", "start"].forEach(function(e) {
  nt[e] = new Ct(e,5,!1,e.toLowerCase(),null,!1,!1)
});
var Rh = /[\-:]([a-z])/g;
function Nh(e) {
  return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
  var t = e.replace(Rh, Nh);
  nt[t] = new Ct(t,1,!1,e,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
  var t = e.replace(Rh, Nh);
  nt[t] = new Ct(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
  var t = e.replace(Rh, Nh);
  nt[t] = new Ct(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(e) {
  nt[e] = new Ct(e,1,!1,e.toLowerCase(),null,!1,!1)
});
nt.xlinkHref = new Ct("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(e) {
  nt[e] = new Ct(e,1,!1,e.toLowerCase(),null,!0,!0)
});
function jh(e, t, n, r) {
  var i = nt.hasOwnProperty(t) ? nt[t] : null;
  (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (M6(t, n, i, r) && (n = null),
  r || i === null ? N6(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (t = i.attributeName,
  r = i.attributeNamespace,
  n === null ? e.removeAttribute(t) : (i = i.type,
  n = i === 3 || i === 4 && n === !0 ? "" : "" + n,
  r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
}
var Jn = Cw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
, Uo = Symbol.for("react.element")
, Ri = Symbol.for("react.portal")
, Ni = Symbol.for("react.fragment")
, Mh = Symbol.for("react.strict_mode")
, Pd = Symbol.for("react.profiler")
, Pw = Symbol.for("react.provider")
, Tw = Symbol.for("react.context")
, Lh = Symbol.for("react.forward_ref")
, Td = Symbol.for("react.suspense")
, Od = Symbol.for("react.suspense_list")
, Fh = Symbol.for("react.memo")
, ar = Symbol.for("react.lazy")
, Ow = Symbol.for("react.offscreen")
, eg = Symbol.iterator;
function Rs(e) {
  return e === null || typeof e != "object" ? null : (e = eg && e[eg] || e["@@iterator"],
  typeof e == "function" ? e : null)
}
var ke = Object.assign, bf;
function Xs(e) {
  if (bf === void 0)
      try {
          throw Error()
      } catch (n) {
          var t = n.stack.trim().match(/\n( *(at )?)/);
          bf = t && t[1] || ""
      }
  return `
` + bf + e
}
var xf = !1;
function Ef(e, t) {
  if (!e || xf)
      return "";
  xf = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
      if (t)
          if (t = function() {
              throw Error()
          }
          ,
          Object.defineProperty(t.prototype, "props", {
              set: function() {
                  throw Error()
              }
          }),
          typeof Reflect == "object" && Reflect.construct) {
              try {
                  Reflect.construct(t, [])
              } catch (l) {
                  var r = l
              }
              Reflect.construct(e, [], t)
          } else {
              try {
                  t.call()
              } catch (l) {
                  r = l
              }
              e.call(t.prototype)
          }
      else {
          try {
              throw Error()
          } catch (l) {
              r = l
          }
          e()
      }
  } catch (l) {
      if (l && r && typeof l.stack == "string") {
          for (var i = l.stack.split(`
`), s = r.stack.split(`
`), a = i.length - 1, o = s.length - 1; 1 <= a && 0 <= o && i[a] !== s[o]; )
              o--;
          for (; 1 <= a && 0 <= o; a--,
          o--)
              if (i[a] !== s[o]) {
                  if (a !== 1 || o !== 1)
                      do
                          if (a--,
                          o--,
                          0 > o || i[a] !== s[o]) {
                              var u = `
` + i[a].replace(" at new ", " at ");
                              return e.displayName && u.includes("<anonymous>") && (u = u.replace("<anonymous>", e.displayName)),
                              u
                          }
                      while (1 <= a && 0 <= o);
                  break
              }
      }
  } finally {
      xf = !1,
      Error.prepareStackTrace = n
  }
  return (e = e ? e.displayName || e.name : "") ? Xs(e) : ""
}
function L6(e) {
  switch (e.tag) {
  case 5:
      return Xs(e.type);
  case 16:
      return Xs("Lazy");
  case 13:
      return Xs("Suspense");
  case 19:
      return Xs("SuspenseList");
  case 0:
  case 2:
  case 15:
      return e = Ef(e.type, !1),
      e;
  case 11:
      return e = Ef(e.type.render, !1),
      e;
  case 1:
      return e = Ef(e.type, !0),
      e;
  default:
      return ""
  }
}
function kd(e) {
  if (e == null)
      return null;
  if (typeof e == "function")
      return e.displayName || e.name || null;
  if (typeof e == "string")
      return e;
  switch (e) {
  case Ni:
      return "Fragment";
  case Ri:
      return "Portal";
  case Pd:
      return "Profiler";
  case Mh:
      return "StrictMode";
  case Td:
      return "Suspense";
  case Od:
      return "SuspenseList"
  }
  if (typeof e == "object")
      switch (e.$$typeof) {
      case Tw:
          return (e.displayName || "Context") + ".Consumer";
      case Pw:
          return (e._context.displayName || "Context") + ".Provider";
      case Lh:
          var t = e.render;
          return e = e.displayName,
          e || (e = t.displayName || t.name || "",
          e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"),
          e;
      case Fh:
          return t = e.displayName || null,
          t !== null ? t : kd(e.type) || "Memo";
      case ar:
          t = e._payload,
          e = e._init;
          try {
              return kd(e(t))
          } catch {}
      }
  return null
}
function F6(e) {
  var t = e.type;
  switch (e.tag) {
  case 24:
      return "Cache";
  case 9:
      return (t.displayName || "Context") + ".Consumer";
  case 10:
      return (t._context.displayName || "Context") + ".Provider";
  case 18:
      return "DehydratedFragment";
  case 11:
      return e = t.render,
      e = e.displayName || e.name || "",
      t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
  case 7:
      return "Fragment";
  case 5:
      return t;
  case 4:
      return "Portal";
  case 3:
      return "Root";
  case 6:
      return "Text";
  case 16:
      return kd(t);
  case 8:
      return t === Mh ? "StrictMode" : "Mode";
  case 22:
      return "Offscreen";
  case 12:
      return "Profiler";
  case 21:
      return "Scope";
  case 13:
      return "Suspense";
  case 19:
      return "SuspenseList";
  case 25:
      return "TracingMarker";
  case 1:
  case 0:
  case 17:
  case 2:
  case 14:
  case 15:
      if (typeof t == "function")
          return t.displayName || t.name || null;
      if (typeof t == "string")
          return t
  }
  return null
}
function Ir(e) {
  switch (typeof e) {
  case "boolean":
  case "number":
  case "string":
  case "undefined":
      return e;
  case "object":
      return e;
  default:
      return ""
  }
}
function kw(e) {
  var t = e.type;
  return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio")
}
function U6(e) {
  var t = kw(e) ? "checked" : "value"
    , n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t)
    , r = "" + e[t];
  if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
      var i = n.get
        , s = n.set;
      return Object.defineProperty(e, t, {
          configurable: !0,
          get: function() {
              return i.call(this)
          },
          set: function(a) {
              r = "" + a,
              s.call(this, a)
          }
      }),
      Object.defineProperty(e, t, {
          enumerable: n.enumerable
      }),
      {
          getValue: function() {
              return r
          },
          setValue: function(a) {
              r = "" + a
          },
          stopTracking: function() {
              e._valueTracker = null,
              delete e[t]
          }
      }
  }
}
function zo(e) {
  e._valueTracker || (e._valueTracker = U6(e))
}
function Dw(e) {
  if (!e)
      return !1;
  var t = e._valueTracker;
  if (!t)
      return !0;
  var n = t.getValue()
    , r = "";
  return e && (r = kw(e) ? e.checked ? "true" : "false" : e.value),
  e = r,
  e !== n ? (t.setValue(e),
  !0) : !1
}
function Gu(e) {
  if (e = e || (typeof document < "u" ? document : void 0),
  typeof e > "u")
      return null;
  try {
      return e.activeElement || e.body
  } catch {
      return e.body
  }
}
function Dd(e, t) {
  var n = t.checked;
  return ke({}, t, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: n ?? e._wrapperState.initialChecked
  })
}
function tg(e, t) {
  var n = t.defaultValue == null ? "" : t.defaultValue
    , r = t.checked != null ? t.checked : t.defaultChecked;
  n = Ir(t.value != null ? t.value : n),
  e._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null
  }
}
function Iw(e, t) {
  t = t.checked,
  t != null && jh(e, "checked", t, !1)
}
function Id(e, t) {
  Iw(e, t);
  var n = Ir(t.value)
    , r = t.type;
  if (n != null)
      r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
  else if (r === "submit" || r === "reset") {
      e.removeAttribute("value");
      return
  }
  t.hasOwnProperty("value") ? Ad(e, t.type, n) : t.hasOwnProperty("defaultValue") && Ad(e, t.type, Ir(t.defaultValue)),
  t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}
function ng(e, t, n) {
  if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
      var r = t.type;
      if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null))
          return;
      t = "" + e._wrapperState.initialValue,
      n || t === e.value || (e.value = t),
      e.defaultValue = t
  }
  n = e.name,
  n !== "" && (e.name = ""),
  e.defaultChecked = !!e._wrapperState.initialChecked,
  n !== "" && (e.name = n)
}
function Ad(e, t, n) {
  (t !== "number" || Gu(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
}
var Js = Array.isArray;
function Yi(e, t, n, r) {
  if (e = e.options,
  t) {
      t = {};
      for (var i = 0; i < n.length; i++)
          t["$" + n[i]] = !0;
      for (n = 0; n < e.length; n++)
          i = t.hasOwnProperty("$" + e[n].value),
          e[n].selected !== i && (e[n].selected = i),
          i && r && (e[n].defaultSelected = !0)
  } else {
      for (n = "" + Ir(n),
      t = null,
      i = 0; i < e.length; i++) {
          if (e[i].value === n) {
              e[i].selected = !0,
              r && (e[i].defaultSelected = !0);
              return
          }
          t !== null || e[i].disabled || (t = e[i])
      }
      t !== null && (t.selected = !0)
  }
}
function $d(e, t) {
  if (t.dangerouslySetInnerHTML != null)
      throw Error(H(91));
  return ke({}, t, {
      value: void 0,
      defaultValue: void 0,
      children: "" + e._wrapperState.initialValue
  })
}
function rg(e, t) {
  var n = t.value;
  if (n == null) {
      if (n = t.children,
      t = t.defaultValue,
      n != null) {
          if (t != null)
              throw Error(H(92));
          if (Js(n)) {
              if (1 < n.length)
                  throw Error(H(93));
              n = n[0]
          }
          t = n
      }
      t == null && (t = ""),
      n = t
  }
  e._wrapperState = {
      initialValue: Ir(n)
  }
}
function Aw(e, t) {
  var n = Ir(t.value)
    , r = Ir(t.defaultValue);
  n != null && (n = "" + n,
  n !== e.value && (e.value = n),
  t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)),
  r != null && (e.defaultValue = "" + r)
}
function ig(e) {
  var t = e.textContent;
  t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}
function $w(e) {
  switch (e) {
  case "svg":
      return "http://www.w3.org/2000/svg";
  case "math":
      return "http://www.w3.org/1998/Math/MathML";
  default:
      return "http://www.w3.org/1999/xhtml"
  }
}
function Rd(e, t) {
  return e == null || e === "http://www.w3.org/1999/xhtml" ? $w(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e
}
var Bo, Rw = function(e) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, n, r, i) {
      MSApp.execUnsafeLocalFunction(function() {
          return e(t, n, r, i)
      })
  }
  : e
}(function(e, t) {
  if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in e)
      e.innerHTML = t;
  else {
      for (Bo = Bo || document.createElement("div"),
      Bo.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
      t = Bo.firstChild; e.firstChild; )
          e.removeChild(e.firstChild);
      for (; t.firstChild; )
          e.appendChild(t.firstChild)
  }
});
function ya(e, t) {
  if (t) {
      var n = e.firstChild;
      if (n && n === e.lastChild && n.nodeType === 3) {
          n.nodeValue = t;
          return
      }
  }
  e.textContent = t
}
var ra = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}
, z6 = ["Webkit", "ms", "Moz", "O"];
Object.keys(ra).forEach(function(e) {
  z6.forEach(function(t) {
      t = t + e.charAt(0).toUpperCase() + e.substring(1),
      ra[t] = ra[e]
  })
});
function Nw(e, t, n) {
  return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || ra.hasOwnProperty(e) && ra[e] ? ("" + t).trim() : t + "px"
}
function jw(e, t) {
  e = e.style;
  for (var n in t)
      if (t.hasOwnProperty(n)) {
          var r = n.indexOf("--") === 0
            , i = Nw(n, t[n], r);
          n === "float" && (n = "cssFloat"),
          r ? e.setProperty(n, i) : e[n] = i
      }
}
var B6 = ke({
  menuitem: !0
}, {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
});
function Nd(e, t) {
  if (t) {
      if (B6[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
          throw Error(H(137, e));
      if (t.dangerouslySetInnerHTML != null) {
          if (t.children != null)
              throw Error(H(60));
          if (typeof t.dangerouslySetInnerHTML != "object" || !("__html"in t.dangerouslySetInnerHTML))
              throw Error(H(61))
      }
      if (t.style != null && typeof t.style != "object")
          throw Error(H(62))
  }
}
function jd(e, t) {
  if (e.indexOf("-") === -1)
      return typeof t.is == "string";
  switch (e) {
  case "annotation-xml":
  case "color-profile":
  case "font-face":
  case "font-face-src":
  case "font-face-uri":
  case "font-face-format":
  case "font-face-name":
  case "missing-glyph":
      return !1;
  default:
      return !0
  }
}
var Md = null;
function Uh(e) {
  return e = e.target || e.srcElement || window,
  e.correspondingUseElement && (e = e.correspondingUseElement),
  e.nodeType === 3 ? e.parentNode : e
}
var Ld = null
, Xi = null
, Ji = null;
function sg(e) {
  if (e = co(e)) {
      if (typeof Ld != "function")
          throw Error(H(280));
      var t = e.stateNode;
      t && (t = rc(t),
      Ld(e.stateNode, e.type, t))
  }
}
function Mw(e) {
  Xi ? Ji ? Ji.push(e) : Ji = [e] : Xi = e
}
function Lw() {
  if (Xi) {
      var e = Xi
        , t = Ji;
      if (Ji = Xi = null,
      sg(e),
      t)
          for (e = 0; e < t.length; e++)
              sg(t[e])
  }
}
function Fw(e, t) {
  return e(t)
}
function Uw() {}
var Sf = !1;
function zw(e, t, n) {
  if (Sf)
      return e(t, n);
  Sf = !0;
  try {
      return Fw(e, t, n)
  } finally {
      Sf = !1,
      (Xi !== null || Ji !== null) && (Uw(),
      Lw())
  }
}
function ga(e, t) {
  var n = e.stateNode;
  if (n === null)
      return null;
  var r = rc(n);
  if (r === null)
      return null;
  n = r[t];
  e: switch (t) {
  case "onClick":
  case "onClickCapture":
  case "onDoubleClick":
  case "onDoubleClickCapture":
  case "onMouseDown":
  case "onMouseDownCapture":
  case "onMouseMove":
  case "onMouseMoveCapture":
  case "onMouseUp":
  case "onMouseUpCapture":
  case "onMouseEnter":
      (r = !r.disabled) || (e = e.type,
      r = !(e === "button" || e === "input" || e === "select" || e === "textarea")),
      e = !r;
      break e;
  default:
      e = !1
  }
  if (e)
      return null;
  if (n && typeof n != "function")
      throw Error(H(231, t, typeof n));
  return n
}
var Fd = !1;
if (Hn)
  try {
      var Ns = {};
      Object.defineProperty(Ns, "passive", {
          get: function() {
              Fd = !0
          }
      }),
      window.addEventListener("test", Ns, Ns),
      window.removeEventListener("test", Ns, Ns)
  } catch {
      Fd = !1
  }
function W6(e, t, n, r, i, s, a, o, u) {
  var l = Array.prototype.slice.call(arguments, 3);
  try {
      t.apply(n, l)
  } catch (c) {
      this.onError(c)
  }
}
var ia = !1
, Qu = null
, Yu = !1
, Ud = null
, H6 = {
  onError: function(e) {
      ia = !0,
      Qu = e
  }
};
function q6(e, t, n, r, i, s, a, o, u) {
  ia = !1,
  Qu = null,
  W6.apply(H6, arguments)
}
function V6(e, t, n, r, i, s, a, o, u) {
  if (q6.apply(this, arguments),
  ia) {
      if (ia) {
          var l = Qu;
          ia = !1,
          Qu = null
      } else
          throw Error(H(198));
      Yu || (Yu = !0,
      Ud = l)
  }
}
function wi(e) {
  var t = e
    , n = e;
  if (e.alternate)
      for (; t.return; )
          t = t.return;
  else {
      e = t;
      do
          t = e,
          t.flags & 4098 && (n = t.return),
          e = t.return;
      while (e)
  }
  return t.tag === 3 ? n : null
}
function Bw(e) {
  if (e.tag === 13) {
      var t = e.memoizedState;
      if (t === null && (e = e.alternate,
      e !== null && (t = e.memoizedState)),
      t !== null)
          return t.dehydrated
  }
  return null
}
function ag(e) {
  if (wi(e) !== e)
      throw Error(H(188))
}
function K6(e) {
  var t = e.alternate;
  if (!t) {
      if (t = wi(e),
      t === null)
          throw Error(H(188));
      return t !== e ? null : e
  }
  for (var n = e, r = t; ; ) {
      var i = n.return;
      if (i === null)
          break;
      var s = i.alternate;
      if (s === null) {
          if (r = i.return,
          r !== null) {
              n = r;
              continue
          }
          break
      }
      if (i.child === s.child) {
          for (s = i.child; s; ) {
              if (s === n)
                  return ag(i),
                  e;
              if (s === r)
                  return ag(i),
                  t;
              s = s.sibling
          }
          throw Error(H(188))
      }
      if (n.return !== r.return)
          n = i,
          r = s;
      else {
          for (var a = !1, o = i.child; o; ) {
              if (o === n) {
                  a = !0,
                  n = i,
                  r = s;
                  break
              }
              if (o === r) {
                  a = !0,
                  r = i,
                  n = s;
                  break
              }
              o = o.sibling
          }
          if (!a) {
              for (o = s.child; o; ) {
                  if (o === n) {
                      a = !0,
                      n = s,
                      r = i;
                      break
                  }
                  if (o === r) {
                      a = !0,
                      r = s,
                      n = i;
                      break
                  }
                  o = o.sibling
              }
              if (!a)
                  throw Error(H(189))
          }
      }
      if (n.alternate !== r)
          throw Error(H(190))
  }
  if (n.tag !== 3)
      throw Error(H(188));
  return n.stateNode.current === n ? e : t
}
function Ww(e) {
  return e = K6(e),
  e !== null ? Hw(e) : null
}
function Hw(e) {
  if (e.tag === 5 || e.tag === 6)
      return e;
  for (e = e.child; e !== null; ) {
      var t = Hw(e);
      if (t !== null)
          return t;
      e = e.sibling
  }
  return null
}
var qw = Ft.unstable_scheduleCallback
, og = Ft.unstable_cancelCallback
, G6 = Ft.unstable_shouldYield
, Q6 = Ft.unstable_requestPaint
, Le = Ft.unstable_now
, Y6 = Ft.unstable_getCurrentPriorityLevel
, zh = Ft.unstable_ImmediatePriority
, Vw = Ft.unstable_UserBlockingPriority
, Xu = Ft.unstable_NormalPriority
, X6 = Ft.unstable_LowPriority
, Kw = Ft.unstable_IdlePriority
, Zl = null
, Tn = null;
function J6(e) {
  if (Tn && typeof Tn.onCommitFiberRoot == "function")
      try {
          Tn.onCommitFiberRoot(Zl, e, void 0, (e.current.flags & 128) === 128)
      } catch {}
}
var dn = Math.clz32 ? Math.clz32 : tC
, Z6 = Math.log
, eC = Math.LN2;
function tC(e) {
  return e >>>= 0,
  e === 0 ? 32 : 31 - (Z6(e) / eC | 0) | 0
}
var Wo = 64
, Ho = 4194304;
function Zs(e) {
  switch (e & -e) {
  case 1:
      return 1;
  case 2:
      return 2;
  case 4:
      return 4;
  case 8:
      return 8;
  case 16:
      return 16;
  case 32:
      return 32;
  case 64:
  case 128:
  case 256:
  case 512:
  case 1024:
  case 2048:
  case 4096:
  case 8192:
  case 16384:
  case 32768:
  case 65536:
  case 131072:
  case 262144:
  case 524288:
  case 1048576:
  case 2097152:
      return e & 4194240;
  case 4194304:
  case 8388608:
  case 16777216:
  case 33554432:
  case 67108864:
      return e & 130023424;
  case 134217728:
      return 134217728;
  case 268435456:
      return 268435456;
  case 536870912:
      return 536870912;
  case 1073741824:
      return 1073741824;
  default:
      return e
  }
}
function Ju(e, t) {
  var n = e.pendingLanes;
  if (n === 0)
      return 0;
  var r = 0
    , i = e.suspendedLanes
    , s = e.pingedLanes
    , a = n & 268435455;
  if (a !== 0) {
      var o = a & ~i;
      o !== 0 ? r = Zs(o) : (s &= a,
      s !== 0 && (r = Zs(s)))
  } else
      a = n & ~i,
      a !== 0 ? r = Zs(a) : s !== 0 && (r = Zs(s));
  if (r === 0)
      return 0;
  if (t !== 0 && t !== r && !(t & i) && (i = r & -r,
  s = t & -t,
  i >= s || i === 16 && (s & 4194240) !== 0))
      return t;
  if (r & 4 && (r |= n & 16),
  t = e.entangledLanes,
  t !== 0)
      for (e = e.entanglements,
      t &= r; 0 < t; )
          n = 31 - dn(t),
          i = 1 << n,
          r |= e[n],
          t &= ~i;
  return r
}
function nC(e, t) {
  switch (e) {
  case 1:
  case 2:
  case 4:
      return t + 250;
  case 8:
  case 16:
  case 32:
  case 64:
  case 128:
  case 256:
  case 512:
  case 1024:
  case 2048:
  case 4096:
  case 8192:
  case 16384:
  case 32768:
  case 65536:
  case 131072:
  case 262144:
  case 524288:
  case 1048576:
  case 2097152:
      return t + 5e3;
  case 4194304:
  case 8388608:
  case 16777216:
  case 33554432:
  case 67108864:
      return -1;
  case 134217728:
  case 268435456:
  case 536870912:
  case 1073741824:
      return -1;
  default:
      return -1
  }
}
function rC(e, t) {
  for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, s = e.pendingLanes; 0 < s; ) {
      var a = 31 - dn(s)
        , o = 1 << a
        , u = i[a];
      u === -1 ? (!(o & n) || o & r) && (i[a] = nC(o, t)) : u <= t && (e.expiredLanes |= o),
      s &= ~o
  }
}
function zd(e) {
  return e = e.pendingLanes & -1073741825,
  e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
}
function Gw() {
  var e = Wo;
  return Wo <<= 1,
  !(Wo & 4194240) && (Wo = 64),
  e
}
function Cf(e) {
  for (var t = [], n = 0; 31 > n; n++)
      t.push(e);
  return t
}
function uo(e, t, n) {
  e.pendingLanes |= t,
  t !== 536870912 && (e.suspendedLanes = 0,
  e.pingedLanes = 0),
  e = e.eventTimes,
  t = 31 - dn(t),
  e[t] = n
}
function iC(e, t) {
  var n = e.pendingLanes & ~t;
  e.pendingLanes = t,
  e.suspendedLanes = 0,
  e.pingedLanes = 0,
  e.expiredLanes &= t,
  e.mutableReadLanes &= t,
  e.entangledLanes &= t,
  t = e.entanglements;
  var r = e.eventTimes;
  for (e = e.expirationTimes; 0 < n; ) {
      var i = 31 - dn(n)
        , s = 1 << i;
      t[i] = 0,
      r[i] = -1,
      e[i] = -1,
      n &= ~s
  }
}
function Bh(e, t) {
  var n = e.entangledLanes |= t;
  for (e = e.entanglements; n; ) {
      var r = 31 - dn(n)
        , i = 1 << r;
      i & t | e[r] & t && (e[r] |= t),
      n &= ~i
  }
}
var de = 0;
function Qw(e) {
  return e &= -e,
  1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1
}
var Yw, Wh, Xw, Jw, Zw, Bd = !1, qo = [], vr = null, wr = null, br = null, va = new Map, wa = new Map, cr = [], sC = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function ug(e, t) {
  switch (e) {
  case "focusin":
  case "focusout":
      vr = null;
      break;
  case "dragenter":
  case "dragleave":
      wr = null;
      break;
  case "mouseover":
  case "mouseout":
      br = null;
      break;
  case "pointerover":
  case "pointerout":
      va.delete(t.pointerId);
      break;
  case "gotpointercapture":
  case "lostpointercapture":
      wa.delete(t.pointerId)
  }
}
function js(e, t, n, r, i, s) {
  return e === null || e.nativeEvent !== s ? (e = {
      blockedOn: t,
      domEventName: n,
      eventSystemFlags: r,
      nativeEvent: s,
      targetContainers: [i]
  },
  t !== null && (t = co(t),
  t !== null && Wh(t)),
  e) : (e.eventSystemFlags |= r,
  t = e.targetContainers,
  i !== null && t.indexOf(i) === -1 && t.push(i),
  e)
}
function aC(e, t, n, r, i) {
  switch (t) {
  case "focusin":
      return vr = js(vr, e, t, n, r, i),
      !0;
  case "dragenter":
      return wr = js(wr, e, t, n, r, i),
      !0;
  case "mouseover":
      return br = js(br, e, t, n, r, i),
      !0;
  case "pointerover":
      var s = i.pointerId;
      return va.set(s, js(va.get(s) || null, e, t, n, r, i)),
      !0;
  case "gotpointercapture":
      return s = i.pointerId,
      wa.set(s, js(wa.get(s) || null, e, t, n, r, i)),
      !0
  }
  return !1
}
function eb(e) {
  var t = ei(e.target);
  if (t !== null) {
      var n = wi(t);
      if (n !== null) {
          if (t = n.tag,
          t === 13) {
              if (t = Bw(n),
              t !== null) {
                  e.blockedOn = t,
                  Zw(e.priority, function() {
                      Xw(n)
                  });
                  return
              }
          } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
              e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
              return
          }
      }
  }
  e.blockedOn = null
}
function _u(e) {
  if (e.blockedOn !== null)
      return !1;
  for (var t = e.targetContainers; 0 < t.length; ) {
      var n = Wd(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
      if (n === null) {
          n = e.nativeEvent;
          var r = new n.constructor(n.type,n);
          Md = r,
          n.target.dispatchEvent(r),
          Md = null
      } else
          return t = co(n),
          t !== null && Wh(t),
          e.blockedOn = n,
          !1;
      t.shift()
  }
  return !0
}
function lg(e, t, n) {
  _u(e) && n.delete(t)
}
function oC() {
  Bd = !1,
  vr !== null && _u(vr) && (vr = null),
  wr !== null && _u(wr) && (wr = null),
  br !== null && _u(br) && (br = null),
  va.forEach(lg),
  wa.forEach(lg)
}
function Ms(e, t) {
  e.blockedOn === t && (e.blockedOn = null,
  Bd || (Bd = !0,
  Ft.unstable_scheduleCallback(Ft.unstable_NormalPriority, oC)))
}
function ba(e) {
  function t(i) {
      return Ms(i, e)
  }
  if (0 < qo.length) {
      Ms(qo[0], e);
      for (var n = 1; n < qo.length; n++) {
          var r = qo[n];
          r.blockedOn === e && (r.blockedOn = null)
      }
  }
  for (vr !== null && Ms(vr, e),
  wr !== null && Ms(wr, e),
  br !== null && Ms(br, e),
  va.forEach(t),
  wa.forEach(t),
  n = 0; n < cr.length; n++)
      r = cr[n],
      r.blockedOn === e && (r.blockedOn = null);
  for (; 0 < cr.length && (n = cr[0],
  n.blockedOn === null); )
      eb(n),
      n.blockedOn === null && cr.shift()
}
var Zi = Jn.ReactCurrentBatchConfig
, Zu = !0;
function uC(e, t, n, r) {
  var i = de
    , s = Zi.transition;
  Zi.transition = null;
  try {
      de = 1,
      Hh(e, t, n, r)
  } finally {
      de = i,
      Zi.transition = s
  }
}
function lC(e, t, n, r) {
  var i = de
    , s = Zi.transition;
  Zi.transition = null;
  try {
      de = 4,
      Hh(e, t, n, r)
  } finally {
      de = i,
      Zi.transition = s
  }
}
function Hh(e, t, n, r) {
  if (Zu) {
      var i = Wd(e, t, n, r);
      if (i === null)
          Rf(e, t, r, el, n),
          ug(e, r);
      else if (aC(i, e, t, n, r))
          r.stopPropagation();
      else if (ug(e, r),
      t & 4 && -1 < sC.indexOf(e)) {
          for (; i !== null; ) {
              var s = co(i);
              if (s !== null && Yw(s),
              s = Wd(e, t, n, r),
              s === null && Rf(e, t, r, el, n),
              s === i)
                  break;
              i = s
          }
          i !== null && r.stopPropagation()
      } else
          Rf(e, t, r, null, n)
  }
}
var el = null;
function Wd(e, t, n, r) {
  if (el = null,
  e = Uh(r),
  e = ei(e),
  e !== null)
      if (t = wi(e),
      t === null)
          e = null;
      else if (n = t.tag,
      n === 13) {
          if (e = Bw(t),
          e !== null)
              return e;
          e = null
      } else if (n === 3) {
          if (t.stateNode.current.memoizedState.isDehydrated)
              return t.tag === 3 ? t.stateNode.containerInfo : null;
          e = null
      } else
          t !== e && (e = null);
  return el = e,
  null
}
function tb(e) {
  switch (e) {
  case "cancel":
  case "click":
  case "close":
  case "contextmenu":
  case "copy":
  case "cut":
  case "auxclick":
  case "dblclick":
  case "dragend":
  case "dragstart":
  case "drop":
  case "focusin":
  case "focusout":
  case "input":
  case "invalid":
  case "keydown":
  case "keypress":
  case "keyup":
  case "mousedown":
  case "mouseup":
  case "paste":
  case "pause":
  case "play":
  case "pointercancel":
  case "pointerdown":
  case "pointerup":
  case "ratechange":
  case "reset":
  case "resize":
  case "seeked":
  case "submit":
  case "touchcancel":
  case "touchend":
  case "touchstart":
  case "volumechange":
  case "change":
  case "selectionchange":
  case "textInput":
  case "compositionstart":
  case "compositionend":
  case "compositionupdate":
  case "beforeblur":
  case "afterblur":
  case "beforeinput":
  case "blur":
  case "fullscreenchange":
  case "focus":
  case "hashchange":
  case "popstate":
  case "select":
  case "selectstart":
      return 1;
  case "drag":
  case "dragenter":
  case "dragexit":
  case "dragleave":
  case "dragover":
  case "mousemove":
  case "mouseout":
  case "mouseover":
  case "pointermove":
  case "pointerout":
  case "pointerover":
  case "scroll":
  case "toggle":
  case "touchmove":
  case "wheel":
  case "mouseenter":
  case "mouseleave":
  case "pointerenter":
  case "pointerleave":
      return 4;
  case "message":
      switch (Y6()) {
      case zh:
          return 1;
      case Vw:
          return 4;
      case Xu:
      case X6:
          return 16;
      case Kw:
          return 536870912;
      default:
          return 16
      }
  default:
      return 16
  }
}
var hr = null
, qh = null
, Pu = null;
function nb() {
  if (Pu)
      return Pu;
  var e, t = qh, n = t.length, r, i = "value"in hr ? hr.value : hr.textContent, s = i.length;
  for (e = 0; e < n && t[e] === i[e]; e++)
      ;
  var a = n - e;
  for (r = 1; r <= a && t[n - r] === i[s - r]; r++)
      ;
  return Pu = i.slice(e, 1 < r ? 1 - r : void 0)
}
function Tu(e) {
  var t = e.keyCode;
  return "charCode"in e ? (e = e.charCode,
  e === 0 && t === 13 && (e = 13)) : e = t,
  e === 10 && (e = 13),
  32 <= e || e === 13 ? e : 0
}
function Vo() {
  return !0
}
function cg() {
  return !1
}
function zt(e) {
  function t(n, r, i, s, a) {
      this._reactName = n,
      this._targetInst = i,
      this.type = r,
      this.nativeEvent = s,
      this.target = a,
      this.currentTarget = null;
      for (var o in e)
          e.hasOwnProperty(o) && (n = e[o],
          this[o] = n ? n(s) : s[o]);
      return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Vo : cg,
      this.isPropagationStopped = cg,
      this
  }
  return ke(t.prototype, {
      preventDefault: function() {
          this.defaultPrevented = !0;
          var n = this.nativeEvent;
          n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          this.isDefaultPrevented = Vo)
      },
      stopPropagation: function() {
          var n = this.nativeEvent;
          n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          this.isPropagationStopped = Vo)
      },
      persist: function() {},
      isPersistent: Vo
  }),
  t
}
var vs = {
  eventPhase: 0,
  bubbles: 0,
  cancelable: 0,
  timeStamp: function(e) {
      return e.timeStamp || Date.now()
  },
  defaultPrevented: 0,
  isTrusted: 0
}, Vh = zt(vs), lo = ke({}, vs, {
  view: 0,
  detail: 0
}), cC = zt(lo), _f, Pf, Ls, ec = ke({}, lo, {
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  pageX: 0,
  pageY: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  getModifierState: Kh,
  button: 0,
  buttons: 0,
  relatedTarget: function(e) {
      return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
  },
  movementX: function(e) {
      return "movementX"in e ? e.movementX : (e !== Ls && (Ls && e.type === "mousemove" ? (_f = e.screenX - Ls.screenX,
      Pf = e.screenY - Ls.screenY) : Pf = _f = 0,
      Ls = e),
      _f)
  },
  movementY: function(e) {
      return "movementY"in e ? e.movementY : Pf
  }
}), fg = zt(ec), fC = ke({}, ec, {
  dataTransfer: 0
}), dC = zt(fC), pC = ke({}, lo, {
  relatedTarget: 0
}), Tf = zt(pC), hC = ke({}, vs, {
  animationName: 0,
  elapsedTime: 0,
  pseudoElement: 0
}), mC = zt(hC), yC = ke({}, vs, {
  clipboardData: function(e) {
      return "clipboardData"in e ? e.clipboardData : window.clipboardData
  }
}), gC = zt(yC), vC = ke({}, vs, {
  data: 0
}), dg = zt(vC), wC = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, bC = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, xC = {
  Alt: "altKey",
  Control: "ctrlKey",
  Meta: "metaKey",
  Shift: "shiftKey"
};
function EC(e) {
  var t = this.nativeEvent;
  return t.getModifierState ? t.getModifierState(e) : (e = xC[e]) ? !!t[e] : !1
}
function Kh() {
  return EC
}
var SC = ke({}, lo, {
  key: function(e) {
      if (e.key) {
          var t = wC[e.key] || e.key;
          if (t !== "Unidentified")
              return t
      }
      return e.type === "keypress" ? (e = Tu(e),
      e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? bC[e.keyCode] || "Unidentified" : ""
  },
  code: 0,
  location: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  repeat: 0,
  locale: 0,
  getModifierState: Kh,
  charCode: function(e) {
      return e.type === "keypress" ? Tu(e) : 0
  },
  keyCode: function(e) {
      return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
  },
  which: function(e) {
      return e.type === "keypress" ? Tu(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
  }
})
, CC = zt(SC)
, _C = ke({}, ec, {
  pointerId: 0,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  pointerType: 0,
  isPrimary: 0
})
, pg = zt(_C)
, PC = ke({}, lo, {
  touches: 0,
  targetTouches: 0,
  changedTouches: 0,
  altKey: 0,
  metaKey: 0,
  ctrlKey: 0,
  shiftKey: 0,
  getModifierState: Kh
})
, TC = zt(PC)
, OC = ke({}, vs, {
  propertyName: 0,
  elapsedTime: 0,
  pseudoElement: 0
})
, kC = zt(OC)
, DC = ke({}, ec, {
  deltaX: function(e) {
      return "deltaX"in e ? e.deltaX : "wheelDeltaX"in e ? -e.wheelDeltaX : 0
  },
  deltaY: function(e) {
      return "deltaY"in e ? e.deltaY : "wheelDeltaY"in e ? -e.wheelDeltaY : "wheelDelta"in e ? -e.wheelDelta : 0
  },
  deltaZ: 0,
  deltaMode: 0
})
, IC = zt(DC)
, AC = [9, 13, 27, 32]
, Gh = Hn && "CompositionEvent"in window
, sa = null;
Hn && "documentMode"in document && (sa = document.documentMode);
var $C = Hn && "TextEvent"in window && !sa
, rb = Hn && (!Gh || sa && 8 < sa && 11 >= sa)
, hg = " "
, mg = !1;
function ib(e, t) {
  switch (e) {
  case "keyup":
      return AC.indexOf(t.keyCode) !== -1;
  case "keydown":
      return t.keyCode !== 229;
  case "keypress":
  case "mousedown":
  case "focusout":
      return !0;
  default:
      return !1
  }
}
function sb(e) {
  return e = e.detail,
  typeof e == "object" && "data"in e ? e.data : null
}
var ji = !1;
function RC(e, t) {
  switch (e) {
  case "compositionend":
      return sb(t);
  case "keypress":
      return t.which !== 32 ? null : (mg = !0,
      hg);
  case "textInput":
      return e = t.data,
      e === hg && mg ? null : e;
  default:
      return null
  }
}
function NC(e, t) {
  if (ji)
      return e === "compositionend" || !Gh && ib(e, t) ? (e = nb(),
      Pu = qh = hr = null,
      ji = !1,
      e) : null;
  switch (e) {
  case "paste":
      return null;
  case "keypress":
      if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
          if (t.char && 1 < t.char.length)
              return t.char;
          if (t.which)
              return String.fromCharCode(t.which)
      }
      return null;
  case "compositionend":
      return rb && t.locale !== "ko" ? null : t.data;
  default:
      return null
  }
}
var jC = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};
function yg(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t === "input" ? !!jC[e.type] : t === "textarea"
}
function ab(e, t, n, r) {
  Mw(r),
  t = tl(t, "onChange"),
  0 < t.length && (n = new Vh("onChange","change",null,n,r),
  e.push({
      event: n,
      listeners: t
  }))
}
var aa = null
, xa = null;
function MC(e) {
  gb(e, 0)
}
function tc(e) {
  var t = Fi(e);
  if (Dw(t))
      return e
}
function LC(e, t) {
  if (e === "change")
      return t
}
var ob = !1;
if (Hn) {
  var Of;
  if (Hn) {
      var kf = "oninput"in document;
      if (!kf) {
          var gg = document.createElement("div");
          gg.setAttribute("oninput", "return;"),
          kf = typeof gg.oninput == "function"
      }
      Of = kf
  } else
      Of = !1;
  ob = Of && (!document.documentMode || 9 < document.documentMode)
}
function vg() {
  aa && (aa.detachEvent("onpropertychange", ub),
  xa = aa = null)
}
function ub(e) {
  if (e.propertyName === "value" && tc(xa)) {
      var t = [];
      ab(t, xa, e, Uh(e)),
      zw(MC, t)
  }
}
function FC(e, t, n) {
  e === "focusin" ? (vg(),
  aa = t,
  xa = n,
  aa.attachEvent("onpropertychange", ub)) : e === "focusout" && vg()
}
function UC(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown")
      return tc(xa)
}
function zC(e, t) {
  if (e === "click")
      return tc(t)
}
function BC(e, t) {
  if (e === "input" || e === "change")
      return tc(t)
}
function WC(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var hn = typeof Object.is == "function" ? Object.is : WC;
function Ea(e, t) {
  if (hn(e, t))
      return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
      return !1;
  var n = Object.keys(e)
    , r = Object.keys(t);
  if (n.length !== r.length)
      return !1;
  for (r = 0; r < n.length; r++) {
      var i = n[r];
      if (!_d.call(t, i) || !hn(e[i], t[i]))
          return !1
  }
  return !0
}
function wg(e) {
  for (; e && e.firstChild; )
      e = e.firstChild;
  return e
}
function bg(e, t) {
  var n = wg(e);
  e = 0;
  for (var r; n; ) {
      if (n.nodeType === 3) {
          if (r = e + n.textContent.length,
          e <= t && r >= t)
              return {
                  node: n,
                  offset: t - e
              };
          e = r
      }
      e: {
          for (; n; ) {
              if (n.nextSibling) {
                  n = n.nextSibling;
                  break e
              }
              n = n.parentNode
          }
          n = void 0
      }
      n = wg(n)
  }
}
function lb(e, t) {
  return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? lb(e, t.parentNode) : "contains"in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1
}
function cb() {
  for (var e = window, t = Gu(); t instanceof e.HTMLIFrameElement; ) {
      try {
          var n = typeof t.contentWindow.location.href == "string"
      } catch {
          n = !1
      }
      if (n)
          e = t.contentWindow;
      else
          break;
      t = Gu(e.document)
  }
  return t
}
function Qh(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true")
}
function HC(e) {
  var t = cb()
    , n = e.focusedElem
    , r = e.selectionRange;
  if (t !== n && n && n.ownerDocument && lb(n.ownerDocument.documentElement, n)) {
      if (r !== null && Qh(n)) {
          if (t = r.start,
          e = r.end,
          e === void 0 && (e = t),
          "selectionStart"in n)
              n.selectionStart = t,
              n.selectionEnd = Math.min(e, n.value.length);
          else if (e = (t = n.ownerDocument || document) && t.defaultView || window,
          e.getSelection) {
              e = e.getSelection();
              var i = n.textContent.length
                , s = Math.min(r.start, i);
              r = r.end === void 0 ? s : Math.min(r.end, i),
              !e.extend && s > r && (i = r,
              r = s,
              s = i),
              i = bg(n, s);
              var a = bg(n, r);
              i && a && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== a.node || e.focusOffset !== a.offset) && (t = t.createRange(),
              t.setStart(i.node, i.offset),
              e.removeAllRanges(),
              s > r ? (e.addRange(t),
              e.extend(a.node, a.offset)) : (t.setEnd(a.node, a.offset),
              e.addRange(t)))
          }
      }
      for (t = [],
      e = n; e = e.parentNode; )
          e.nodeType === 1 && t.push({
              element: e,
              left: e.scrollLeft,
              top: e.scrollTop
          });
      for (typeof n.focus == "function" && n.focus(),
      n = 0; n < t.length; n++)
          e = t[n],
          e.element.scrollLeft = e.left,
          e.element.scrollTop = e.top
  }
}
var qC = Hn && "documentMode"in document && 11 >= document.documentMode
, Mi = null
, Hd = null
, oa = null
, qd = !1;
function xg(e, t, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  qd || Mi == null || Mi !== Gu(r) || (r = Mi,
  "selectionStart"in r && Qh(r) ? r = {
      start: r.selectionStart,
      end: r.selectionEnd
  } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(),
  r = {
      anchorNode: r.anchorNode,
      anchorOffset: r.anchorOffset,
      focusNode: r.focusNode,
      focusOffset: r.focusOffset
  }),
  oa && Ea(oa, r) || (oa = r,
  r = tl(Hd, "onSelect"),
  0 < r.length && (t = new Vh("onSelect","select",null,t,n),
  e.push({
      event: t,
      listeners: r
  }),
  t.target = Mi)))
}
function Ko(e, t) {
  var n = {};
  return n[e.toLowerCase()] = t.toLowerCase(),
  n["Webkit" + e] = "webkit" + t,
  n["Moz" + e] = "moz" + t,
  n
}
var Li = {
  animationend: Ko("Animation", "AnimationEnd"),
  animationiteration: Ko("Animation", "AnimationIteration"),
  animationstart: Ko("Animation", "AnimationStart"),
  transitionend: Ko("Transition", "TransitionEnd")
}
, Df = {}
, fb = {};
Hn && (fb = document.createElement("div").style,
"AnimationEvent"in window || (delete Li.animationend.animation,
delete Li.animationiteration.animation,
delete Li.animationstart.animation),
"TransitionEvent"in window || delete Li.transitionend.transition);
function nc(e) {
  if (Df[e])
      return Df[e];
  if (!Li[e])
      return e;
  var t = Li[e], n;
  for (n in t)
      if (t.hasOwnProperty(n) && n in fb)
          return Df[e] = t[n];
  return e
}
var db = nc("animationend")
, pb = nc("animationiteration")
, hb = nc("animationstart")
, mb = nc("transitionend")
, yb = new Map
, Eg = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function Lr(e, t) {
  yb.set(e, t),
  vi(t, [e])
}
for (var If = 0; If < Eg.length; If++) {
  var Af = Eg[If]
    , VC = Af.toLowerCase()
    , KC = Af[0].toUpperCase() + Af.slice(1);
  Lr(VC, "on" + KC)
}
Lr(db, "onAnimationEnd");
Lr(pb, "onAnimationIteration");
Lr(hb, "onAnimationStart");
Lr("dblclick", "onDoubleClick");
Lr("focusin", "onFocus");
Lr("focusout", "onBlur");
Lr(mb, "onTransitionEnd");
is("onMouseEnter", ["mouseout", "mouseover"]);
is("onMouseLeave", ["mouseout", "mouseover"]);
is("onPointerEnter", ["pointerout", "pointerover"]);
is("onPointerLeave", ["pointerout", "pointerover"]);
vi("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
vi("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
vi("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
vi("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
vi("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
vi("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var ea = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
, GC = new Set("cancel close invalid load scroll toggle".split(" ").concat(ea));
function Sg(e, t, n) {
  var r = e.type || "unknown-event";
  e.currentTarget = n,
  V6(r, t, void 0, e),
  e.currentTarget = null
}
function gb(e, t) {
  t = (t & 4) !== 0;
  for (var n = 0; n < e.length; n++) {
      var r = e[n]
        , i = r.event;
      r = r.listeners;
      e: {
          var s = void 0;
          if (t)
              for (var a = r.length - 1; 0 <= a; a--) {
                  var o = r[a]
                    , u = o.instance
                    , l = o.currentTarget;
                  if (o = o.listener,
                  u !== s && i.isPropagationStopped())
                      break e;
                  Sg(i, o, l),
                  s = u
              }
          else
              for (a = 0; a < r.length; a++) {
                  if (o = r[a],
                  u = o.instance,
                  l = o.currentTarget,
                  o = o.listener,
                  u !== s && i.isPropagationStopped())
                      break e;
                  Sg(i, o, l),
                  s = u
              }
      }
  }
  if (Yu)
      throw e = Ud,
      Yu = !1,
      Ud = null,
      e
}
function we(e, t) {
  var n = t[Yd];
  n === void 0 && (n = t[Yd] = new Set);
  var r = e + "__bubble";
  n.has(r) || (vb(t, e, 2, !1),
  n.add(r))
}
function $f(e, t, n) {
  var r = 0;
  t && (r |= 4),
  vb(n, e, r, t)
}
var Go = "_reactListening" + Math.random().toString(36).slice(2);
function Sa(e) {
  if (!e[Go]) {
      e[Go] = !0,
      _w.forEach(function(n) {
          n !== "selectionchange" && (GC.has(n) || $f(n, !1, e),
          $f(n, !0, e))
      });
      var t = e.nodeType === 9 ? e : e.ownerDocument;
      t === null || t[Go] || (t[Go] = !0,
      $f("selectionchange", !1, t))
  }
}
function vb(e, t, n, r) {
  switch (tb(t)) {
  case 1:
      var i = uC;
      break;
  case 4:
      i = lC;
      break;
  default:
      i = Hh
  }
  n = i.bind(null, t, n, e),
  i = void 0,
  !Fd || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0),
  r ? i !== void 0 ? e.addEventListener(t, n, {
      capture: !0,
      passive: i
  }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, {
      passive: i
  }) : e.addEventListener(t, n, !1)
}
function Rf(e, t, n, r, i) {
  var s = r;
  if (!(t & 1) && !(t & 2) && r !== null)
      e: for (; ; ) {
          if (r === null)
              return;
          var a = r.tag;
          if (a === 3 || a === 4) {
              var o = r.stateNode.containerInfo;
              if (o === i || o.nodeType === 8 && o.parentNode === i)
                  break;
              if (a === 4)
                  for (a = r.return; a !== null; ) {
                      var u = a.tag;
                      if ((u === 3 || u === 4) && (u = a.stateNode.containerInfo,
                      u === i || u.nodeType === 8 && u.parentNode === i))
                          return;
                      a = a.return
                  }
              for (; o !== null; ) {
                  if (a = ei(o),
                  a === null)
                      return;
                  if (u = a.tag,
                  u === 5 || u === 6) {
                      r = s = a;
                      continue e
                  }
                  o = o.parentNode
              }
          }
          r = r.return
      }
  zw(function() {
      var l = s
        , c = Uh(n)
        , f = [];
      e: {
          var d = yb.get(e);
          if (d !== void 0) {
              var y = Vh
                , m = e;
              switch (e) {
              case "keypress":
                  if (Tu(n) === 0)
                      break e;
              case "keydown":
              case "keyup":
                  y = CC;
                  break;
              case "focusin":
                  m = "focus",
                  y = Tf;
                  break;
              case "focusout":
                  m = "blur",
                  y = Tf;
                  break;
              case "beforeblur":
              case "afterblur":
                  y = Tf;
                  break;
              case "click":
                  if (n.button === 2)
                      break e;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                  y = fg;
                  break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                  y = dC;
                  break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                  y = TC;
                  break;
              case db:
              case pb:
              case hb:
                  y = mC;
                  break;
              case mb:
                  y = kC;
                  break;
              case "scroll":
                  y = cC;
                  break;
              case "wheel":
                  y = IC;
                  break;
              case "copy":
              case "cut":
              case "paste":
                  y = gC;
                  break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                  y = pg
              }
              var v = (t & 4) !== 0
                , b = !v && e === "scroll"
                , w = v ? d !== null ? d + "Capture" : null : d;
              v = [];
              for (var h = l, g; h !== null; ) {
                  g = h;
                  var x = g.stateNode;
                  if (g.tag === 5 && x !== null && (g = x,
                  w !== null && (x = ga(h, w),
                  x != null && v.push(Ca(h, x, g)))),
                  b)
                      break;
                  h = h.return
              }
              0 < v.length && (d = new y(d,m,null,n,c),
              f.push({
                  event: d,
                  listeners: v
              }))
          }
      }
      if (!(t & 7)) {
          e: {
              if (d = e === "mouseover" || e === "pointerover",
              y = e === "mouseout" || e === "pointerout",
              d && n !== Md && (m = n.relatedTarget || n.fromElement) && (ei(m) || m[qn]))
                  break e;
              if ((y || d) && (d = c.window === c ? c : (d = c.ownerDocument) ? d.defaultView || d.parentWindow : window,
              y ? (m = n.relatedTarget || n.toElement,
              y = l,
              m = m ? ei(m) : null,
              m !== null && (b = wi(m),
              m !== b || m.tag !== 5 && m.tag !== 6) && (m = null)) : (y = null,
              m = l),
              y !== m)) {
                  if (v = fg,
                  x = "onMouseLeave",
                  w = "onMouseEnter",
                  h = "mouse",
                  (e === "pointerout" || e === "pointerover") && (v = pg,
                  x = "onPointerLeave",
                  w = "onPointerEnter",
                  h = "pointer"),
                  b = y == null ? d : Fi(y),
                  g = m == null ? d : Fi(m),
                  d = new v(x,h + "leave",y,n,c),
                  d.target = b,
                  d.relatedTarget = g,
                  x = null,
                  ei(c) === l && (v = new v(w,h + "enter",m,n,c),
                  v.target = g,
                  v.relatedTarget = b,
                  x = v),
                  b = x,
                  y && m)
                      t: {
                          for (v = y,
                          w = m,
                          h = 0,
                          g = v; g; g = Pi(g))
                              h++;
                          for (g = 0,
                          x = w; x; x = Pi(x))
                              g++;
                          for (; 0 < h - g; )
                              v = Pi(v),
                              h--;
                          for (; 0 < g - h; )
                              w = Pi(w),
                              g--;
                          for (; h--; ) {
                              if (v === w || w !== null && v === w.alternate)
                                  break t;
                              v = Pi(v),
                              w = Pi(w)
                          }
                          v = null
                      }
                  else
                      v = null;
                  y !== null && Cg(f, d, y, v, !1),
                  m !== null && b !== null && Cg(f, b, m, v, !0)
              }
          }
          e: {
              if (d = l ? Fi(l) : window,
              y = d.nodeName && d.nodeName.toLowerCase(),
              y === "select" || y === "input" && d.type === "file")
                  var S = LC;
              else if (yg(d))
                  if (ob)
                      S = BC;
                  else {
                      S = UC;
                      var E = FC
                  }
              else
                  (y = d.nodeName) && y.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (S = zC);
              if (S && (S = S(e, l))) {
                  ab(f, S, n, c);
                  break e
              }
              E && E(e, d, l),
              e === "focusout" && (E = d._wrapperState) && E.controlled && d.type === "number" && Ad(d, "number", d.value)
          }
          switch (E = l ? Fi(l) : window,
          e) {
          case "focusin":
              (yg(E) || E.contentEditable === "true") && (Mi = E,
              Hd = l,
              oa = null);
              break;
          case "focusout":
              oa = Hd = Mi = null;
              break;
          case "mousedown":
              qd = !0;
              break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
              qd = !1,
              xg(f, n, c);
              break;
          case "selectionchange":
              if (qC)
                  break;
          case "keydown":
          case "keyup":
              xg(f, n, c)
          }
          var p;
          if (Gh)
              e: {
                  switch (e) {
                  case "compositionstart":
                      var C = "onCompositionStart";
                      break e;
                  case "compositionend":
                      C = "onCompositionEnd";
                      break e;
                  case "compositionupdate":
                      C = "onCompositionUpdate";
                      break e
                  }
                  C = void 0
              }
          else
              ji ? ib(e, n) && (C = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (C = "onCompositionStart");
          C && (rb && n.locale !== "ko" && (ji || C !== "onCompositionStart" ? C === "onCompositionEnd" && ji && (p = nb()) : (hr = c,
          qh = "value"in hr ? hr.value : hr.textContent,
          ji = !0)),
          E = tl(l, C),
          0 < E.length && (C = new dg(C,e,null,n,c),
          f.push({
              event: C,
              listeners: E
          }),
          p ? C.data = p : (p = sb(n),
          p !== null && (C.data = p)))),
          (p = $C ? RC(e, n) : NC(e, n)) && (l = tl(l, "onBeforeInput"),
          0 < l.length && (c = new dg("onBeforeInput","beforeinput",null,n,c),
          f.push({
              event: c,
              listeners: l
          }),
          c.data = p))
      }
      gb(f, t)
  })
}
function Ca(e, t, n) {
  return {
      instance: e,
      listener: t,
      currentTarget: n
  }
}
function tl(e, t) {
  for (var n = t + "Capture", r = []; e !== null; ) {
      var i = e
        , s = i.stateNode;
      i.tag === 5 && s !== null && (i = s,
      s = ga(e, n),
      s != null && r.unshift(Ca(e, s, i)),
      s = ga(e, t),
      s != null && r.push(Ca(e, s, i))),
      e = e.return
  }
  return r
}
function Pi(e) {
  if (e === null)
      return null;
  do
      e = e.return;
  while (e && e.tag !== 5);
  return e || null
}
function Cg(e, t, n, r, i) {
  for (var s = t._reactName, a = []; n !== null && n !== r; ) {
      var o = n
        , u = o.alternate
        , l = o.stateNode;
      if (u !== null && u === r)
          break;
      o.tag === 5 && l !== null && (o = l,
      i ? (u = ga(n, s),
      u != null && a.unshift(Ca(n, u, o))) : i || (u = ga(n, s),
      u != null && a.push(Ca(n, u, o)))),
      n = n.return
  }
  a.length !== 0 && e.push({
      event: t,
      listeners: a
  })
}
var QC = /\r\n?/g
, YC = /\u0000|\uFFFD/g;
function _g(e) {
  return (typeof e == "string" ? e : "" + e).replace(QC, `
`).replace(YC, "")
}
function Qo(e, t, n) {
  if (t = _g(t),
  _g(e) !== t && n)
      throw Error(H(425))
}
function nl() {}
var Vd = null
, Kd = null;
function Gd(e, t) {
  return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null
}
var Qd = typeof setTimeout == "function" ? setTimeout : void 0
, XC = typeof clearTimeout == "function" ? clearTimeout : void 0
, Pg = typeof Promise == "function" ? Promise : void 0
, JC = typeof queueMicrotask == "function" ? queueMicrotask : typeof Pg < "u" ? function(e) {
  return Pg.resolve(null).then(e).catch(ZC)
}
: Qd;
function ZC(e) {
  setTimeout(function() {
      throw e
  })
}
function Nf(e, t) {
  var n = t
    , r = 0;
  do {
      var i = n.nextSibling;
      if (e.removeChild(n),
      i && i.nodeType === 8)
          if (n = i.data,
          n === "/$") {
              if (r === 0) {
                  e.removeChild(i),
                  ba(t);
                  return
              }
              r--
          } else
              n !== "$" && n !== "$?" && n !== "$!" || r++;
      n = i
  } while (n);
  ba(t)
}
function xr(e) {
  for (; e != null; e = e.nextSibling) {
      var t = e.nodeType;
      if (t === 1 || t === 3)
          break;
      if (t === 8) {
          if (t = e.data,
          t === "$" || t === "$!" || t === "$?")
              break;
          if (t === "/$")
              return null
      }
  }
  return e
}
function Tg(e) {
  e = e.previousSibling;
  for (var t = 0; e; ) {
      if (e.nodeType === 8) {
          var n = e.data;
          if (n === "$" || n === "$!" || n === "$?") {
              if (t === 0)
                  return e;
              t--
          } else
              n === "/$" && t++
      }
      e = e.previousSibling
  }
  return null
}
var ws = Math.random().toString(36).slice(2)
, Sn = "__reactFiber$" + ws
, _a = "__reactProps$" + ws
, qn = "__reactContainer$" + ws
, Yd = "__reactEvents$" + ws
, e5 = "__reactListeners$" + ws
, t5 = "__reactHandles$" + ws;
function ei(e) {
  var t = e[Sn];
  if (t)
      return t;
  for (var n = e.parentNode; n; ) {
      if (t = n[qn] || n[Sn]) {
          if (n = t.alternate,
          t.child !== null || n !== null && n.child !== null)
              for (e = Tg(e); e !== null; ) {
                  if (n = e[Sn])
                      return n;
                  e = Tg(e)
              }
          return t
      }
      e = n,
      n = e.parentNode
  }
  return null
}
function co(e) {
  return e = e[Sn] || e[qn],
  !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e
}
function Fi(e) {
  if (e.tag === 5 || e.tag === 6)
      return e.stateNode;
  throw Error(H(33))
}
function rc(e) {
  return e[_a] || null
}
var Xd = []
, Ui = -1;
function Fr(e) {
  return {
      current: e
  }
}
function be(e) {
  0 > Ui || (e.current = Xd[Ui],
  Xd[Ui] = null,
  Ui--)
}
function ge(e, t) {
  Ui++,
  Xd[Ui] = e.current,
  e.current = t
}
var Ar = {}
, gt = Fr(Ar)
, Ot = Fr(!1)
, ci = Ar;
function ss(e, t) {
  var n = e.type.contextTypes;
  if (!n)
      return Ar;
  var r = e.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
      return r.__reactInternalMemoizedMaskedChildContext;
  var i = {}, s;
  for (s in n)
      i[s] = t[s];
  return r && (e = e.stateNode,
  e.__reactInternalMemoizedUnmaskedChildContext = t,
  e.__reactInternalMemoizedMaskedChildContext = i),
  i
}
function kt(e) {
  return e = e.childContextTypes,
  e != null
}
function rl() {
  be(Ot),
  be(gt)
}
function Og(e, t, n) {
  if (gt.current !== Ar)
      throw Error(H(168));
  ge(gt, t),
  ge(Ot, n)
}
function wb(e, t, n) {
  var r = e.stateNode;
  if (t = t.childContextTypes,
  typeof r.getChildContext != "function")
      return n;
  r = r.getChildContext();
  for (var i in r)
      if (!(i in t))
          throw Error(H(108, F6(e) || "Unknown", i));
  return ke({}, n, r)
}
function il(e) {
  return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Ar,
  ci = gt.current,
  ge(gt, e),
  ge(Ot, Ot.current),
  !0
}
function kg(e, t, n) {
  var r = e.stateNode;
  if (!r)
      throw Error(H(169));
  n ? (e = wb(e, t, ci),
  r.__reactInternalMemoizedMergedChildContext = e,
  be(Ot),
  be(gt),
  ge(gt, e)) : be(Ot),
  ge(Ot, n)
}
var Nn = null
, ic = !1
, jf = !1;
function bb(e) {
  Nn === null ? Nn = [e] : Nn.push(e)
}
function n5(e) {
  ic = !0,
  bb(e)
}
function Ur() {
  if (!jf && Nn !== null) {
      jf = !0;
      var e = 0
        , t = de;
      try {
          var n = Nn;
          for (de = 1; e < n.length; e++) {
              var r = n[e];
              do
                  r = r(!0);
              while (r !== null)
          }
          Nn = null,
          ic = !1
      } catch (i) {
          throw Nn !== null && (Nn = Nn.slice(e + 1)),
          qw(zh, Ur),
          i
      } finally {
          de = t,
          jf = !1
      }
  }
  return null
}
var zi = []
, Bi = 0
, sl = null
, al = 0
, Qt = []
, Yt = 0
, fi = null
, Ln = 1
, Fn = "";
function Xr(e, t) {
  zi[Bi++] = al,
  zi[Bi++] = sl,
  sl = e,
  al = t
}
function xb(e, t, n) {
  Qt[Yt++] = Ln,
  Qt[Yt++] = Fn,
  Qt[Yt++] = fi,
  fi = e;
  var r = Ln;
  e = Fn;
  var i = 32 - dn(r) - 1;
  r &= ~(1 << i),
  n += 1;
  var s = 32 - dn(t) + i;
  if (30 < s) {
      var a = i - i % 5;
      s = (r & (1 << a) - 1).toString(32),
      r >>= a,
      i -= a,
      Ln = 1 << 32 - dn(t) + i | n << i | r,
      Fn = s + e
  } else
      Ln = 1 << s | n << i | r,
      Fn = e
}
function Yh(e) {
  e.return !== null && (Xr(e, 1),
  xb(e, 1, 0))
}
function Xh(e) {
  for (; e === sl; )
      sl = zi[--Bi],
      zi[Bi] = null,
      al = zi[--Bi],
      zi[Bi] = null;
  for (; e === fi; )
      fi = Qt[--Yt],
      Qt[Yt] = null,
      Fn = Qt[--Yt],
      Qt[Yt] = null,
      Ln = Qt[--Yt],
      Qt[Yt] = null
}
var Lt = null
, Nt = null
, Ee = !1
, cn = null;
function Eb(e, t) {
  var n = Xt(5, null, null, 0);
  n.elementType = "DELETED",
  n.stateNode = t,
  n.return = e,
  t = e.deletions,
  t === null ? (e.deletions = [n],
  e.flags |= 16) : t.push(n)
}
function Dg(e, t) {
  switch (e.tag) {
  case 5:
      var n = e.type;
      return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t,
      t !== null ? (e.stateNode = t,
      Lt = e,
      Nt = xr(t.firstChild),
      !0) : !1;
  case 6:
      return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t,
      t !== null ? (e.stateNode = t,
      Lt = e,
      Nt = null,
      !0) : !1;
  case 13:
      return t = t.nodeType !== 8 ? null : t,
      t !== null ? (n = fi !== null ? {
          id: Ln,
          overflow: Fn
      } : null,
      e.memoizedState = {
          dehydrated: t,
          treeContext: n,
          retryLane: 1073741824
      },
      n = Xt(18, null, null, 0),
      n.stateNode = t,
      n.return = e,
      e.child = n,
      Lt = e,
      Nt = null,
      !0) : !1;
  default:
      return !1
  }
}
function Jd(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}
function Zd(e) {
  if (Ee) {
      var t = Nt;
      if (t) {
          var n = t;
          if (!Dg(e, t)) {
              if (Jd(e))
                  throw Error(H(418));
              t = xr(n.nextSibling);
              var r = Lt;
              t && Dg(e, t) ? Eb(r, n) : (e.flags = e.flags & -4097 | 2,
              Ee = !1,
              Lt = e)
          }
      } else {
          if (Jd(e))
              throw Error(H(418));
          e.flags = e.flags & -4097 | 2,
          Ee = !1,
          Lt = e
      }
  }
}
function Ig(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; )
      e = e.return;
  Lt = e
}
function Yo(e) {
  if (e !== Lt)
      return !1;
  if (!Ee)
      return Ig(e),
      Ee = !0,
      !1;
  var t;
  if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type,
  t = t !== "head" && t !== "body" && !Gd(e.type, e.memoizedProps)),
  t && (t = Nt)) {
      if (Jd(e))
          throw Sb(),
          Error(H(418));
      for (; t; )
          Eb(e, t),
          t = xr(t.nextSibling)
  }
  if (Ig(e),
  e.tag === 13) {
      if (e = e.memoizedState,
      e = e !== null ? e.dehydrated : null,
      !e)
          throw Error(H(317));
      e: {
          for (e = e.nextSibling,
          t = 0; e; ) {
              if (e.nodeType === 8) {
                  var n = e.data;
                  if (n === "/$") {
                      if (t === 0) {
                          Nt = xr(e.nextSibling);
                          break e
                      }
                      t--
                  } else
                      n !== "$" && n !== "$!" && n !== "$?" || t++
              }
              e = e.nextSibling
          }
          Nt = null
      }
  } else
      Nt = Lt ? xr(e.stateNode.nextSibling) : null;
  return !0
}
function Sb() {
  for (var e = Nt; e; )
      e = xr(e.nextSibling)
}
function as() {
  Nt = Lt = null,
  Ee = !1
}
function Jh(e) {
  cn === null ? cn = [e] : cn.push(e)
}
var r5 = Jn.ReactCurrentBatchConfig;
function un(e, t) {
  if (e && e.defaultProps) {
      t = ke({}, t),
      e = e.defaultProps;
      for (var n in e)
          t[n] === void 0 && (t[n] = e[n]);
      return t
  }
  return t
}
var ol = Fr(null)
, ul = null
, Wi = null
, Zh = null;
function em() {
  Zh = Wi = ul = null
}
function tm(e) {
  var t = ol.current;
  be(ol),
  e._currentValue = t
}
function ep(e, t, n) {
  for (; e !== null; ) {
      var r = e.alternate;
      if ((e.childLanes & t) !== t ? (e.childLanes |= t,
      r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t),
      e === n)
          break;
      e = e.return
  }
}
function es(e, t) {
  ul = e,
  Zh = Wi = null,
  e = e.dependencies,
  e !== null && e.firstContext !== null && (e.lanes & t && (Tt = !0),
  e.firstContext = null)
}
function en(e) {
  var t = e._currentValue;
  if (Zh !== e)
      if (e = {
          context: e,
          memoizedValue: t,
          next: null
      },
      Wi === null) {
          if (ul === null)
              throw Error(H(308));
          Wi = e,
          ul.dependencies = {
              lanes: 0,
              firstContext: e
          }
      } else
          Wi = Wi.next = e;
  return t
}
var ti = null;
function nm(e) {
  ti === null ? ti = [e] : ti.push(e)
}
function Cb(e, t, n, r) {
  var i = t.interleaved;
  return i === null ? (n.next = n,
  nm(t)) : (n.next = i.next,
  i.next = n),
  t.interleaved = n,
  Vn(e, r)
}
function Vn(e, t) {
  e.lanes |= t;
  var n = e.alternate;
  for (n !== null && (n.lanes |= t),
  n = e,
  e = e.return; e !== null; )
      e.childLanes |= t,
      n = e.alternate,
      n !== null && (n.childLanes |= t),
      n = e,
      e = e.return;
  return n.tag === 3 ? n.stateNode : null
}
var or = !1;
function rm(e) {
  e.updateQueue = {
      baseState: e.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
          pending: null,
          interleaved: null,
          lanes: 0
      },
      effects: null
  }
}
function _b(e, t) {
  e = e.updateQueue,
  t.updateQueue === e && (t.updateQueue = {
      baseState: e.baseState,
      firstBaseUpdate: e.firstBaseUpdate,
      lastBaseUpdate: e.lastBaseUpdate,
      shared: e.shared,
      effects: e.effects
  })
}
function zn(e, t) {
  return {
      eventTime: e,
      lane: t,
      tag: 0,
      payload: null,
      callback: null,
      next: null
  }
}
function Er(e, t, n) {
  var r = e.updateQueue;
  if (r === null)
      return null;
  if (r = r.shared,
  fe & 2) {
      var i = r.pending;
      return i === null ? t.next = t : (t.next = i.next,
      i.next = t),
      r.pending = t,
      Vn(e, n)
  }
  return i = r.interleaved,
  i === null ? (t.next = t,
  nm(r)) : (t.next = i.next,
  i.next = t),
  r.interleaved = t,
  Vn(e, n)
}
function Ou(e, t, n) {
  if (t = t.updateQueue,
  t !== null && (t = t.shared,
  (n & 4194240) !== 0)) {
      var r = t.lanes;
      r &= e.pendingLanes,
      n |= r,
      t.lanes = n,
      Bh(e, n)
  }
}
function Ag(e, t) {
  var n = e.updateQueue
    , r = e.alternate;
  if (r !== null && (r = r.updateQueue,
  n === r)) {
      var i = null
        , s = null;
      if (n = n.firstBaseUpdate,
      n !== null) {
          do {
              var a = {
                  eventTime: n.eventTime,
                  lane: n.lane,
                  tag: n.tag,
                  payload: n.payload,
                  callback: n.callback,
                  next: null
              };
              s === null ? i = s = a : s = s.next = a,
              n = n.next
          } while (n !== null);
          s === null ? i = s = t : s = s.next = t
      } else
          i = s = t;
      n = {
          baseState: r.baseState,
          firstBaseUpdate: i,
          lastBaseUpdate: s,
          shared: r.shared,
          effects: r.effects
      },
      e.updateQueue = n;
      return
  }
  e = n.lastBaseUpdate,
  e === null ? n.firstBaseUpdate = t : e.next = t,
  n.lastBaseUpdate = t
}
function ll(e, t, n, r) {
  var i = e.updateQueue;
  or = !1;
  var s = i.firstBaseUpdate
    , a = i.lastBaseUpdate
    , o = i.shared.pending;
  if (o !== null) {
      i.shared.pending = null;
      var u = o
        , l = u.next;
      u.next = null,
      a === null ? s = l : a.next = l,
      a = u;
      var c = e.alternate;
      c !== null && (c = c.updateQueue,
      o = c.lastBaseUpdate,
      o !== a && (o === null ? c.firstBaseUpdate = l : o.next = l,
      c.lastBaseUpdate = u))
  }
  if (s !== null) {
      var f = i.baseState;
      a = 0,
      c = l = u = null,
      o = s;
      do {
          var d = o.lane
            , y = o.eventTime;
          if ((r & d) === d) {
              c !== null && (c = c.next = {
                  eventTime: y,
                  lane: 0,
                  tag: o.tag,
                  payload: o.payload,
                  callback: o.callback,
                  next: null
              });
              e: {
                  var m = e
                    , v = o;
                  switch (d = t,
                  y = n,
                  v.tag) {
                  case 1:
                      if (m = v.payload,
                      typeof m == "function") {
                          f = m.call(y, f, d);
                          break e
                      }
                      f = m;
                      break e;
                  case 3:
                      m.flags = m.flags & -65537 | 128;
                  case 0:
                      if (m = v.payload,
                      d = typeof m == "function" ? m.call(y, f, d) : m,
                      d == null)
                          break e;
                      f = ke({}, f, d);
                      break e;
                  case 2:
                      or = !0
                  }
              }
              o.callback !== null && o.lane !== 0 && (e.flags |= 64,
              d = i.effects,
              d === null ? i.effects = [o] : d.push(o))
          } else
              y = {
                  eventTime: y,
                  lane: d,
                  tag: o.tag,
                  payload: o.payload,
                  callback: o.callback,
                  next: null
              },
              c === null ? (l = c = y,
              u = f) : c = c.next = y,
              a |= d;
          if (o = o.next,
          o === null) {
              if (o = i.shared.pending,
              o === null)
                  break;
              d = o,
              o = d.next,
              d.next = null,
              i.lastBaseUpdate = d,
              i.shared.pending = null
          }
      } while (!0);
      if (c === null && (u = f),
      i.baseState = u,
      i.firstBaseUpdate = l,
      i.lastBaseUpdate = c,
      t = i.shared.interleaved,
      t !== null) {
          i = t;
          do
              a |= i.lane,
              i = i.next;
          while (i !== t)
      } else
          s === null && (i.shared.lanes = 0);
      pi |= a,
      e.lanes = a,
      e.memoizedState = f
  }
}
function $g(e, t, n) {
  if (e = t.effects,
  t.effects = null,
  e !== null)
      for (t = 0; t < e.length; t++) {
          var r = e[t]
            , i = r.callback;
          if (i !== null) {
              if (r.callback = null,
              r = n,
              typeof i != "function")
                  throw Error(H(191, i));
              i.call(r)
          }
      }
}
var Pb = new Cw.Component().refs;
function tp(e, t, n, r) {
  t = e.memoizedState,
  n = n(r, t),
  n = n == null ? t : ke({}, t, n),
  e.memoizedState = n,
  e.lanes === 0 && (e.updateQueue.baseState = n)
}
var sc = {
  isMounted: function(e) {
      return (e = e._reactInternals) ? wi(e) === e : !1
  },
  enqueueSetState: function(e, t, n) {
      e = e._reactInternals;
      var r = xt()
        , i = Cr(e)
        , s = zn(r, i);
      s.payload = t,
      n != null && (s.callback = n),
      t = Er(e, s, i),
      t !== null && (pn(t, e, i, r),
      Ou(t, e, i))
  },
  enqueueReplaceState: function(e, t, n) {
      e = e._reactInternals;
      var r = xt()
        , i = Cr(e)
        , s = zn(r, i);
      s.tag = 1,
      s.payload = t,
      n != null && (s.callback = n),
      t = Er(e, s, i),
      t !== null && (pn(t, e, i, r),
      Ou(t, e, i))
  },
  enqueueForceUpdate: function(e, t) {
      e = e._reactInternals;
      var n = xt()
        , r = Cr(e)
        , i = zn(n, r);
      i.tag = 2,
      t != null && (i.callback = t),
      t = Er(e, i, r),
      t !== null && (pn(t, e, r, n),
      Ou(t, e, r))
  }
};
function Rg(e, t, n, r, i, s, a) {
  return e = e.stateNode,
  typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, s, a) : t.prototype && t.prototype.isPureReactComponent ? !Ea(n, r) || !Ea(i, s) : !0
}
function Tb(e, t, n) {
  var r = !1
    , i = Ar
    , s = t.contextType;
  return typeof s == "object" && s !== null ? s = en(s) : (i = kt(t) ? ci : gt.current,
  r = t.contextTypes,
  s = (r = r != null) ? ss(e, i) : Ar),
  t = new t(n,s),
  e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null,
  t.updater = sc,
  e.stateNode = t,
  t._reactInternals = e,
  r && (e = e.stateNode,
  e.__reactInternalMemoizedUnmaskedChildContext = i,
  e.__reactInternalMemoizedMaskedChildContext = s),
  t
}
function Ng(e, t, n, r) {
  e = t.state,
  typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r),
  typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r),
  t.state !== e && sc.enqueueReplaceState(t, t.state, null)
}
function np(e, t, n, r) {
  var i = e.stateNode;
  i.props = n,
  i.state = e.memoizedState,
  i.refs = Pb,
  rm(e);
  var s = t.contextType;
  typeof s == "object" && s !== null ? i.context = en(s) : (s = kt(t) ? ci : gt.current,
  i.context = ss(e, s)),
  i.state = e.memoizedState,
  s = t.getDerivedStateFromProps,
  typeof s == "function" && (tp(e, t, s, n),
  i.state = e.memoizedState),
  typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state,
  typeof i.componentWillMount == "function" && i.componentWillMount(),
  typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(),
  t !== i.state && sc.enqueueReplaceState(i, i.state, null),
  ll(e, n, i, r),
  i.state = e.memoizedState),
  typeof i.componentDidMount == "function" && (e.flags |= 4194308)
}
function Fs(e, t, n) {
  if (e = n.ref,
  e !== null && typeof e != "function" && typeof e != "object") {
      if (n._owner) {
          if (n = n._owner,
          n) {
              if (n.tag !== 1)
                  throw Error(H(309));
              var r = n.stateNode
          }
          if (!r)
              throw Error(H(147, e));
          var i = r
            , s = "" + e;
          return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === s ? t.ref : (t = function(a) {
              var o = i.refs;
              o === Pb && (o = i.refs = {}),
              a === null ? delete o[s] : o[s] = a
          }
          ,
          t._stringRef = s,
          t)
      }
      if (typeof e != "string")
          throw Error(H(284));
      if (!n._owner)
          throw Error(H(290, e))
  }
  return e
}
function Xo(e, t) {
  throw e = Object.prototype.toString.call(t),
  Error(H(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
}
function jg(e) {
  var t = e._init;
  return t(e._payload)
}
function Ob(e) {
  function t(w, h) {
      if (e) {
          var g = w.deletions;
          g === null ? (w.deletions = [h],
          w.flags |= 16) : g.push(h)
      }
  }
  function n(w, h) {
      if (!e)
          return null;
      for (; h !== null; )
          t(w, h),
          h = h.sibling;
      return null
  }
  function r(w, h) {
      for (w = new Map; h !== null; )
          h.key !== null ? w.set(h.key, h) : w.set(h.index, h),
          h = h.sibling;
      return w
  }
  function i(w, h) {
      return w = _r(w, h),
      w.index = 0,
      w.sibling = null,
      w
  }
  function s(w, h, g) {
      return w.index = g,
      e ? (g = w.alternate,
      g !== null ? (g = g.index,
      g < h ? (w.flags |= 2,
      h) : g) : (w.flags |= 2,
      h)) : (w.flags |= 1048576,
      h)
  }
  function a(w) {
      return e && w.alternate === null && (w.flags |= 2),
      w
  }
  function o(w, h, g, x) {
      return h === null || h.tag !== 6 ? (h = Wf(g, w.mode, x),
      h.return = w,
      h) : (h = i(h, g),
      h.return = w,
      h)
  }
  function u(w, h, g, x) {
      var S = g.type;
      return S === Ni ? c(w, h, g.props.children, x, g.key) : h !== null && (h.elementType === S || typeof S == "object" && S !== null && S.$$typeof === ar && jg(S) === h.type) ? (x = i(h, g.props),
      x.ref = Fs(w, h, g),
      x.return = w,
      x) : (x = Ru(g.type, g.key, g.props, null, w.mode, x),
      x.ref = Fs(w, h, g),
      x.return = w,
      x)
  }
  function l(w, h, g, x) {
      return h === null || h.tag !== 4 || h.stateNode.containerInfo !== g.containerInfo || h.stateNode.implementation !== g.implementation ? (h = Hf(g, w.mode, x),
      h.return = w,
      h) : (h = i(h, g.children || []),
      h.return = w,
      h)
  }
  function c(w, h, g, x, S) {
      return h === null || h.tag !== 7 ? (h = ai(g, w.mode, x, S),
      h.return = w,
      h) : (h = i(h, g),
      h.return = w,
      h)
  }
  function f(w, h, g) {
      if (typeof h == "string" && h !== "" || typeof h == "number")
          return h = Wf("" + h, w.mode, g),
          h.return = w,
          h;
      if (typeof h == "object" && h !== null) {
          switch (h.$$typeof) {
          case Uo:
              return g = Ru(h.type, h.key, h.props, null, w.mode, g),
              g.ref = Fs(w, null, h),
              g.return = w,
              g;
          case Ri:
              return h = Hf(h, w.mode, g),
              h.return = w,
              h;
          case ar:
              var x = h._init;
              return f(w, x(h._payload), g)
          }
          if (Js(h) || Rs(h))
              return h = ai(h, w.mode, g, null),
              h.return = w,
              h;
          Xo(w, h)
      }
      return null
  }
  function d(w, h, g, x) {
      var S = h !== null ? h.key : null;
      if (typeof g == "string" && g !== "" || typeof g == "number")
          return S !== null ? null : o(w, h, "" + g, x);
      if (typeof g == "object" && g !== null) {
          switch (g.$$typeof) {
          case Uo:
              return g.key === S ? u(w, h, g, x) : null;
          case Ri:
              return g.key === S ? l(w, h, g, x) : null;
          case ar:
              return S = g._init,
              d(w, h, S(g._payload), x)
          }
          if (Js(g) || Rs(g))
              return S !== null ? null : c(w, h, g, x, null);
          Xo(w, g)
      }
      return null
  }
  function y(w, h, g, x, S) {
      if (typeof x == "string" && x !== "" || typeof x == "number")
          return w = w.get(g) || null,
          o(h, w, "" + x, S);
      if (typeof x == "object" && x !== null) {
          switch (x.$$typeof) {
          case Uo:
              return w = w.get(x.key === null ? g : x.key) || null,
              u(h, w, x, S);
          case Ri:
              return w = w.get(x.key === null ? g : x.key) || null,
              l(h, w, x, S);
          case ar:
              var E = x._init;
              return y(w, h, g, E(x._payload), S)
          }
          if (Js(x) || Rs(x))
              return w = w.get(g) || null,
              c(h, w, x, S, null);
          Xo(h, x)
      }
      return null
  }
  function m(w, h, g, x) {
      for (var S = null, E = null, p = h, C = h = 0, T = null; p !== null && C < g.length; C++) {
          p.index > C ? (T = p,
          p = null) : T = p.sibling;
          var O = d(w, p, g[C], x);
          if (O === null) {
              p === null && (p = T);
              break
          }
          e && p && O.alternate === null && t(w, p),
          h = s(O, h, C),
          E === null ? S = O : E.sibling = O,
          E = O,
          p = T
      }
      if (C === g.length)
          return n(w, p),
          Ee && Xr(w, C),
          S;
      if (p === null) {
          for (; C < g.length; C++)
              p = f(w, g[C], x),
              p !== null && (h = s(p, h, C),
              E === null ? S = p : E.sibling = p,
              E = p);
          return Ee && Xr(w, C),
          S
      }
      for (p = r(w, p); C < g.length; C++)
          T = y(p, w, C, g[C], x),
          T !== null && (e && T.alternate !== null && p.delete(T.key === null ? C : T.key),
          h = s(T, h, C),
          E === null ? S = T : E.sibling = T,
          E = T);
      return e && p.forEach(function(R) {
          return t(w, R)
      }),
      Ee && Xr(w, C),
      S
  }
  function v(w, h, g, x) {
      var S = Rs(g);
      if (typeof S != "function")
          throw Error(H(150));
      if (g = S.call(g),
      g == null)
          throw Error(H(151));
      for (var E = S = null, p = h, C = h = 0, T = null, O = g.next(); p !== null && !O.done; C++,
      O = g.next()) {
          p.index > C ? (T = p,
          p = null) : T = p.sibling;
          var R = d(w, p, O.value, x);
          if (R === null) {
              p === null && (p = T);
              break
          }
          e && p && R.alternate === null && t(w, p),
          h = s(R, h, C),
          E === null ? S = R : E.sibling = R,
          E = R,
          p = T
      }
      if (O.done)
          return n(w, p),
          Ee && Xr(w, C),
          S;
      if (p === null) {
          for (; !O.done; C++,
          O = g.next())
              O = f(w, O.value, x),
              O !== null && (h = s(O, h, C),
              E === null ? S = O : E.sibling = O,
              E = O);
          return Ee && Xr(w, C),
          S
      }
      for (p = r(w, p); !O.done; C++,
      O = g.next())
          O = y(p, w, C, O.value, x),
          O !== null && (e && O.alternate !== null && p.delete(O.key === null ? C : O.key),
          h = s(O, h, C),
          E === null ? S = O : E.sibling = O,
          E = O);
      return e && p.forEach(function(j) {
          return t(w, j)
      }),
      Ee && Xr(w, C),
      S
  }
  function b(w, h, g, x) {
      if (typeof g == "object" && g !== null && g.type === Ni && g.key === null && (g = g.props.children),
      typeof g == "object" && g !== null) {
          switch (g.$$typeof) {
          case Uo:
              e: {
                  for (var S = g.key, E = h; E !== null; ) {
                      if (E.key === S) {
                          if (S = g.type,
                          S === Ni) {
                              if (E.tag === 7) {
                                  n(w, E.sibling),
                                  h = i(E, g.props.children),
                                  h.return = w,
                                  w = h;
                                  break e
                              }
                          } else if (E.elementType === S || typeof S == "object" && S !== null && S.$$typeof === ar && jg(S) === E.type) {
                              n(w, E.sibling),
                              h = i(E, g.props),
                              h.ref = Fs(w, E, g),
                              h.return = w,
                              w = h;
                              break e
                          }
                          n(w, E);
                          break
                      } else
                          t(w, E);
                      E = E.sibling
                  }
                  g.type === Ni ? (h = ai(g.props.children, w.mode, x, g.key),
                  h.return = w,
                  w = h) : (x = Ru(g.type, g.key, g.props, null, w.mode, x),
                  x.ref = Fs(w, h, g),
                  x.return = w,
                  w = x)
              }
              return a(w);
          case Ri:
              e: {
                  for (E = g.key; h !== null; ) {
                      if (h.key === E)
                          if (h.tag === 4 && h.stateNode.containerInfo === g.containerInfo && h.stateNode.implementation === g.implementation) {
                              n(w, h.sibling),
                              h = i(h, g.children || []),
                              h.return = w,
                              w = h;
                              break e
                          } else {
                              n(w, h);
                              break
                          }
                      else
                          t(w, h);
                      h = h.sibling
                  }
                  h = Hf(g, w.mode, x),
                  h.return = w,
                  w = h
              }
              return a(w);
          case ar:
              return E = g._init,
              b(w, h, E(g._payload), x)
          }
          if (Js(g))
              return m(w, h, g, x);
          if (Rs(g))
              return v(w, h, g, x);
          Xo(w, g)
      }
      return typeof g == "string" && g !== "" || typeof g == "number" ? (g = "" + g,
      h !== null && h.tag === 6 ? (n(w, h.sibling),
      h = i(h, g),
      h.return = w,
      w = h) : (n(w, h),
      h = Wf(g, w.mode, x),
      h.return = w,
      w = h),
      a(w)) : n(w, h)
  }
  return b
}
var os = Ob(!0)
, kb = Ob(!1)
, fo = {}
, On = Fr(fo)
, Pa = Fr(fo)
, Ta = Fr(fo);
function ni(e) {
  if (e === fo)
      throw Error(H(174));
  return e
}
function im(e, t) {
  switch (ge(Ta, t),
  ge(Pa, e),
  ge(On, fo),
  e = t.nodeType,
  e) {
  case 9:
  case 11:
      t = (t = t.documentElement) ? t.namespaceURI : Rd(null, "");
      break;
  default:
      e = e === 8 ? t.parentNode : t,
      t = e.namespaceURI || null,
      e = e.tagName,
      t = Rd(t, e)
  }
  be(On),
  ge(On, t)
}
function us() {
  be(On),
  be(Pa),
  be(Ta)
}
function Db(e) {
  ni(Ta.current);
  var t = ni(On.current)
    , n = Rd(t, e.type);
  t !== n && (ge(Pa, e),
  ge(On, n))
}
function sm(e) {
  Pa.current === e && (be(On),
  be(Pa))
}
var _e = Fr(0);
function cl(e) {
  for (var t = e; t !== null; ) {
      if (t.tag === 13) {
          var n = t.memoizedState;
          if (n !== null && (n = n.dehydrated,
          n === null || n.data === "$?" || n.data === "$!"))
              return t
      } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
          if (t.flags & 128)
              return t
      } else if (t.child !== null) {
          t.child.return = t,
          t = t.child;
          continue
      }
      if (t === e)
          break;
      for (; t.sibling === null; ) {
          if (t.return === null || t.return === e)
              return null;
          t = t.return
      }
      t.sibling.return = t.return,
      t = t.sibling
  }
  return null
}
var Mf = [];
function am() {
  for (var e = 0; e < Mf.length; e++)
      Mf[e]._workInProgressVersionPrimary = null;
  Mf.length = 0
}
var ku = Jn.ReactCurrentDispatcher
, Lf = Jn.ReactCurrentBatchConfig
, di = 0
, Oe = null
, qe = null
, Xe = null
, fl = !1
, ua = !1
, Oa = 0
, i5 = 0;
function ft() {
  throw Error(H(321))
}
function om(e, t) {
  if (t === null)
      return !1;
  for (var n = 0; n < t.length && n < e.length; n++)
      if (!hn(e[n], t[n]))
          return !1;
  return !0
}
function um(e, t, n, r, i, s) {
  if (di = s,
  Oe = t,
  t.memoizedState = null,
  t.updateQueue = null,
  t.lanes = 0,
  ku.current = e === null || e.memoizedState === null ? u5 : l5,
  e = n(r, i),
  ua) {
      s = 0;
      do {
          if (ua = !1,
          Oa = 0,
          25 <= s)
              throw Error(H(301));
          s += 1,
          Xe = qe = null,
          t.updateQueue = null,
          ku.current = c5,
          e = n(r, i)
      } while (ua)
  }
  if (ku.current = dl,
  t = qe !== null && qe.next !== null,
  di = 0,
  Xe = qe = Oe = null,
  fl = !1,
  t)
      throw Error(H(300));
  return e
}
function lm() {
  var e = Oa !== 0;
  return Oa = 0,
  e
}
function xn() {
  var e = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
  };
  return Xe === null ? Oe.memoizedState = Xe = e : Xe = Xe.next = e,
  Xe
}
function tn() {
  if (qe === null) {
      var e = Oe.alternate;
      e = e !== null ? e.memoizedState : null
  } else
      e = qe.next;
  var t = Xe === null ? Oe.memoizedState : Xe.next;
  if (t !== null)
      Xe = t,
      qe = e;
  else {
      if (e === null)
          throw Error(H(310));
      qe = e,
      e = {
          memoizedState: qe.memoizedState,
          baseState: qe.baseState,
          baseQueue: qe.baseQueue,
          queue: qe.queue,
          next: null
      },
      Xe === null ? Oe.memoizedState = Xe = e : Xe = Xe.next = e
  }
  return Xe
}
function ka(e, t) {
  return typeof t == "function" ? t(e) : t
}
function Ff(e) {
  var t = tn()
    , n = t.queue;
  if (n === null)
      throw Error(H(311));
  n.lastRenderedReducer = e;
  var r = qe
    , i = r.baseQueue
    , s = n.pending;
  if (s !== null) {
      if (i !== null) {
          var a = i.next;
          i.next = s.next,
          s.next = a
      }
      r.baseQueue = i = s,
      n.pending = null
  }
  if (i !== null) {
      s = i.next,
      r = r.baseState;
      var o = a = null
        , u = null
        , l = s;
      do {
          var c = l.lane;
          if ((di & c) === c)
              u !== null && (u = u.next = {
                  lane: 0,
                  action: l.action,
                  hasEagerState: l.hasEagerState,
                  eagerState: l.eagerState,
                  next: null
              }),
              r = l.hasEagerState ? l.eagerState : e(r, l.action);
          else {
              var f = {
                  lane: c,
                  action: l.action,
                  hasEagerState: l.hasEagerState,
                  eagerState: l.eagerState,
                  next: null
              };
              u === null ? (o = u = f,
              a = r) : u = u.next = f,
              Oe.lanes |= c,
              pi |= c
          }
          l = l.next
      } while (l !== null && l !== s);
      u === null ? a = r : u.next = o,
      hn(r, t.memoizedState) || (Tt = !0),
      t.memoizedState = r,
      t.baseState = a,
      t.baseQueue = u,
      n.lastRenderedState = r
  }
  if (e = n.interleaved,
  e !== null) {
      i = e;
      do
          s = i.lane,
          Oe.lanes |= s,
          pi |= s,
          i = i.next;
      while (i !== e)
  } else
      i === null && (n.lanes = 0);
  return [t.memoizedState, n.dispatch]
}
function Uf(e) {
  var t = tn()
    , n = t.queue;
  if (n === null)
      throw Error(H(311));
  n.lastRenderedReducer = e;
  var r = n.dispatch
    , i = n.pending
    , s = t.memoizedState;
  if (i !== null) {
      n.pending = null;
      var a = i = i.next;
      do
          s = e(s, a.action),
          a = a.next;
      while (a !== i);
      hn(s, t.memoizedState) || (Tt = !0),
      t.memoizedState = s,
      t.baseQueue === null && (t.baseState = s),
      n.lastRenderedState = s
  }
  return [s, r]
}
function Ib() {}
function Ab(e, t) {
  var n = Oe
    , r = tn()
    , i = t()
    , s = !hn(r.memoizedState, i);
  if (s && (r.memoizedState = i,
  Tt = !0),
  r = r.queue,
  cm(Nb.bind(null, n, r, e), [e]),
  r.getSnapshot !== t || s || Xe !== null && Xe.memoizedState.tag & 1) {
      if (n.flags |= 2048,
      Da(9, Rb.bind(null, n, r, i, t), void 0, null),
      Je === null)
          throw Error(H(349));
      di & 30 || $b(n, t, i)
  }
  return i
}
function $b(e, t, n) {
  e.flags |= 16384,
  e = {
      getSnapshot: t,
      value: n
  },
  t = Oe.updateQueue,
  t === null ? (t = {
      lastEffect: null,
      stores: null
  },
  Oe.updateQueue = t,
  t.stores = [e]) : (n = t.stores,
  n === null ? t.stores = [e] : n.push(e))
}
function Rb(e, t, n, r) {
  t.value = n,
  t.getSnapshot = r,
  jb(t) && Mb(e)
}
function Nb(e, t, n) {
  return n(function() {
      jb(t) && Mb(e)
  })
}
function jb(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
      var n = t();
      return !hn(e, n)
  } catch {
      return !0
  }
}
function Mb(e) {
  var t = Vn(e, 1);
  t !== null && pn(t, e, 1, -1)
}
function Mg(e) {
  var t = xn();
  return typeof e == "function" && (e = e()),
  t.memoizedState = t.baseState = e,
  e = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: ka,
      lastRenderedState: e
  },
  t.queue = e,
  e = e.dispatch = o5.bind(null, Oe, e),
  [t.memoizedState, e]
}
function Da(e, t, n, r) {
  return e = {
      tag: e,
      create: t,
      destroy: n,
      deps: r,
      next: null
  },
  t = Oe.updateQueue,
  t === null ? (t = {
      lastEffect: null,
      stores: null
  },
  Oe.updateQueue = t,
  t.lastEffect = e.next = e) : (n = t.lastEffect,
  n === null ? t.lastEffect = e.next = e : (r = n.next,
  n.next = e,
  e.next = r,
  t.lastEffect = e)),
  e
}
function Lb() {
  return tn().memoizedState
}
function Du(e, t, n, r) {
  var i = xn();
  Oe.flags |= e,
  i.memoizedState = Da(1 | t, n, void 0, r === void 0 ? null : r)
}
function ac(e, t, n, r) {
  var i = tn();
  r = r === void 0 ? null : r;
  var s = void 0;
  if (qe !== null) {
      var a = qe.memoizedState;
      if (s = a.destroy,
      r !== null && om(r, a.deps)) {
          i.memoizedState = Da(t, n, s, r);
          return
      }
  }
  Oe.flags |= e,
  i.memoizedState = Da(1 | t, n, s, r)
}
function Lg(e, t) {
  return Du(8390656, 8, e, t)
}
function cm(e, t) {
  return ac(2048, 8, e, t)
}
function Fb(e, t) {
  return ac(4, 2, e, t)
}
function Ub(e, t) {
  return ac(4, 4, e, t)
}
function zb(e, t) {
  if (typeof t == "function")
      return e = e(),
      t(e),
      function() {
          t(null)
      }
      ;
  if (t != null)
      return e = e(),
      t.current = e,
      function() {
          t.current = null
      }
}
function Bb(e, t, n) {
  return n = n != null ? n.concat([e]) : null,
  ac(4, 4, zb.bind(null, t, e), n)
}
function fm() {}
function Wb(e, t) {
  var n = tn();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && om(t, r[1]) ? r[0] : (n.memoizedState = [e, t],
  e)
}
function Hb(e, t) {
  var n = tn();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && om(t, r[1]) ? r[0] : (e = e(),
  n.memoizedState = [e, t],
  e)
}
function qb(e, t, n) {
  return di & 21 ? (hn(n, t) || (n = Gw(),
  Oe.lanes |= n,
  pi |= n,
  e.baseState = !0),
  t) : (e.baseState && (e.baseState = !1,
  Tt = !0),
  e.memoizedState = n)
}
function s5(e, t) {
  var n = de;
  de = n !== 0 && 4 > n ? n : 4,
  e(!0);
  var r = Lf.transition;
  Lf.transition = {};
  try {
      e(!1),
      t()
  } finally {
      de = n,
      Lf.transition = r
  }
}
function Vb() {
  return tn().memoizedState
}
function a5(e, t, n) {
  var r = Cr(e);
  if (n = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null
  },
  Kb(e))
      Gb(t, n);
  else if (n = Cb(e, t, n, r),
  n !== null) {
      var i = xt();
      pn(n, e, r, i),
      Qb(n, t, r)
  }
}
function o5(e, t, n) {
  var r = Cr(e)
    , i = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null
  };
  if (Kb(e))
      Gb(t, i);
  else {
      var s = e.alternate;
      if (e.lanes === 0 && (s === null || s.lanes === 0) && (s = t.lastRenderedReducer,
      s !== null))
          try {
              var a = t.lastRenderedState
                , o = s(a, n);
              if (i.hasEagerState = !0,
              i.eagerState = o,
              hn(o, a)) {
                  var u = t.interleaved;
                  u === null ? (i.next = i,
                  nm(t)) : (i.next = u.next,
                  u.next = i),
                  t.interleaved = i;
                  return
              }
          } catch {} finally {}
      n = Cb(e, t, i, r),
      n !== null && (i = xt(),
      pn(n, e, r, i),
      Qb(n, t, r))
  }
}
function Kb(e) {
  var t = e.alternate;
  return e === Oe || t !== null && t === Oe
}
function Gb(e, t) {
  ua = fl = !0;
  var n = e.pending;
  n === null ? t.next = t : (t.next = n.next,
  n.next = t),
  e.pending = t
}
function Qb(e, t, n) {
  if (n & 4194240) {
      var r = t.lanes;
      r &= e.pendingLanes,
      n |= r,
      t.lanes = n,
      Bh(e, n)
  }
}
var dl = {
  readContext: en,
  useCallback: ft,
  useContext: ft,
  useEffect: ft,
  useImperativeHandle: ft,
  useInsertionEffect: ft,
  useLayoutEffect: ft,
  useMemo: ft,
  useReducer: ft,
  useRef: ft,
  useState: ft,
  useDebugValue: ft,
  useDeferredValue: ft,
  useTransition: ft,
  useMutableSource: ft,
  useSyncExternalStore: ft,
  useId: ft,
  unstable_isNewReconciler: !1
}
, u5 = {
  readContext: en,
  useCallback: function(e, t) {
      return xn().memoizedState = [e, t === void 0 ? null : t],
      e
  },
  useContext: en,
  useEffect: Lg,
  useImperativeHandle: function(e, t, n) {
      return n = n != null ? n.concat([e]) : null,
      Du(4194308, 4, zb.bind(null, t, e), n)
  },
  useLayoutEffect: function(e, t) {
      return Du(4194308, 4, e, t)
  },
  useInsertionEffect: function(e, t) {
      return Du(4, 2, e, t)
  },
  useMemo: function(e, t) {
      var n = xn();
      return t = t === void 0 ? null : t,
      e = e(),
      n.memoizedState = [e, t],
      e
  },
  useReducer: function(e, t, n) {
      var r = xn();
      return t = n !== void 0 ? n(t) : t,
      r.memoizedState = r.baseState = t,
      e = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: e,
          lastRenderedState: t
      },
      r.queue = e,
      e = e.dispatch = a5.bind(null, Oe, e),
      [r.memoizedState, e]
  },
  useRef: function(e) {
      var t = xn();
      return e = {
          current: e
      },
      t.memoizedState = e
  },
  useState: Mg,
  useDebugValue: fm,
  useDeferredValue: function(e) {
      return xn().memoizedState = e
  },
  useTransition: function() {
      var e = Mg(!1)
        , t = e[0];
      return e = s5.bind(null, e[1]),
      xn().memoizedState = e,
      [t, e]
  },
  useMutableSource: function() {},
  useSyncExternalStore: function(e, t, n) {
      var r = Oe
        , i = xn();
      if (Ee) {
          if (n === void 0)
              throw Error(H(407));
          n = n()
      } else {
          if (n = t(),
          Je === null)
              throw Error(H(349));
          di & 30 || $b(r, t, n)
      }
      i.memoizedState = n;
      var s = {
          value: n,
          getSnapshot: t
      };
      return i.queue = s,
      Lg(Nb.bind(null, r, s, e), [e]),
      r.flags |= 2048,
      Da(9, Rb.bind(null, r, s, n, t), void 0, null),
      n
  },
  useId: function() {
      var e = xn()
        , t = Je.identifierPrefix;
      if (Ee) {
          var n = Fn
            , r = Ln;
          n = (r & ~(1 << 32 - dn(r) - 1)).toString(32) + n,
          t = ":" + t + "R" + n,
          n = Oa++,
          0 < n && (t += "H" + n.toString(32)),
          t += ":"
      } else
          n = i5++,
          t = ":" + t + "r" + n.toString(32) + ":";
      return e.memoizedState = t
  },
  unstable_isNewReconciler: !1
}
, l5 = {
  readContext: en,
  useCallback: Wb,
  useContext: en,
  useEffect: cm,
  useImperativeHandle: Bb,
  useInsertionEffect: Fb,
  useLayoutEffect: Ub,
  useMemo: Hb,
  useReducer: Ff,
  useRef: Lb,
  useState: function() {
      return Ff(ka)
  },
  useDebugValue: fm,
  useDeferredValue: function(e) {
      var t = tn();
      return qb(t, qe.memoizedState, e)
  },
  useTransition: function() {
      var e = Ff(ka)[0]
        , t = tn().memoizedState;
      return [e, t]
  },
  useMutableSource: Ib,
  useSyncExternalStore: Ab,
  useId: Vb,
  unstable_isNewReconciler: !1
}
, c5 = {
  readContext: en,
  useCallback: Wb,
  useContext: en,
  useEffect: cm,
  useImperativeHandle: Bb,
  useInsertionEffect: Fb,
  useLayoutEffect: Ub,
  useMemo: Hb,
  useReducer: Uf,
  useRef: Lb,
  useState: function() {
      return Uf(ka)
  },
  useDebugValue: fm,
  useDeferredValue: function(e) {
      var t = tn();
      return qe === null ? t.memoizedState = e : qb(t, qe.memoizedState, e)
  },
  useTransition: function() {
      var e = Uf(ka)[0]
        , t = tn().memoizedState;
      return [e, t]
  },
  useMutableSource: Ib,
  useSyncExternalStore: Ab,
  useId: Vb,
  unstable_isNewReconciler: !1
};
function ls(e, t) {
  try {
      var n = ""
        , r = t;
      do
          n += L6(r),
          r = r.return;
      while (r);
      var i = n
  } catch (s) {
      i = `
Error generating stack: ` + s.message + `
` + s.stack
  }
  return {
      value: e,
      source: t,
      stack: i,
      digest: null
  }
}
function zf(e, t, n) {
  return {
      value: e,
      source: null,
      stack: n ?? null,
      digest: t ?? null
  }
}
function rp(e, t) {
  try {
      console.error(t.value)
  } catch (n) {
      setTimeout(function() {
          throw n
      })
  }
}
var f5 = typeof WeakMap == "function" ? WeakMap : Map;
function Yb(e, t, n) {
  n = zn(-1, n),
  n.tag = 3,
  n.payload = {
      element: null
  };
  var r = t.value;
  return n.callback = function() {
      hl || (hl = !0,
      pp = r),
      rp(e, t)
  }
  ,
  n
}
function Xb(e, t, n) {
  n = zn(-1, n),
  n.tag = 3;
  var r = e.type.getDerivedStateFromError;
  if (typeof r == "function") {
      var i = t.value;
      n.payload = function() {
          return r(i)
      }
      ,
      n.callback = function() {
          rp(e, t)
      }
  }
  var s = e.stateNode;
  return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function() {
      rp(e, t),
      typeof r != "function" && (Sr === null ? Sr = new Set([this]) : Sr.add(this));
      var a = t.stack;
      this.componentDidCatch(t.value, {
          componentStack: a !== null ? a : ""
      })
  }
  ),
  n
}
function Fg(e, t, n) {
  var r = e.pingCache;
  if (r === null) {
      r = e.pingCache = new f5;
      var i = new Set;
      r.set(t, i)
  } else
      i = r.get(t),
      i === void 0 && (i = new Set,
      r.set(t, i));
  i.has(n) || (i.add(n),
  e = _5.bind(null, e, t, n),
  t.then(e, e))
}
function Ug(e) {
  do {
      var t;
      if ((t = e.tag === 13) && (t = e.memoizedState,
      t = t !== null ? t.dehydrated !== null : !0),
      t)
          return e;
      e = e.return
  } while (e !== null);
  return null
}
function zg(e, t, n, r, i) {
  return e.mode & 1 ? (e.flags |= 65536,
  e.lanes = i,
  e) : (e === t ? e.flags |= 65536 : (e.flags |= 128,
  n.flags |= 131072,
  n.flags &= -52805,
  n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = zn(-1, 1),
  t.tag = 2,
  Er(n, t, 1))),
  n.lanes |= 1),
  e)
}
var d5 = Jn.ReactCurrentOwner
, Tt = !1;
function wt(e, t, n, r) {
  t.child = e === null ? kb(t, null, n, r) : os(t, e.child, n, r)
}
function Bg(e, t, n, r, i) {
  n = n.render;
  var s = t.ref;
  return es(t, i),
  r = um(e, t, n, r, s, i),
  n = lm(),
  e !== null && !Tt ? (t.updateQueue = e.updateQueue,
  t.flags &= -2053,
  e.lanes &= ~i,
  Kn(e, t, i)) : (Ee && n && Yh(t),
  t.flags |= 1,
  wt(e, t, r, i),
  t.child)
}
function Wg(e, t, n, r, i) {
  if (e === null) {
      var s = n.type;
      return typeof s == "function" && !wm(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15,
      t.type = s,
      Jb(e, t, s, r, i)) : (e = Ru(n.type, null, r, t, t.mode, i),
      e.ref = t.ref,
      e.return = t,
      t.child = e)
  }
  if (s = e.child,
  !(e.lanes & i)) {
      var a = s.memoizedProps;
      if (n = n.compare,
      n = n !== null ? n : Ea,
      n(a, r) && e.ref === t.ref)
          return Kn(e, t, i)
  }
  return t.flags |= 1,
  e = _r(s, r),
  e.ref = t.ref,
  e.return = t,
  t.child = e
}
function Jb(e, t, n, r, i) {
  if (e !== null) {
      var s = e.memoizedProps;
      if (Ea(s, r) && e.ref === t.ref)
          if (Tt = !1,
          t.pendingProps = r = s,
          (e.lanes & i) !== 0)
              e.flags & 131072 && (Tt = !0);
          else
              return t.lanes = e.lanes,
              Kn(e, t, i)
  }
  return ip(e, t, n, r, i)
}
function Zb(e, t, n) {
  var r = t.pendingProps
    , i = r.children
    , s = e !== null ? e.memoizedState : null;
  if (r.mode === "hidden")
      if (!(t.mode & 1))
          t.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null
          },
          ge(qi, Rt),
          Rt |= n;
      else {
          if (!(n & 1073741824))
              return e = s !== null ? s.baseLanes | n : n,
              t.lanes = t.childLanes = 1073741824,
              t.memoizedState = {
                  baseLanes: e,
                  cachePool: null,
                  transitions: null
              },
              t.updateQueue = null,
              ge(qi, Rt),
              Rt |= e,
              null;
          t.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null
          },
          r = s !== null ? s.baseLanes : n,
          ge(qi, Rt),
          Rt |= r
      }
  else
      s !== null ? (r = s.baseLanes | n,
      t.memoizedState = null) : r = n,
      ge(qi, Rt),
      Rt |= r;
  return wt(e, t, i, n),
  t.child
}
function e2(e, t) {
  var n = t.ref;
  (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512,
  t.flags |= 2097152)
}
function ip(e, t, n, r, i) {
  var s = kt(n) ? ci : gt.current;
  return s = ss(t, s),
  es(t, i),
  n = um(e, t, n, r, s, i),
  r = lm(),
  e !== null && !Tt ? (t.updateQueue = e.updateQueue,
  t.flags &= -2053,
  e.lanes &= ~i,
  Kn(e, t, i)) : (Ee && r && Yh(t),
  t.flags |= 1,
  wt(e, t, n, i),
  t.child)
}
function Hg(e, t, n, r, i) {
  if (kt(n)) {
      var s = !0;
      il(t)
  } else
      s = !1;
  if (es(t, i),
  t.stateNode === null)
      Iu(e, t),
      Tb(t, n, r),
      np(t, n, r, i),
      r = !0;
  else if (e === null) {
      var a = t.stateNode
        , o = t.memoizedProps;
      a.props = o;
      var u = a.context
        , l = n.contextType;
      typeof l == "object" && l !== null ? l = en(l) : (l = kt(n) ? ci : gt.current,
      l = ss(t, l));
      var c = n.getDerivedStateFromProps
        , f = typeof c == "function" || typeof a.getSnapshotBeforeUpdate == "function";
      f || typeof a.UNSAFE_componentWillReceiveProps != "function" && typeof a.componentWillReceiveProps != "function" || (o !== r || u !== l) && Ng(t, a, r, l),
      or = !1;
      var d = t.memoizedState;
      a.state = d,
      ll(t, r, a, i),
      u = t.memoizedState,
      o !== r || d !== u || Ot.current || or ? (typeof c == "function" && (tp(t, n, c, r),
      u = t.memoizedState),
      (o = or || Rg(t, n, o, r, d, u, l)) ? (f || typeof a.UNSAFE_componentWillMount != "function" && typeof a.componentWillMount != "function" || (typeof a.componentWillMount == "function" && a.componentWillMount(),
      typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount()),
      typeof a.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof a.componentDidMount == "function" && (t.flags |= 4194308),
      t.memoizedProps = r,
      t.memoizedState = u),
      a.props = r,
      a.state = u,
      a.context = l,
      r = o) : (typeof a.componentDidMount == "function" && (t.flags |= 4194308),
      r = !1)
  } else {
      a = t.stateNode,
      _b(e, t),
      o = t.memoizedProps,
      l = t.type === t.elementType ? o : un(t.type, o),
      a.props = l,
      f = t.pendingProps,
      d = a.context,
      u = n.contextType,
      typeof u == "object" && u !== null ? u = en(u) : (u = kt(n) ? ci : gt.current,
      u = ss(t, u));
      var y = n.getDerivedStateFromProps;
      (c = typeof y == "function" || typeof a.getSnapshotBeforeUpdate == "function") || typeof a.UNSAFE_componentWillReceiveProps != "function" && typeof a.componentWillReceiveProps != "function" || (o !== f || d !== u) && Ng(t, a, r, u),
      or = !1,
      d = t.memoizedState,
      a.state = d,
      ll(t, r, a, i);
      var m = t.memoizedState;
      o !== f || d !== m || Ot.current || or ? (typeof y == "function" && (tp(t, n, y, r),
      m = t.memoizedState),
      (l = or || Rg(t, n, l, r, d, m, u) || !1) ? (c || typeof a.UNSAFE_componentWillUpdate != "function" && typeof a.componentWillUpdate != "function" || (typeof a.componentWillUpdate == "function" && a.componentWillUpdate(r, m, u),
      typeof a.UNSAFE_componentWillUpdate == "function" && a.UNSAFE_componentWillUpdate(r, m, u)),
      typeof a.componentDidUpdate == "function" && (t.flags |= 4),
      typeof a.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof a.componentDidUpdate != "function" || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 4),
      typeof a.getSnapshotBeforeUpdate != "function" || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024),
      t.memoizedProps = r,
      t.memoizedState = m),
      a.props = r,
      a.state = m,
      a.context = u,
      r = l) : (typeof a.componentDidUpdate != "function" || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 4),
      typeof a.getSnapshotBeforeUpdate != "function" || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024),
      r = !1)
  }
  return sp(e, t, n, r, s, i)
}
function sp(e, t, n, r, i, s) {
  e2(e, t);
  var a = (t.flags & 128) !== 0;
  if (!r && !a)
      return i && kg(t, n, !1),
      Kn(e, t, s);
  r = t.stateNode,
  d5.current = t;
  var o = a && typeof n.getDerivedStateFromError != "function" ? null : r.render();
  return t.flags |= 1,
  e !== null && a ? (t.child = os(t, e.child, null, s),
  t.child = os(t, null, o, s)) : wt(e, t, o, s),
  t.memoizedState = r.state,
  i && kg(t, n, !0),
  t.child
}
function t2(e) {
  var t = e.stateNode;
  t.pendingContext ? Og(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Og(e, t.context, !1),
  im(e, t.containerInfo)
}
function qg(e, t, n, r, i) {
  return as(),
  Jh(i),
  t.flags |= 256,
  wt(e, t, n, r),
  t.child
}
var ap = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0
};
function op(e) {
  return {
      baseLanes: e,
      cachePool: null,
      transitions: null
  }
}
function n2(e, t, n) {
  var r = t.pendingProps, i = _e.current, s = !1, a = (t.flags & 128) !== 0, o;
  if ((o = a) || (o = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0),
  o ? (s = !0,
  t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1),
  ge(_e, i & 1),
  e === null)
      return Zd(t),
      e = t.memoizedState,
      e !== null && (e = e.dehydrated,
      e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1,
      null) : (a = r.children,
      e = r.fallback,
      s ? (r = t.mode,
      s = t.child,
      a = {
          mode: "hidden",
          children: a
      },
      !(r & 1) && s !== null ? (s.childLanes = 0,
      s.pendingProps = a) : s = lc(a, r, 0, null),
      e = ai(e, r, n, null),
      s.return = t,
      e.return = t,
      s.sibling = e,
      t.child = s,
      t.child.memoizedState = op(n),
      t.memoizedState = ap,
      e) : dm(t, a));
  if (i = e.memoizedState,
  i !== null && (o = i.dehydrated,
  o !== null))
      return p5(e, t, a, r, o, i, n);
  if (s) {
      s = r.fallback,
      a = t.mode,
      i = e.child,
      o = i.sibling;
      var u = {
          mode: "hidden",
          children: r.children
      };
      return !(a & 1) && t.child !== i ? (r = t.child,
      r.childLanes = 0,
      r.pendingProps = u,
      t.deletions = null) : (r = _r(i, u),
      r.subtreeFlags = i.subtreeFlags & 14680064),
      o !== null ? s = _r(o, s) : (s = ai(s, a, n, null),
      s.flags |= 2),
      s.return = t,
      r.return = t,
      r.sibling = s,
      t.child = r,
      r = s,
      s = t.child,
      a = e.child.memoizedState,
      a = a === null ? op(n) : {
          baseLanes: a.baseLanes | n,
          cachePool: null,
          transitions: a.transitions
      },
      s.memoizedState = a,
      s.childLanes = e.childLanes & ~n,
      t.memoizedState = ap,
      r
  }
  return s = e.child,
  e = s.sibling,
  r = _r(s, {
      mode: "visible",
      children: r.children
  }),
  !(t.mode & 1) && (r.lanes = n),
  r.return = t,
  r.sibling = null,
  e !== null && (n = t.deletions,
  n === null ? (t.deletions = [e],
  t.flags |= 16) : n.push(e)),
  t.child = r,
  t.memoizedState = null,
  r
}
function dm(e, t) {
  return t = lc({
      mode: "visible",
      children: t
  }, e.mode, 0, null),
  t.return = e,
  e.child = t
}
function Jo(e, t, n, r) {
  return r !== null && Jh(r),
  os(t, e.child, null, n),
  e = dm(t, t.pendingProps.children),
  e.flags |= 2,
  t.memoizedState = null,
  e
}
function p5(e, t, n, r, i, s, a) {
  if (n)
      return t.flags & 256 ? (t.flags &= -257,
      r = zf(Error(H(422))),
      Jo(e, t, a, r)) : t.memoizedState !== null ? (t.child = e.child,
      t.flags |= 128,
      null) : (s = r.fallback,
      i = t.mode,
      r = lc({
          mode: "visible",
          children: r.children
      }, i, 0, null),
      s = ai(s, i, a, null),
      s.flags |= 2,
      r.return = t,
      s.return = t,
      r.sibling = s,
      t.child = r,
      t.mode & 1 && os(t, e.child, null, a),
      t.child.memoizedState = op(a),
      t.memoizedState = ap,
      s);
  if (!(t.mode & 1))
      return Jo(e, t, a, null);
  if (i.data === "$!") {
      if (r = i.nextSibling && i.nextSibling.dataset,
      r)
          var o = r.dgst;
      return r = o,
      s = Error(H(419)),
      r = zf(s, r, void 0),
      Jo(e, t, a, r)
  }
  if (o = (a & e.childLanes) !== 0,
  Tt || o) {
      if (r = Je,
      r !== null) {
          switch (a & -a) {
          case 4:
              i = 2;
              break;
          case 16:
              i = 8;
              break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
              i = 32;
              break;
          case 536870912:
              i = 268435456;
              break;
          default:
              i = 0
          }
          i = i & (r.suspendedLanes | a) ? 0 : i,
          i !== 0 && i !== s.retryLane && (s.retryLane = i,
          Vn(e, i),
          pn(r, e, i, -1))
      }
      return vm(),
      r = zf(Error(H(421))),
      Jo(e, t, a, r)
  }
  return i.data === "$?" ? (t.flags |= 128,
  t.child = e.child,
  t = P5.bind(null, e),
  i._reactRetry = t,
  null) : (e = s.treeContext,
  Nt = xr(i.nextSibling),
  Lt = t,
  Ee = !0,
  cn = null,
  e !== null && (Qt[Yt++] = Ln,
  Qt[Yt++] = Fn,
  Qt[Yt++] = fi,
  Ln = e.id,
  Fn = e.overflow,
  fi = t),
  t = dm(t, r.children),
  t.flags |= 4096,
  t)
}
function Vg(e, t, n) {
  e.lanes |= t;
  var r = e.alternate;
  r !== null && (r.lanes |= t),
  ep(e.return, t, n)
}
function Bf(e, t, n, r, i) {
  var s = e.memoizedState;
  s === null ? e.memoizedState = {
      isBackwards: t,
      rendering: null,
      renderingStartTime: 0,
      last: r,
      tail: n,
      tailMode: i
  } : (s.isBackwards = t,
  s.rendering = null,
  s.renderingStartTime = 0,
  s.last = r,
  s.tail = n,
  s.tailMode = i)
}
function r2(e, t, n) {
  var r = t.pendingProps
    , i = r.revealOrder
    , s = r.tail;
  if (wt(e, t, r.children, n),
  r = _e.current,
  r & 2)
      r = r & 1 | 2,
      t.flags |= 128;
  else {
      if (e !== null && e.flags & 128)
          e: for (e = t.child; e !== null; ) {
              if (e.tag === 13)
                  e.memoizedState !== null && Vg(e, n, t);
              else if (e.tag === 19)
                  Vg(e, n, t);
              else if (e.child !== null) {
                  e.child.return = e,
                  e = e.child;
                  continue
              }
              if (e === t)
                  break e;
              for (; e.sibling === null; ) {
                  if (e.return === null || e.return === t)
                      break e;
                  e = e.return
              }
              e.sibling.return = e.return,
              e = e.sibling
          }
      r &= 1
  }
  if (ge(_e, r),
  !(t.mode & 1))
      t.memoizedState = null;
  else
      switch (i) {
      case "forwards":
          for (n = t.child,
          i = null; n !== null; )
              e = n.alternate,
              e !== null && cl(e) === null && (i = n),
              n = n.sibling;
          n = i,
          n === null ? (i = t.child,
          t.child = null) : (i = n.sibling,
          n.sibling = null),
          Bf(t, !1, i, n, s);
          break;
      case "backwards":
          for (n = null,
          i = t.child,
          t.child = null; i !== null; ) {
              if (e = i.alternate,
              e !== null && cl(e) === null) {
                  t.child = i;
                  break
              }
              e = i.sibling,
              i.sibling = n,
              n = i,
              i = e
          }
          Bf(t, !0, n, null, s);
          break;
      case "together":
          Bf(t, !1, null, null, void 0);
          break;
      default:
          t.memoizedState = null
      }
  return t.child
}
function Iu(e, t) {
  !(t.mode & 1) && e !== null && (e.alternate = null,
  t.alternate = null,
  t.flags |= 2)
}
function Kn(e, t, n) {
  if (e !== null && (t.dependencies = e.dependencies),
  pi |= t.lanes,
  !(n & t.childLanes))
      return null;
  if (e !== null && t.child !== e.child)
      throw Error(H(153));
  if (t.child !== null) {
      for (e = t.child,
      n = _r(e, e.pendingProps),
      t.child = n,
      n.return = t; e.sibling !== null; )
          e = e.sibling,
          n = n.sibling = _r(e, e.pendingProps),
          n.return = t;
      n.sibling = null
  }
  return t.child
}
function h5(e, t, n) {
  switch (t.tag) {
  case 3:
      t2(t),
      as();
      break;
  case 5:
      Db(t);
      break;
  case 1:
      kt(t.type) && il(t);
      break;
  case 4:
      im(t, t.stateNode.containerInfo);
      break;
  case 10:
      var r = t.type._context
        , i = t.memoizedProps.value;
      ge(ol, r._currentValue),
      r._currentValue = i;
      break;
  case 13:
      if (r = t.memoizedState,
      r !== null)
          return r.dehydrated !== null ? (ge(_e, _e.current & 1),
          t.flags |= 128,
          null) : n & t.child.childLanes ? n2(e, t, n) : (ge(_e, _e.current & 1),
          e = Kn(e, t, n),
          e !== null ? e.sibling : null);
      ge(_e, _e.current & 1);
      break;
  case 19:
      if (r = (n & t.childLanes) !== 0,
      e.flags & 128) {
          if (r)
              return r2(e, t, n);
          t.flags |= 128
      }
      if (i = t.memoizedState,
      i !== null && (i.rendering = null,
      i.tail = null,
      i.lastEffect = null),
      ge(_e, _e.current),
      r)
          break;
      return null;
  case 22:
  case 23:
      return t.lanes = 0,
      Zb(e, t, n)
  }
  return Kn(e, t, n)
}
var i2, up, s2, a2;
i2 = function(e, t) {
  for (var n = t.child; n !== null; ) {
      if (n.tag === 5 || n.tag === 6)
          e.appendChild(n.stateNode);
      else if (n.tag !== 4 && n.child !== null) {
          n.child.return = n,
          n = n.child;
          continue
      }
      if (n === t)
          break;
      for (; n.sibling === null; ) {
          if (n.return === null || n.return === t)
              return;
          n = n.return
      }
      n.sibling.return = n.return,
      n = n.sibling
  }
}
;
up = function() {}
;
s2 = function(e, t, n, r) {
  var i = e.memoizedProps;
  if (i !== r) {
      e = t.stateNode,
      ni(On.current);
      var s = null;
      switch (n) {
      case "input":
          i = Dd(e, i),
          r = Dd(e, r),
          s = [];
          break;
      case "select":
          i = ke({}, i, {
              value: void 0
          }),
          r = ke({}, r, {
              value: void 0
          }),
          s = [];
          break;
      case "textarea":
          i = $d(e, i),
          r = $d(e, r),
          s = [];
          break;
      default:
          typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = nl)
      }
      Nd(n, r);
      var a;
      n = null;
      for (l in i)
          if (!r.hasOwnProperty(l) && i.hasOwnProperty(l) && i[l] != null)
              if (l === "style") {
                  var o = i[l];
                  for (a in o)
                      o.hasOwnProperty(a) && (n || (n = {}),
                      n[a] = "")
              } else
                  l !== "dangerouslySetInnerHTML" && l !== "children" && l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (ma.hasOwnProperty(l) ? s || (s = []) : (s = s || []).push(l, null));
      for (l in r) {
          var u = r[l];
          if (o = i != null ? i[l] : void 0,
          r.hasOwnProperty(l) && u !== o && (u != null || o != null))
              if (l === "style")
                  if (o) {
                      for (a in o)
                          !o.hasOwnProperty(a) || u && u.hasOwnProperty(a) || (n || (n = {}),
                          n[a] = "");
                      for (a in u)
                          u.hasOwnProperty(a) && o[a] !== u[a] && (n || (n = {}),
                          n[a] = u[a])
                  } else
                      n || (s || (s = []),
                      s.push(l, n)),
                      n = u;
              else
                  l === "dangerouslySetInnerHTML" ? (u = u ? u.__html : void 0,
                  o = o ? o.__html : void 0,
                  u != null && o !== u && (s = s || []).push(l, u)) : l === "children" ? typeof u != "string" && typeof u != "number" || (s = s || []).push(l, "" + u) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && (ma.hasOwnProperty(l) ? (u != null && l === "onScroll" && we("scroll", e),
                  s || o === u || (s = [])) : (s = s || []).push(l, u))
      }
      n && (s = s || []).push("style", n);
      var l = s;
      (t.updateQueue = l) && (t.flags |= 4)
  }
}
;
a2 = function(e, t, n, r) {
  n !== r && (t.flags |= 4)
}
;
function Us(e, t) {
  if (!Ee)
      switch (e.tailMode) {
      case "hidden":
          t = e.tail;
          for (var n = null; t !== null; )
              t.alternate !== null && (n = t),
              t = t.sibling;
          n === null ? e.tail = null : n.sibling = null;
          break;
      case "collapsed":
          n = e.tail;
          for (var r = null; n !== null; )
              n.alternate !== null && (r = n),
              n = n.sibling;
          r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null
      }
}
function dt(e) {
  var t = e.alternate !== null && e.alternate.child === e.child
    , n = 0
    , r = 0;
  if (t)
      for (var i = e.child; i !== null; )
          n |= i.lanes | i.childLanes,
          r |= i.subtreeFlags & 14680064,
          r |= i.flags & 14680064,
          i.return = e,
          i = i.sibling;
  else
      for (i = e.child; i !== null; )
          n |= i.lanes | i.childLanes,
          r |= i.subtreeFlags,
          r |= i.flags,
          i.return = e,
          i = i.sibling;
  return e.subtreeFlags |= r,
  e.childLanes = n,
  t
}
function m5(e, t, n) {
  var r = t.pendingProps;
  switch (Xh(t),
  t.tag) {
  case 2:
  case 16:
  case 15:
  case 0:
  case 11:
  case 7:
  case 8:
  case 12:
  case 9:
  case 14:
      return dt(t),
      null;
  case 1:
      return kt(t.type) && rl(),
      dt(t),
      null;
  case 3:
      return r = t.stateNode,
      us(),
      be(Ot),
      be(gt),
      am(),
      r.pendingContext && (r.context = r.pendingContext,
      r.pendingContext = null),
      (e === null || e.child === null) && (Yo(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024,
      cn !== null && (yp(cn),
      cn = null))),
      up(e, t),
      dt(t),
      null;
  case 5:
      sm(t);
      var i = ni(Ta.current);
      if (n = t.type,
      e !== null && t.stateNode != null)
          s2(e, t, n, r, i),
          e.ref !== t.ref && (t.flags |= 512,
          t.flags |= 2097152);
      else {
          if (!r) {
              if (t.stateNode === null)
                  throw Error(H(166));
              return dt(t),
              null
          }
          if (e = ni(On.current),
          Yo(t)) {
              r = t.stateNode,
              n = t.type;
              var s = t.memoizedProps;
              switch (r[Sn] = t,
              r[_a] = s,
              e = (t.mode & 1) !== 0,
              n) {
              case "dialog":
                  we("cancel", r),
                  we("close", r);
                  break;
              case "iframe":
              case "object":
              case "embed":
                  we("load", r);
                  break;
              case "video":
              case "audio":
                  for (i = 0; i < ea.length; i++)
                      we(ea[i], r);
                  break;
              case "source":
                  we("error", r);
                  break;
              case "img":
              case "image":
              case "link":
                  we("error", r),
                  we("load", r);
                  break;
              case "details":
                  we("toggle", r);
                  break;
              case "input":
                  tg(r, s),
                  we("invalid", r);
                  break;
              case "select":
                  r._wrapperState = {
                      wasMultiple: !!s.multiple
                  },
                  we("invalid", r);
                  break;
              case "textarea":
                  rg(r, s),
                  we("invalid", r)
              }
              Nd(n, s),
              i = null;
              for (var a in s)
                  if (s.hasOwnProperty(a)) {
                      var o = s[a];
                      a === "children" ? typeof o == "string" ? r.textContent !== o && (s.suppressHydrationWarning !== !0 && Qo(r.textContent, o, e),
                      i = ["children", o]) : typeof o == "number" && r.textContent !== "" + o && (s.suppressHydrationWarning !== !0 && Qo(r.textContent, o, e),
                      i = ["children", "" + o]) : ma.hasOwnProperty(a) && o != null && a === "onScroll" && we("scroll", r)
                  }
              switch (n) {
              case "input":
                  zo(r),
                  ng(r, s, !0);
                  break;
              case "textarea":
                  zo(r),
                  ig(r);
                  break;
              case "select":
              case "option":
                  break;
              default:
                  typeof s.onClick == "function" && (r.onclick = nl)
              }
              r = i,
              t.updateQueue = r,
              r !== null && (t.flags |= 4)
          } else {
              a = i.nodeType === 9 ? i : i.ownerDocument,
              e === "http://www.w3.org/1999/xhtml" && (e = $w(n)),
              e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = a.createElement("div"),
              e.innerHTML = "<script><\/script>",
              e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = a.createElement(n, {
                  is: r.is
              }) : (e = a.createElement(n),
              n === "select" && (a = e,
              r.multiple ? a.multiple = !0 : r.size && (a.size = r.size))) : e = a.createElementNS(e, n),
              e[Sn] = t,
              e[_a] = r,
              i2(e, t, !1, !1),
              t.stateNode = e;
              e: {
                  switch (a = jd(n, r),
                  n) {
                  case "dialog":
                      we("cancel", e),
                      we("close", e),
                      i = r;
                      break;
                  case "iframe":
                  case "object":
                  case "embed":
                      we("load", e),
                      i = r;
                      break;
                  case "video":
                  case "audio":
                      for (i = 0; i < ea.length; i++)
                          we(ea[i], e);
                      i = r;
                      break;
                  case "source":
                      we("error", e),
                      i = r;
                      break;
                  case "img":
                  case "image":
                  case "link":
                      we("error", e),
                      we("load", e),
                      i = r;
                      break;
                  case "details":
                      we("toggle", e),
                      i = r;
                      break;
                  case "input":
                      tg(e, r),
                      i = Dd(e, r),
                      we("invalid", e);
                      break;
                  case "option":
                      i = r;
                      break;
                  case "select":
                      e._wrapperState = {
                          wasMultiple: !!r.multiple
                      },
                      i = ke({}, r, {
                          value: void 0
                      }),
                      we("invalid", e);
                      break;
                  case "textarea":
                      rg(e, r),
                      i = $d(e, r),
                      we("invalid", e);
                      break;
                  default:
                      i = r
                  }
                  Nd(n, i),
                  o = i;
                  for (s in o)
                      if (o.hasOwnProperty(s)) {
                          var u = o[s];
                          s === "style" ? jw(e, u) : s === "dangerouslySetInnerHTML" ? (u = u ? u.__html : void 0,
                          u != null && Rw(e, u)) : s === "children" ? typeof u == "string" ? (n !== "textarea" || u !== "") && ya(e, u) : typeof u == "number" && ya(e, "" + u) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (ma.hasOwnProperty(s) ? u != null && s === "onScroll" && we("scroll", e) : u != null && jh(e, s, u, a))
                      }
                  switch (n) {
                  case "input":
                      zo(e),
                      ng(e, r, !1);
                      break;
                  case "textarea":
                      zo(e),
                      ig(e);
                      break;
                  case "option":
                      r.value != null && e.setAttribute("value", "" + Ir(r.value));
                      break;
                  case "select":
                      e.multiple = !!r.multiple,
                      s = r.value,
                      s != null ? Yi(e, !!r.multiple, s, !1) : r.defaultValue != null && Yi(e, !!r.multiple, r.defaultValue, !0);
                      break;
                  default:
                      typeof i.onClick == "function" && (e.onclick = nl)
                  }
                  switch (n) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                      r = !!r.autoFocus;
                      break e;
                  case "img":
                      r = !0;
                      break e;
                  default:
                      r = !1
                  }
              }
              r && (t.flags |= 4)
          }
          t.ref !== null && (t.flags |= 512,
          t.flags |= 2097152)
      }
      return dt(t),
      null;
  case 6:
      if (e && t.stateNode != null)
          a2(e, t, e.memoizedProps, r);
      else {
          if (typeof r != "string" && t.stateNode === null)
              throw Error(H(166));
          if (n = ni(Ta.current),
          ni(On.current),
          Yo(t)) {
              if (r = t.stateNode,
              n = t.memoizedProps,
              r[Sn] = t,
              (s = r.nodeValue !== n) && (e = Lt,
              e !== null))
                  switch (e.tag) {
                  case 3:
                      Qo(r.nodeValue, n, (e.mode & 1) !== 0);
                      break;
                  case 5:
                      e.memoizedProps.suppressHydrationWarning !== !0 && Qo(r.nodeValue, n, (e.mode & 1) !== 0)
                  }
              s && (t.flags |= 4)
          } else
              r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r),
              r[Sn] = t,
              t.stateNode = r
      }
      return dt(t),
      null;
  case 13:
      if (be(_e),
      r = t.memoizedState,
      e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
          if (Ee && Nt !== null && t.mode & 1 && !(t.flags & 128))
              Sb(),
              as(),
              t.flags |= 98560,
              s = !1;
          else if (s = Yo(t),
          r !== null && r.dehydrated !== null) {
              if (e === null) {
                  if (!s)
                      throw Error(H(318));
                  if (s = t.memoizedState,
                  s = s !== null ? s.dehydrated : null,
                  !s)
                      throw Error(H(317));
                  s[Sn] = t
              } else
                  as(),
                  !(t.flags & 128) && (t.memoizedState = null),
                  t.flags |= 4;
              dt(t),
              s = !1
          } else
              cn !== null && (yp(cn),
              cn = null),
              s = !0;
          if (!s)
              return t.flags & 65536 ? t : null
      }
      return t.flags & 128 ? (t.lanes = n,
      t) : (r = r !== null,
      r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192,
      t.mode & 1 && (e === null || _e.current & 1 ? Ve === 0 && (Ve = 3) : vm())),
      t.updateQueue !== null && (t.flags |= 4),
      dt(t),
      null);
  case 4:
      return us(),
      up(e, t),
      e === null && Sa(t.stateNode.containerInfo),
      dt(t),
      null;
  case 10:
      return tm(t.type._context),
      dt(t),
      null;
  case 17:
      return kt(t.type) && rl(),
      dt(t),
      null;
  case 19:
      if (be(_e),
      s = t.memoizedState,
      s === null)
          return dt(t),
          null;
      if (r = (t.flags & 128) !== 0,
      a = s.rendering,
      a === null)
          if (r)
              Us(s, !1);
          else {
              if (Ve !== 0 || e !== null && e.flags & 128)
                  for (e = t.child; e !== null; ) {
                      if (a = cl(e),
                      a !== null) {
                          for (t.flags |= 128,
                          Us(s, !1),
                          r = a.updateQueue,
                          r !== null && (t.updateQueue = r,
                          t.flags |= 4),
                          t.subtreeFlags = 0,
                          r = n,
                          n = t.child; n !== null; )
                              s = n,
                              e = r,
                              s.flags &= 14680066,
                              a = s.alternate,
                              a === null ? (s.childLanes = 0,
                              s.lanes = e,
                              s.child = null,
                              s.subtreeFlags = 0,
                              s.memoizedProps = null,
                              s.memoizedState = null,
                              s.updateQueue = null,
                              s.dependencies = null,
                              s.stateNode = null) : (s.childLanes = a.childLanes,
                              s.lanes = a.lanes,
                              s.child = a.child,
                              s.subtreeFlags = 0,
                              s.deletions = null,
                              s.memoizedProps = a.memoizedProps,
                              s.memoizedState = a.memoizedState,
                              s.updateQueue = a.updateQueue,
                              s.type = a.type,
                              e = a.dependencies,
                              s.dependencies = e === null ? null : {
                                  lanes: e.lanes,
                                  firstContext: e.firstContext
                              }),
                              n = n.sibling;
                          return ge(_e, _e.current & 1 | 2),
                          t.child
                      }
                      e = e.sibling
                  }
              s.tail !== null && Le() > cs && (t.flags |= 128,
              r = !0,
              Us(s, !1),
              t.lanes = 4194304)
          }
      else {
          if (!r)
              if (e = cl(a),
              e !== null) {
                  if (t.flags |= 128,
                  r = !0,
                  n = e.updateQueue,
                  n !== null && (t.updateQueue = n,
                  t.flags |= 4),
                  Us(s, !0),
                  s.tail === null && s.tailMode === "hidden" && !a.alternate && !Ee)
                      return dt(t),
                      null
              } else
                  2 * Le() - s.renderingStartTime > cs && n !== 1073741824 && (t.flags |= 128,
                  r = !0,
                  Us(s, !1),
                  t.lanes = 4194304);
          s.isBackwards ? (a.sibling = t.child,
          t.child = a) : (n = s.last,
          n !== null ? n.sibling = a : t.child = a,
          s.last = a)
      }
      return s.tail !== null ? (t = s.tail,
      s.rendering = t,
      s.tail = t.sibling,
      s.renderingStartTime = Le(),
      t.sibling = null,
      n = _e.current,
      ge(_e, r ? n & 1 | 2 : n & 1),
      t) : (dt(t),
      null);
  case 22:
  case 23:
      return gm(),
      r = t.memoizedState !== null,
      e !== null && e.memoizedState !== null !== r && (t.flags |= 8192),
      r && t.mode & 1 ? Rt & 1073741824 && (dt(t),
      t.subtreeFlags & 6 && (t.flags |= 8192)) : dt(t),
      null;
  case 24:
      return null;
  case 25:
      return null
  }
  throw Error(H(156, t.tag))
}
function y5(e, t) {
  switch (Xh(t),
  t.tag) {
  case 1:
      return kt(t.type) && rl(),
      e = t.flags,
      e & 65536 ? (t.flags = e & -65537 | 128,
      t) : null;
  case 3:
      return us(),
      be(Ot),
      be(gt),
      am(),
      e = t.flags,
      e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128,
      t) : null;
  case 5:
      return sm(t),
      null;
  case 13:
      if (be(_e),
      e = t.memoizedState,
      e !== null && e.dehydrated !== null) {
          if (t.alternate === null)
              throw Error(H(340));
          as()
      }
      return e = t.flags,
      e & 65536 ? (t.flags = e & -65537 | 128,
      t) : null;
  case 19:
      return be(_e),
      null;
  case 4:
      return us(),
      null;
  case 10:
      return tm(t.type._context),
      null;
  case 22:
  case 23:
      return gm(),
      null;
  case 24:
      return null;
  default:
      return null
  }
}
var Zo = !1
, mt = !1
, g5 = typeof WeakSet == "function" ? WeakSet : Set
, Y = null;
function Hi(e, t) {
  var n = e.ref;
  if (n !== null)
      if (typeof n == "function")
          try {
              n(null)
          } catch (r) {
              Re(e, t, r)
          }
      else
          n.current = null
}
function lp(e, t, n) {
  try {
      n()
  } catch (r) {
      Re(e, t, r)
  }
}
var Kg = !1;
function v5(e, t) {
  if (Vd = Zu,
  e = cb(),
  Qh(e)) {
      if ("selectionStart"in e)
          var n = {
              start: e.selectionStart,
              end: e.selectionEnd
          };
      else
          e: {
              n = (n = e.ownerDocument) && n.defaultView || window;
              var r = n.getSelection && n.getSelection();
              if (r && r.rangeCount !== 0) {
                  n = r.anchorNode;
                  var i = r.anchorOffset
                    , s = r.focusNode;
                  r = r.focusOffset;
                  try {
                      n.nodeType,
                      s.nodeType
                  } catch {
                      n = null;
                      break e
                  }
                  var a = 0
                    , o = -1
                    , u = -1
                    , l = 0
                    , c = 0
                    , f = e
                    , d = null;
                  t: for (; ; ) {
                      for (var y; f !== n || i !== 0 && f.nodeType !== 3 || (o = a + i),
                      f !== s || r !== 0 && f.nodeType !== 3 || (u = a + r),
                      f.nodeType === 3 && (a += f.nodeValue.length),
                      (y = f.firstChild) !== null; )
                          d = f,
                          f = y;
                      for (; ; ) {
                          if (f === e)
                              break t;
                          if (d === n && ++l === i && (o = a),
                          d === s && ++c === r && (u = a),
                          (y = f.nextSibling) !== null)
                              break;
                          f = d,
                          d = f.parentNode
                      }
                      f = y
                  }
                  n = o === -1 || u === -1 ? null : {
                      start: o,
                      end: u
                  }
              } else
                  n = null
          }
      n = n || {
          start: 0,
          end: 0
      }
  } else
      n = null;
  for (Kd = {
      focusedElem: e,
      selectionRange: n
  },
  Zu = !1,
  Y = t; Y !== null; )
      if (t = Y,
      e = t.child,
      (t.subtreeFlags & 1028) !== 0 && e !== null)
          e.return = t,
          Y = e;
      else
          for (; Y !== null; ) {
              t = Y;
              try {
                  var m = t.alternate;
                  if (t.flags & 1024)
                      switch (t.tag) {
                      case 0:
                      case 11:
                      case 15:
                          break;
                      case 1:
                          if (m !== null) {
                              var v = m.memoizedProps
                                , b = m.memoizedState
                                , w = t.stateNode
                                , h = w.getSnapshotBeforeUpdate(t.elementType === t.type ? v : un(t.type, v), b);
                              w.__reactInternalSnapshotBeforeUpdate = h
                          }
                          break;
                      case 3:
                          var g = t.stateNode.containerInfo;
                          g.nodeType === 1 ? g.textContent = "" : g.nodeType === 9 && g.documentElement && g.removeChild(g.documentElement);
                          break;
                      case 5:
                      case 6:
                      case 4:
                      case 17:
                          break;
                      default:
                          throw Error(H(163))
                      }
              } catch (x) {
                  Re(t, t.return, x)
              }
              if (e = t.sibling,
              e !== null) {
                  e.return = t.return,
                  Y = e;
                  break
              }
              Y = t.return
          }
  return m = Kg,
  Kg = !1,
  m
}
function la(e, t, n) {
  var r = t.updateQueue;
  if (r = r !== null ? r.lastEffect : null,
  r !== null) {
      var i = r = r.next;
      do {
          if ((i.tag & e) === e) {
              var s = i.destroy;
              i.destroy = void 0,
              s !== void 0 && lp(t, n, s)
          }
          i = i.next
      } while (i !== r)
  }
}
function oc(e, t) {
  if (t = t.updateQueue,
  t = t !== null ? t.lastEffect : null,
  t !== null) {
      var n = t = t.next;
      do {
          if ((n.tag & e) === e) {
              var r = n.create;
              n.destroy = r()
          }
          n = n.next
      } while (n !== t)
  }
}
function cp(e) {
  var t = e.ref;
  if (t !== null) {
      var n = e.stateNode;
      switch (e.tag) {
      case 5:
          e = n;
          break;
      default:
          e = n
      }
      typeof t == "function" ? t(e) : t.current = e
  }
}
function o2(e) {
  var t = e.alternate;
  t !== null && (e.alternate = null,
  o2(t)),
  e.child = null,
  e.deletions = null,
  e.sibling = null,
  e.tag === 5 && (t = e.stateNode,
  t !== null && (delete t[Sn],
  delete t[_a],
  delete t[Yd],
  delete t[e5],
  delete t[t5])),
  e.stateNode = null,
  e.return = null,
  e.dependencies = null,
  e.memoizedProps = null,
  e.memoizedState = null,
  e.pendingProps = null,
  e.stateNode = null,
  e.updateQueue = null
}
function u2(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4
}
function Gg(e) {
  e: for (; ; ) {
      for (; e.sibling === null; ) {
          if (e.return === null || u2(e.return))
              return null;
          e = e.return
      }
      for (e.sibling.return = e.return,
      e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
          if (e.flags & 2 || e.child === null || e.tag === 4)
              continue e;
          e.child.return = e,
          e = e.child
      }
      if (!(e.flags & 2))
          return e.stateNode
  }
}
function fp(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6)
      e = e.stateNode,
      t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode,
      t.insertBefore(e, n)) : (t = n,
      t.appendChild(e)),
      n = n._reactRootContainer,
      n != null || t.onclick !== null || (t.onclick = nl));
  else if (r !== 4 && (e = e.child,
  e !== null))
      for (fp(e, t, n),
      e = e.sibling; e !== null; )
          fp(e, t, n),
          e = e.sibling
}
function dp(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6)
      e = e.stateNode,
      t ? n.insertBefore(e, t) : n.appendChild(e);
  else if (r !== 4 && (e = e.child,
  e !== null))
      for (dp(e, t, n),
      e = e.sibling; e !== null; )
          dp(e, t, n),
          e = e.sibling
}
var et = null
, ln = !1;
function nr(e, t, n) {
  for (n = n.child; n !== null; )
      l2(e, t, n),
      n = n.sibling
}
function l2(e, t, n) {
  if (Tn && typeof Tn.onCommitFiberUnmount == "function")
      try {
          Tn.onCommitFiberUnmount(Zl, n)
      } catch {}
  switch (n.tag) {
  case 5:
      mt || Hi(n, t);
  case 6:
      var r = et
        , i = ln;
      et = null,
      nr(e, t, n),
      et = r,
      ln = i,
      et !== null && (ln ? (e = et,
      n = n.stateNode,
      e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : et.removeChild(n.stateNode));
      break;
  case 18:
      et !== null && (ln ? (e = et,
      n = n.stateNode,
      e.nodeType === 8 ? Nf(e.parentNode, n) : e.nodeType === 1 && Nf(e, n),
      ba(e)) : Nf(et, n.stateNode));
      break;
  case 4:
      r = et,
      i = ln,
      et = n.stateNode.containerInfo,
      ln = !0,
      nr(e, t, n),
      et = r,
      ln = i;
      break;
  case 0:
  case 11:
  case 14:
  case 15:
      if (!mt && (r = n.updateQueue,
      r !== null && (r = r.lastEffect,
      r !== null))) {
          i = r = r.next;
          do {
              var s = i
                , a = s.destroy;
              s = s.tag,
              a !== void 0 && (s & 2 || s & 4) && lp(n, t, a),
              i = i.next
          } while (i !== r)
      }
      nr(e, t, n);
      break;
  case 1:
      if (!mt && (Hi(n, t),
      r = n.stateNode,
      typeof r.componentWillUnmount == "function"))
          try {
              r.props = n.memoizedProps,
              r.state = n.memoizedState,
              r.componentWillUnmount()
          } catch (o) {
              Re(n, t, o)
          }
      nr(e, t, n);
      break;
  case 21:
      nr(e, t, n);
      break;
  case 22:
      n.mode & 1 ? (mt = (r = mt) || n.memoizedState !== null,
      nr(e, t, n),
      mt = r) : nr(e, t, n);
      break;
  default:
      nr(e, t, n)
  }
}
function Qg(e) {
  var t = e.updateQueue;
  if (t !== null) {
      e.updateQueue = null;
      var n = e.stateNode;
      n === null && (n = e.stateNode = new g5),
      t.forEach(function(r) {
          var i = T5.bind(null, e, r);
          n.has(r) || (n.add(r),
          r.then(i, i))
      })
  }
}
function on(e, t) {
  var n = t.deletions;
  if (n !== null)
      for (var r = 0; r < n.length; r++) {
          var i = n[r];
          try {
              var s = e
                , a = t
                , o = a;
              e: for (; o !== null; ) {
                  switch (o.tag) {
                  case 5:
                      et = o.stateNode,
                      ln = !1;
                      break e;
                  case 3:
                      et = o.stateNode.containerInfo,
                      ln = !0;
                      break e;
                  case 4:
                      et = o.stateNode.containerInfo,
                      ln = !0;
                      break e
                  }
                  o = o.return
              }
              if (et === null)
                  throw Error(H(160));
              l2(s, a, i),
              et = null,
              ln = !1;
              var u = i.alternate;
              u !== null && (u.return = null),
              i.return = null
          } catch (l) {
              Re(i, t, l)
          }
      }
  if (t.subtreeFlags & 12854)
      for (t = t.child; t !== null; )
          c2(t, e),
          t = t.sibling
}
function c2(e, t) {
  var n = e.alternate
    , r = e.flags;
  switch (e.tag) {
  case 0:
  case 11:
  case 14:
  case 15:
      if (on(t, e),
      wn(e),
      r & 4) {
          try {
              la(3, e, e.return),
              oc(3, e)
          } catch (v) {
              Re(e, e.return, v)
          }
          try {
              la(5, e, e.return)
          } catch (v) {
              Re(e, e.return, v)
          }
      }
      break;
  case 1:
      on(t, e),
      wn(e),
      r & 512 && n !== null && Hi(n, n.return);
      break;
  case 5:
      if (on(t, e),
      wn(e),
      r & 512 && n !== null && Hi(n, n.return),
      e.flags & 32) {
          var i = e.stateNode;
          try {
              ya(i, "")
          } catch (v) {
              Re(e, e.return, v)
          }
      }
      if (r & 4 && (i = e.stateNode,
      i != null)) {
          var s = e.memoizedProps
            , a = n !== null ? n.memoizedProps : s
            , o = e.type
            , u = e.updateQueue;
          if (e.updateQueue = null,
          u !== null)
              try {
                  o === "input" && s.type === "radio" && s.name != null && Iw(i, s),
                  jd(o, a);
                  var l = jd(o, s);
                  for (a = 0; a < u.length; a += 2) {
                      var c = u[a]
                        , f = u[a + 1];
                      c === "style" ? jw(i, f) : c === "dangerouslySetInnerHTML" ? Rw(i, f) : c === "children" ? ya(i, f) : jh(i, c, f, l)
                  }
                  switch (o) {
                  case "input":
                      Id(i, s);
                      break;
                  case "textarea":
                      Aw(i, s);
                      break;
                  case "select":
                      var d = i._wrapperState.wasMultiple;
                      i._wrapperState.wasMultiple = !!s.multiple;
                      var y = s.value;
                      y != null ? Yi(i, !!s.multiple, y, !1) : d !== !!s.multiple && (s.defaultValue != null ? Yi(i, !!s.multiple, s.defaultValue, !0) : Yi(i, !!s.multiple, s.multiple ? [] : "", !1))
                  }
                  i[_a] = s
              } catch (v) {
                  Re(e, e.return, v)
              }
      }
      break;
  case 6:
      if (on(t, e),
      wn(e),
      r & 4) {
          if (e.stateNode === null)
              throw Error(H(162));
          i = e.stateNode,
          s = e.memoizedProps;
          try {
              i.nodeValue = s
          } catch (v) {
              Re(e, e.return, v)
          }
      }
      break;
  case 3:
      if (on(t, e),
      wn(e),
      r & 4 && n !== null && n.memoizedState.isDehydrated)
          try {
              ba(t.containerInfo)
          } catch (v) {
              Re(e, e.return, v)
          }
      break;
  case 4:
      on(t, e),
      wn(e);
      break;
  case 13:
      on(t, e),
      wn(e),
      i = e.child,
      i.flags & 8192 && (s = i.memoizedState !== null,
      i.stateNode.isHidden = s,
      !s || i.alternate !== null && i.alternate.memoizedState !== null || (mm = Le())),
      r & 4 && Qg(e);
      break;
  case 22:
      if (c = n !== null && n.memoizedState !== null,
      e.mode & 1 ? (mt = (l = mt) || c,
      on(t, e),
      mt = l) : on(t, e),
      wn(e),
      r & 8192) {
          if (l = e.memoizedState !== null,
          (e.stateNode.isHidden = l) && !c && e.mode & 1)
              for (Y = e,
              c = e.child; c !== null; ) {
                  for (f = Y = c; Y !== null; ) {
                      switch (d = Y,
                      y = d.child,
                      d.tag) {
                      case 0:
                      case 11:
                      case 14:
                      case 15:
                          la(4, d, d.return);
                          break;
                      case 1:
                          Hi(d, d.return);
                          var m = d.stateNode;
                          if (typeof m.componentWillUnmount == "function") {
                              r = d,
                              n = d.return;
                              try {
                                  t = r,
                                  m.props = t.memoizedProps,
                                  m.state = t.memoizedState,
                                  m.componentWillUnmount()
                              } catch (v) {
                                  Re(r, n, v)
                              }
                          }
                          break;
                      case 5:
                          Hi(d, d.return);
                          break;
                      case 22:
                          if (d.memoizedState !== null) {
                              Xg(f);
                              continue
                          }
                      }
                      y !== null ? (y.return = d,
                      Y = y) : Xg(f)
                  }
                  c = c.sibling
              }
          e: for (c = null,
          f = e; ; ) {
              if (f.tag === 5) {
                  if (c === null) {
                      c = f;
                      try {
                          i = f.stateNode,
                          l ? (s = i.style,
                          typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (o = f.stateNode,
                          u = f.memoizedProps.style,
                          a = u != null && u.hasOwnProperty("display") ? u.display : null,
                          o.style.display = Nw("display", a))
                      } catch (v) {
                          Re(e, e.return, v)
                      }
                  }
              } else if (f.tag === 6) {
                  if (c === null)
                      try {
                          f.stateNode.nodeValue = l ? "" : f.memoizedProps
                      } catch (v) {
                          Re(e, e.return, v)
                      }
              } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) {
                  f.child.return = f,
                  f = f.child;
                  continue
              }
              if (f === e)
                  break e;
              for (; f.sibling === null; ) {
                  if (f.return === null || f.return === e)
                      break e;
                  c === f && (c = null),
                  f = f.return
              }
              c === f && (c = null),
              f.sibling.return = f.return,
              f = f.sibling
          }
      }
      break;
  case 19:
      on(t, e),
      wn(e),
      r & 4 && Qg(e);
      break;
  case 21:
      break;
  default:
      on(t, e),
      wn(e)
  }
}
function wn(e) {
  var t = e.flags;
  if (t & 2) {
      try {
          e: {
              for (var n = e.return; n !== null; ) {
                  if (u2(n)) {
                      var r = n;
                      break e
                  }
                  n = n.return
              }
              throw Error(H(160))
          }
          switch (r.tag) {
          case 5:
              var i = r.stateNode;
              r.flags & 32 && (ya(i, ""),
              r.flags &= -33);
              var s = Gg(e);
              dp(e, s, i);
              break;
          case 3:
          case 4:
              var a = r.stateNode.containerInfo
                , o = Gg(e);
              fp(e, o, a);
              break;
          default:
              throw Error(H(161))
          }
      } catch (u) {
          Re(e, e.return, u)
      }
      e.flags &= -3
  }
  t & 4096 && (e.flags &= -4097)
}
function w5(e, t, n) {
  Y = e,
  f2(e)
}
function f2(e, t, n) {
  for (var r = (e.mode & 1) !== 0; Y !== null; ) {
      var i = Y
        , s = i.child;
      if (i.tag === 22 && r) {
          var a = i.memoizedState !== null || Zo;
          if (!a) {
              var o = i.alternate
                , u = o !== null && o.memoizedState !== null || mt;
              o = Zo;
              var l = mt;
              if (Zo = a,
              (mt = u) && !l)
                  for (Y = i; Y !== null; )
                      a = Y,
                      u = a.child,
                      a.tag === 22 && a.memoizedState !== null ? Jg(i) : u !== null ? (u.return = a,
                      Y = u) : Jg(i);
              for (; s !== null; )
                  Y = s,
                  f2(s),
                  s = s.sibling;
              Y = i,
              Zo = o,
              mt = l
          }
          Yg(e)
      } else
          i.subtreeFlags & 8772 && s !== null ? (s.return = i,
          Y = s) : Yg(e)
  }
}
function Yg(e) {
  for (; Y !== null; ) {
      var t = Y;
      if (t.flags & 8772) {
          var n = t.alternate;
          try {
              if (t.flags & 8772)
                  switch (t.tag) {
                  case 0:
                  case 11:
                  case 15:
                      mt || oc(5, t);
                      break;
                  case 1:
                      var r = t.stateNode;
                      if (t.flags & 4 && !mt)
                          if (n === null)
                              r.componentDidMount();
                          else {
                              var i = t.elementType === t.type ? n.memoizedProps : un(t.type, n.memoizedProps);
                              r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                          }
                      var s = t.updateQueue;
                      s !== null && $g(t, s, r);
                      break;
                  case 3:
                      var a = t.updateQueue;
                      if (a !== null) {
                          if (n = null,
                          t.child !== null)
                              switch (t.child.tag) {
                              case 5:
                                  n = t.child.stateNode;
                                  break;
                              case 1:
                                  n = t.child.stateNode
                              }
                          $g(t, a, n)
                      }
                      break;
                  case 5:
                      var o = t.stateNode;
                      if (n === null && t.flags & 4) {
                          n = o;
                          var u = t.memoizedProps;
                          switch (t.type) {
                          case "button":
                          case "input":
                          case "select":
                          case "textarea":
                              u.autoFocus && n.focus();
                              break;
                          case "img":
                              u.src && (n.src = u.src)
                          }
                      }
                      break;
                  case 6:
                      break;
                  case 4:
                      break;
                  case 12:
                      break;
                  case 13:
                      if (t.memoizedState === null) {
                          var l = t.alternate;
                          if (l !== null) {
                              var c = l.memoizedState;
                              if (c !== null) {
                                  var f = c.dehydrated;
                                  f !== null && ba(f)
                              }
                          }
                      }
                      break;
                  case 19:
                  case 17:
                  case 21:
                  case 22:
                  case 23:
                  case 25:
                      break;
                  default:
                      throw Error(H(163))
                  }
              mt || t.flags & 512 && cp(t)
          } catch (d) {
              Re(t, t.return, d)
          }
      }
      if (t === e) {
          Y = null;
          break
      }
      if (n = t.sibling,
      n !== null) {
          n.return = t.return,
          Y = n;
          break
      }
      Y = t.return
  }
}
function Xg(e) {
  for (; Y !== null; ) {
      var t = Y;
      if (t === e) {
          Y = null;
          break
      }
      var n = t.sibling;
      if (n !== null) {
          n.return = t.return,
          Y = n;
          break
      }
      Y = t.return
  }
}
function Jg(e) {
  for (; Y !== null; ) {
      var t = Y;
      try {
          switch (t.tag) {
          case 0:
          case 11:
          case 15:
              var n = t.return;
              try {
                  oc(4, t)
              } catch (u) {
                  Re(t, n, u)
              }
              break;
          case 1:
              var r = t.stateNode;
              if (typeof r.componentDidMount == "function") {
                  var i = t.return;
                  try {
                      r.componentDidMount()
                  } catch (u) {
                      Re(t, i, u)
                  }
              }
              var s = t.return;
              try {
                  cp(t)
              } catch (u) {
                  Re(t, s, u)
              }
              break;
          case 5:
              var a = t.return;
              try {
                  cp(t)
              } catch (u) {
                  Re(t, a, u)
              }
          }
      } catch (u) {
          Re(t, t.return, u)
      }
      if (t === e) {
          Y = null;
          break
      }
      var o = t.sibling;
      if (o !== null) {
          o.return = t.return,
          Y = o;
          break
      }
      Y = t.return
  }
}
var b5 = Math.ceil
, pl = Jn.ReactCurrentDispatcher
, pm = Jn.ReactCurrentOwner
, Zt = Jn.ReactCurrentBatchConfig
, fe = 0
, Je = null
, ze = null
, tt = 0
, Rt = 0
, qi = Fr(0)
, Ve = 0
, Ia = null
, pi = 0
, uc = 0
, hm = 0
, ca = null
, Pt = null
, mm = 0
, cs = 1 / 0
, Rn = null
, hl = !1
, pp = null
, Sr = null
, eu = !1
, mr = null
, ml = 0
, fa = 0
, hp = null
, Au = -1
, $u = 0;
function xt() {
  return fe & 6 ? Le() : Au !== -1 ? Au : Au = Le()
}
function Cr(e) {
  return e.mode & 1 ? fe & 2 && tt !== 0 ? tt & -tt : r5.transition !== null ? ($u === 0 && ($u = Gw()),
  $u) : (e = de,
  e !== 0 || (e = window.event,
  e = e === void 0 ? 16 : tb(e.type)),
  e) : 1
}
function pn(e, t, n, r) {
  if (50 < fa)
      throw fa = 0,
      hp = null,
      Error(H(185));
  uo(e, n, r),
  (!(fe & 2) || e !== Je) && (e === Je && (!(fe & 2) && (uc |= n),
  Ve === 4 && fr(e, tt)),
  Dt(e, r),
  n === 1 && fe === 0 && !(t.mode & 1) && (cs = Le() + 500,
  ic && Ur()))
}
function Dt(e, t) {
  var n = e.callbackNode;
  rC(e, t);
  var r = Ju(e, e === Je ? tt : 0);
  if (r === 0)
      n !== null && og(n),
      e.callbackNode = null,
      e.callbackPriority = 0;
  else if (t = r & -r,
  e.callbackPriority !== t) {
      if (n != null && og(n),
      t === 1)
          e.tag === 0 ? n5(Zg.bind(null, e)) : bb(Zg.bind(null, e)),
          JC(function() {
              !(fe & 6) && Ur()
          }),
          n = null;
      else {
          switch (Qw(r)) {
          case 1:
              n = zh;
              break;
          case 4:
              n = Vw;
              break;
          case 16:
              n = Xu;
              break;
          case 536870912:
              n = Kw;
              break;
          default:
              n = Xu
          }
          n = w2(n, d2.bind(null, e))
      }
      e.callbackPriority = t,
      e.callbackNode = n
  }
}
function d2(e, t) {
  if (Au = -1,
  $u = 0,
  fe & 6)
      throw Error(H(327));
  var n = e.callbackNode;
  if (ts() && e.callbackNode !== n)
      return null;
  var r = Ju(e, e === Je ? tt : 0);
  if (r === 0)
      return null;
  if (r & 30 || r & e.expiredLanes || t)
      t = yl(e, r);
  else {
      t = r;
      var i = fe;
      fe |= 2;
      var s = h2();
      (Je !== e || tt !== t) && (Rn = null,
      cs = Le() + 500,
      si(e, t));
      do
          try {
              S5();
              break
          } catch (o) {
              p2(e, o)
          }
      while (!0);
      em(),
      pl.current = s,
      fe = i,
      ze !== null ? t = 0 : (Je = null,
      tt = 0,
      t = Ve)
  }
  if (t !== 0) {
      if (t === 2 && (i = zd(e),
      i !== 0 && (r = i,
      t = mp(e, i))),
      t === 1)
          throw n = Ia,
          si(e, 0),
          fr(e, r),
          Dt(e, Le()),
          n;
      if (t === 6)
          fr(e, r);
      else {
          if (i = e.current.alternate,
          !(r & 30) && !x5(i) && (t = yl(e, r),
          t === 2 && (s = zd(e),
          s !== 0 && (r = s,
          t = mp(e, s))),
          t === 1))
              throw n = Ia,
              si(e, 0),
              fr(e, r),
              Dt(e, Le()),
              n;
          switch (e.finishedWork = i,
          e.finishedLanes = r,
          t) {
          case 0:
          case 1:
              throw Error(H(345));
          case 2:
              Jr(e, Pt, Rn);
              break;
          case 3:
              if (fr(e, r),
              (r & 130023424) === r && (t = mm + 500 - Le(),
              10 < t)) {
                  if (Ju(e, 0) !== 0)
                      break;
                  if (i = e.suspendedLanes,
                  (i & r) !== r) {
                      xt(),
                      e.pingedLanes |= e.suspendedLanes & i;
                      break
                  }
                  e.timeoutHandle = Qd(Jr.bind(null, e, Pt, Rn), t);
                  break
              }
              Jr(e, Pt, Rn);
              break;
          case 4:
              if (fr(e, r),
              (r & 4194240) === r)
                  break;
              for (t = e.eventTimes,
              i = -1; 0 < r; ) {
                  var a = 31 - dn(r);
                  s = 1 << a,
                  a = t[a],
                  a > i && (i = a),
                  r &= ~s
              }
              if (r = i,
              r = Le() - r,
              r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * b5(r / 1960)) - r,
              10 < r) {
                  e.timeoutHandle = Qd(Jr.bind(null, e, Pt, Rn), r);
                  break
              }
              Jr(e, Pt, Rn);
              break;
          case 5:
              Jr(e, Pt, Rn);
              break;
          default:
              throw Error(H(329))
          }
      }
  }
  return Dt(e, Le()),
  e.callbackNode === n ? d2.bind(null, e) : null
}
function mp(e, t) {
  var n = ca;
  return e.current.memoizedState.isDehydrated && (si(e, t).flags |= 256),
  e = yl(e, t),
  e !== 2 && (t = Pt,
  Pt = n,
  t !== null && yp(t)),
  e
}
function yp(e) {
  Pt === null ? Pt = e : Pt.push.apply(Pt, e)
}
function x5(e) {
  for (var t = e; ; ) {
      if (t.flags & 16384) {
          var n = t.updateQueue;
          if (n !== null && (n = n.stores,
          n !== null))
              for (var r = 0; r < n.length; r++) {
                  var i = n[r]
                    , s = i.getSnapshot;
                  i = i.value;
                  try {
                      if (!hn(s(), i))
                          return !1
                  } catch {
                      return !1
                  }
              }
      }
      if (n = t.child,
      t.subtreeFlags & 16384 && n !== null)
          n.return = t,
          t = n;
      else {
          if (t === e)
              break;
          for (; t.sibling === null; ) {
              if (t.return === null || t.return === e)
                  return !0;
              t = t.return
          }
          t.sibling.return = t.return,
          t = t.sibling
      }
  }
  return !0
}
function fr(e, t) {
  for (t &= ~hm,
  t &= ~uc,
  e.suspendedLanes |= t,
  e.pingedLanes &= ~t,
  e = e.expirationTimes; 0 < t; ) {
      var n = 31 - dn(t)
        , r = 1 << n;
      e[n] = -1,
      t &= ~r
  }
}
function Zg(e) {
  if (fe & 6)
      throw Error(H(327));
  ts();
  var t = Ju(e, 0);
  if (!(t & 1))
      return Dt(e, Le()),
      null;
  var n = yl(e, t);
  if (e.tag !== 0 && n === 2) {
      var r = zd(e);
      r !== 0 && (t = r,
      n = mp(e, r))
  }
  if (n === 1)
      throw n = Ia,
      si(e, 0),
      fr(e, t),
      Dt(e, Le()),
      n;
  if (n === 6)
      throw Error(H(345));
  return e.finishedWork = e.current.alternate,
  e.finishedLanes = t,
  Jr(e, Pt, Rn),
  Dt(e, Le()),
  null
}
function ym(e, t) {
  var n = fe;
  fe |= 1;
  try {
      return e(t)
  } finally {
      fe = n,
      fe === 0 && (cs = Le() + 500,
      ic && Ur())
  }
}
function hi(e) {
  mr !== null && mr.tag === 0 && !(fe & 6) && ts();
  var t = fe;
  fe |= 1;
  var n = Zt.transition
    , r = de;
  try {
      if (Zt.transition = null,
      de = 1,
      e)
          return e()
  } finally {
      de = r,
      Zt.transition = n,
      fe = t,
      !(fe & 6) && Ur()
  }
}
function gm() {
  Rt = qi.current,
  be(qi)
}
function si(e, t) {
  e.finishedWork = null,
  e.finishedLanes = 0;
  var n = e.timeoutHandle;
  if (n !== -1 && (e.timeoutHandle = -1,
  XC(n)),
  ze !== null)
      for (n = ze.return; n !== null; ) {
          var r = n;
          switch (Xh(r),
          r.tag) {
          case 1:
              r = r.type.childContextTypes,
              r != null && rl();
              break;
          case 3:
              us(),
              be(Ot),
              be(gt),
              am();
              break;
          case 5:
              sm(r);
              break;
          case 4:
              us();
              break;
          case 13:
              be(_e);
              break;
          case 19:
              be(_e);
              break;
          case 10:
              tm(r.type._context);
              break;
          case 22:
          case 23:
              gm()
          }
          n = n.return
      }
  if (Je = e,
  ze = e = _r(e.current, null),
  tt = Rt = t,
  Ve = 0,
  Ia = null,
  hm = uc = pi = 0,
  Pt = ca = null,
  ti !== null) {
      for (t = 0; t < ti.length; t++)
          if (n = ti[t],
          r = n.interleaved,
          r !== null) {
              n.interleaved = null;
              var i = r.next
                , s = n.pending;
              if (s !== null) {
                  var a = s.next;
                  s.next = i,
                  r.next = a
              }
              n.pending = r
          }
      ti = null
  }
  return e
}
function p2(e, t) {
  do {
      var n = ze;
      try {
          if (em(),
          ku.current = dl,
          fl) {
              for (var r = Oe.memoizedState; r !== null; ) {
                  var i = r.queue;
                  i !== null && (i.pending = null),
                  r = r.next
              }
              fl = !1
          }
          if (di = 0,
          Xe = qe = Oe = null,
          ua = !1,
          Oa = 0,
          pm.current = null,
          n === null || n.return === null) {
              Ve = 1,
              Ia = t,
              ze = null;
              break
          }
          e: {
              var s = e
                , a = n.return
                , o = n
                , u = t;
              if (t = tt,
              o.flags |= 32768,
              u !== null && typeof u == "object" && typeof u.then == "function") {
                  var l = u
                    , c = o
                    , f = c.tag;
                  if (!(c.mode & 1) && (f === 0 || f === 11 || f === 15)) {
                      var d = c.alternate;
                      d ? (c.updateQueue = d.updateQueue,
                      c.memoizedState = d.memoizedState,
                      c.lanes = d.lanes) : (c.updateQueue = null,
                      c.memoizedState = null)
                  }
                  var y = Ug(a);
                  if (y !== null) {
                      y.flags &= -257,
                      zg(y, a, o, s, t),
                      y.mode & 1 && Fg(s, l, t),
                      t = y,
                      u = l;
                      var m = t.updateQueue;
                      if (m === null) {
                          var v = new Set;
                          v.add(u),
                          t.updateQueue = v
                      } else
                          m.add(u);
                      break e
                  } else {
                      if (!(t & 1)) {
                          Fg(s, l, t),
                          vm();
                          break e
                      }
                      u = Error(H(426))
                  }
              } else if (Ee && o.mode & 1) {
                  var b = Ug(a);
                  if (b !== null) {
                      !(b.flags & 65536) && (b.flags |= 256),
                      zg(b, a, o, s, t),
                      Jh(ls(u, o));
                      break e
                  }
              }
              s = u = ls(u, o),
              Ve !== 4 && (Ve = 2),
              ca === null ? ca = [s] : ca.push(s),
              s = a;
              do {
                  switch (s.tag) {
                  case 3:
                      s.flags |= 65536,
                      t &= -t,
                      s.lanes |= t;
                      var w = Yb(s, u, t);
                      Ag(s, w);
                      break e;
                  case 1:
                      o = u;
                      var h = s.type
                        , g = s.stateNode;
                      if (!(s.flags & 128) && (typeof h.getDerivedStateFromError == "function" || g !== null && typeof g.componentDidCatch == "function" && (Sr === null || !Sr.has(g)))) {
                          s.flags |= 65536,
                          t &= -t,
                          s.lanes |= t;
                          var x = Xb(s, o, t);
                          Ag(s, x);
                          break e
                      }
                  }
                  s = s.return
              } while (s !== null)
          }
          y2(n)
      } catch (S) {
          t = S,
          ze === n && n !== null && (ze = n = n.return);
          continue
      }
      break
  } while (!0)
}
function h2() {
  var e = pl.current;
  return pl.current = dl,
  e === null ? dl : e
}
function vm() {
  (Ve === 0 || Ve === 3 || Ve === 2) && (Ve = 4),
  Je === null || !(pi & 268435455) && !(uc & 268435455) || fr(Je, tt)
}
function yl(e, t) {
  var n = fe;
  fe |= 2;
  var r = h2();
  (Je !== e || tt !== t) && (Rn = null,
  si(e, t));
  do
      try {
          E5();
          break
      } catch (i) {
          p2(e, i)
      }
  while (!0);
  if (em(),
  fe = n,
  pl.current = r,
  ze !== null)
      throw Error(H(261));
  return Je = null,
  tt = 0,
  Ve
}
function E5() {
  for (; ze !== null; )
      m2(ze)
}
function S5() {
  for (; ze !== null && !G6(); )
      m2(ze)
}
function m2(e) {
  var t = v2(e.alternate, e, Rt);
  e.memoizedProps = e.pendingProps,
  t === null ? y2(e) : ze = t,
  pm.current = null
}
function y2(e) {
  var t = e;
  do {
      var n = t.alternate;
      if (e = t.return,
      t.flags & 32768) {
          if (n = y5(n, t),
          n !== null) {
              n.flags &= 32767,
              ze = n;
              return
          }
          if (e !== null)
              e.flags |= 32768,
              e.subtreeFlags = 0,
              e.deletions = null;
          else {
              Ve = 6,
              ze = null;
              return
          }
      } else if (n = m5(n, t, Rt),
      n !== null) {
          ze = n;
          return
      }
      if (t = t.sibling,
      t !== null) {
          ze = t;
          return
      }
      ze = t = e
  } while (t !== null);
  Ve === 0 && (Ve = 5)
}
function Jr(e, t, n) {
  var r = de
    , i = Zt.transition;
  try {
      Zt.transition = null,
      de = 1,
      C5(e, t, n, r)
  } finally {
      Zt.transition = i,
      de = r
  }
  return null
}
function C5(e, t, n, r) {
  do
      ts();
  while (mr !== null);
  if (fe & 6)
      throw Error(H(327));
  n = e.finishedWork;
  var i = e.finishedLanes;
  if (n === null)
      return null;
  if (e.finishedWork = null,
  e.finishedLanes = 0,
  n === e.current)
      throw Error(H(177));
  e.callbackNode = null,
  e.callbackPriority = 0;
  var s = n.lanes | n.childLanes;
  if (iC(e, s),
  e === Je && (ze = Je = null,
  tt = 0),
  !(n.subtreeFlags & 2064) && !(n.flags & 2064) || eu || (eu = !0,
  w2(Xu, function() {
      return ts(),
      null
  })),
  s = (n.flags & 15990) !== 0,
  n.subtreeFlags & 15990 || s) {
      s = Zt.transition,
      Zt.transition = null;
      var a = de;
      de = 1;
      var o = fe;
      fe |= 4,
      pm.current = null,
      v5(e, n),
      c2(n, e),
      HC(Kd),
      Zu = !!Vd,
      Kd = Vd = null,
      e.current = n,
      w5(n),
      Q6(),
      fe = o,
      de = a,
      Zt.transition = s
  } else
      e.current = n;
  if (eu && (eu = !1,
  mr = e,
  ml = i),
  s = e.pendingLanes,
  s === 0 && (Sr = null),
  J6(n.stateNode),
  Dt(e, Le()),
  t !== null)
      for (r = e.onRecoverableError,
      n = 0; n < t.length; n++)
          i = t[n],
          r(i.value, {
              componentStack: i.stack,
              digest: i.digest
          });
  if (hl)
      throw hl = !1,
      e = pp,
      pp = null,
      e;
  return ml & 1 && e.tag !== 0 && ts(),
  s = e.pendingLanes,
  s & 1 ? e === hp ? fa++ : (fa = 0,
  hp = e) : fa = 0,
  Ur(),
  null
}
function ts() {
  if (mr !== null) {
      var e = Qw(ml)
        , t = Zt.transition
        , n = de;
      try {
          if (Zt.transition = null,
          de = 16 > e ? 16 : e,
          mr === null)
              var r = !1;
          else {
              if (e = mr,
              mr = null,
              ml = 0,
              fe & 6)
                  throw Error(H(331));
              var i = fe;
              for (fe |= 4,
              Y = e.current; Y !== null; ) {
                  var s = Y
                    , a = s.child;
                  if (Y.flags & 16) {
                      var o = s.deletions;
                      if (o !== null) {
                          for (var u = 0; u < o.length; u++) {
                              var l = o[u];
                              for (Y = l; Y !== null; ) {
                                  var c = Y;
                                  switch (c.tag) {
                                  case 0:
                                  case 11:
                                  case 15:
                                      la(8, c, s)
                                  }
                                  var f = c.child;
                                  if (f !== null)
                                      f.return = c,
                                      Y = f;
                                  else
                                      for (; Y !== null; ) {
                                          c = Y;
                                          var d = c.sibling
                                            , y = c.return;
                                          if (o2(c),
                                          c === l) {
                                              Y = null;
                                              break
                                          }
                                          if (d !== null) {
                                              d.return = y,
                                              Y = d;
                                              break
                                          }
                                          Y = y
                                      }
                              }
                          }
                          var m = s.alternate;
                          if (m !== null) {
                              var v = m.child;
                              if (v !== null) {
                                  m.child = null;
                                  do {
                                      var b = v.sibling;
                                      v.sibling = null,
                                      v = b
                                  } while (v !== null)
                              }
                          }
                          Y = s
                      }
                  }
                  if (s.subtreeFlags & 2064 && a !== null)
                      a.return = s,
                      Y = a;
                  else
                      e: for (; Y !== null; ) {
                          if (s = Y,
                          s.flags & 2048)
                              switch (s.tag) {
                              case 0:
                              case 11:
                              case 15:
                                  la(9, s, s.return)
                              }
                          var w = s.sibling;
                          if (w !== null) {
                              w.return = s.return,
                              Y = w;
                              break e
                          }
                          Y = s.return
                      }
              }
              var h = e.current;
              for (Y = h; Y !== null; ) {
                  a = Y;
                  var g = a.child;
                  if (a.subtreeFlags & 2064 && g !== null)
                      g.return = a,
                      Y = g;
                  else
                      e: for (a = h; Y !== null; ) {
                          if (o = Y,
                          o.flags & 2048)
                              try {
                                  switch (o.tag) {
                                  case 0:
                                  case 11:
                                  case 15:
                                      oc(9, o)
                                  }
                              } catch (S) {
                                  Re(o, o.return, S)
                              }
                          if (o === a) {
                              Y = null;
                              break e
                          }
                          var x = o.sibling;
                          if (x !== null) {
                              x.return = o.return,
                              Y = x;
                              break e
                          }
                          Y = o.return
                      }
              }
              if (fe = i,
              Ur(),
              Tn && typeof Tn.onPostCommitFiberRoot == "function")
                  try {
                      Tn.onPostCommitFiberRoot(Zl, e)
                  } catch {}
              r = !0
          }
          return r
      } finally {
          de = n,
          Zt.transition = t
      }
  }
  return !1
}
function e0(e, t, n) {
  t = ls(n, t),
  t = Yb(e, t, 1),
  e = Er(e, t, 1),
  t = xt(),
  e !== null && (uo(e, 1, t),
  Dt(e, t))
}
function Re(e, t, n) {
  if (e.tag === 3)
      e0(e, e, n);
  else
      for (; t !== null; ) {
          if (t.tag === 3) {
              e0(t, e, n);
              break
          } else if (t.tag === 1) {
              var r = t.stateNode;
              if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Sr === null || !Sr.has(r))) {
                  e = ls(n, e),
                  e = Xb(t, e, 1),
                  t = Er(t, e, 1),
                  e = xt(),
                  t !== null && (uo(t, 1, e),
                  Dt(t, e));
                  break
              }
          }
          t = t.return
      }
}
function _5(e, t, n) {
  var r = e.pingCache;
  r !== null && r.delete(t),
  t = xt(),
  e.pingedLanes |= e.suspendedLanes & n,
  Je === e && (tt & n) === n && (Ve === 4 || Ve === 3 && (tt & 130023424) === tt && 500 > Le() - mm ? si(e, 0) : hm |= n),
  Dt(e, t)
}
function g2(e, t) {
  t === 0 && (e.mode & 1 ? (t = Ho,
  Ho <<= 1,
  !(Ho & 130023424) && (Ho = 4194304)) : t = 1);
  var n = xt();
  e = Vn(e, t),
  e !== null && (uo(e, t, n),
  Dt(e, n))
}
function P5(e) {
  var t = e.memoizedState
    , n = 0;
  t !== null && (n = t.retryLane),
  g2(e, n)
}
function T5(e, t) {
  var n = 0;
  switch (e.tag) {
  case 13:
      var r = e.stateNode
        , i = e.memoizedState;
      i !== null && (n = i.retryLane);
      break;
  case 19:
      r = e.stateNode;
      break;
  default:
      throw Error(H(314))
  }
  r !== null && r.delete(t),
  g2(e, n)
}
var v2;
v2 = function(e, t, n) {
  if (e !== null)
      if (e.memoizedProps !== t.pendingProps || Ot.current)
          Tt = !0;
      else {
          if (!(e.lanes & n) && !(t.flags & 128))
              return Tt = !1,
              h5(e, t, n);
          Tt = !!(e.flags & 131072)
      }
  else
      Tt = !1,
      Ee && t.flags & 1048576 && xb(t, al, t.index);
  switch (t.lanes = 0,
  t.tag) {
  case 2:
      var r = t.type;
      Iu(e, t),
      e = t.pendingProps;
      var i = ss(t, gt.current);
      es(t, n),
      i = um(null, t, r, e, i, n);
      var s = lm();
      return t.flags |= 1,
      typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1,
      t.memoizedState = null,
      t.updateQueue = null,
      kt(r) ? (s = !0,
      il(t)) : s = !1,
      t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null,
      rm(t),
      i.updater = sc,
      t.stateNode = i,
      i._reactInternals = t,
      np(t, r, e, n),
      t = sp(null, t, r, !0, s, n)) : (t.tag = 0,
      Ee && s && Yh(t),
      wt(null, t, i, n),
      t = t.child),
      t;
  case 16:
      r = t.elementType;
      e: {
          switch (Iu(e, t),
          e = t.pendingProps,
          i = r._init,
          r = i(r._payload),
          t.type = r,
          i = t.tag = k5(r),
          e = un(r, e),
          i) {
          case 0:
              t = ip(null, t, r, e, n);
              break e;
          case 1:
              t = Hg(null, t, r, e, n);
              break e;
          case 11:
              t = Bg(null, t, r, e, n);
              break e;
          case 14:
              t = Wg(null, t, r, un(r.type, e), n);
              break e
          }
          throw Error(H(306, r, ""))
      }
      return t;
  case 0:
      return r = t.type,
      i = t.pendingProps,
      i = t.elementType === r ? i : un(r, i),
      ip(e, t, r, i, n);
  case 1:
      return r = t.type,
      i = t.pendingProps,
      i = t.elementType === r ? i : un(r, i),
      Hg(e, t, r, i, n);
  case 3:
      e: {
          if (t2(t),
          e === null)
              throw Error(H(387));
          r = t.pendingProps,
          s = t.memoizedState,
          i = s.element,
          _b(e, t),
          ll(t, r, null, n);
          var a = t.memoizedState;
          if (r = a.element,
          s.isDehydrated)
              if (s = {
                  element: r,
                  isDehydrated: !1,
                  cache: a.cache,
                  pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
                  transitions: a.transitions
              },
              t.updateQueue.baseState = s,
              t.memoizedState = s,
              t.flags & 256) {
                  i = ls(Error(H(423)), t),
                  t = qg(e, t, r, n, i);
                  break e
              } else if (r !== i) {
                  i = ls(Error(H(424)), t),
                  t = qg(e, t, r, n, i);
                  break e
              } else
                  for (Nt = xr(t.stateNode.containerInfo.firstChild),
                  Lt = t,
                  Ee = !0,
                  cn = null,
                  n = kb(t, null, r, n),
                  t.child = n; n; )
                      n.flags = n.flags & -3 | 4096,
                      n = n.sibling;
          else {
              if (as(),
              r === i) {
                  t = Kn(e, t, n);
                  break e
              }
              wt(e, t, r, n)
          }
          t = t.child
      }
      return t;
  case 5:
      return Db(t),
      e === null && Zd(t),
      r = t.type,
      i = t.pendingProps,
      s = e !== null ? e.memoizedProps : null,
      a = i.children,
      Gd(r, i) ? a = null : s !== null && Gd(r, s) && (t.flags |= 32),
      e2(e, t),
      wt(e, t, a, n),
      t.child;
  case 6:
      return e === null && Zd(t),
      null;
  case 13:
      return n2(e, t, n);
  case 4:
      return im(t, t.stateNode.containerInfo),
      r = t.pendingProps,
      e === null ? t.child = os(t, null, r, n) : wt(e, t, r, n),
      t.child;
  case 11:
      return r = t.type,
      i = t.pendingProps,
      i = t.elementType === r ? i : un(r, i),
      Bg(e, t, r, i, n);
  case 7:
      return wt(e, t, t.pendingProps, n),
      t.child;
  case 8:
      return wt(e, t, t.pendingProps.children, n),
      t.child;
  case 12:
      return wt(e, t, t.pendingProps.children, n),
      t.child;
  case 10:
      e: {
          if (r = t.type._context,
          i = t.pendingProps,
          s = t.memoizedProps,
          a = i.value,
          ge(ol, r._currentValue),
          r._currentValue = a,
          s !== null)
              if (hn(s.value, a)) {
                  if (s.children === i.children && !Ot.current) {
                      t = Kn(e, t, n);
                      break e
                  }
              } else
                  for (s = t.child,
                  s !== null && (s.return = t); s !== null; ) {
                      var o = s.dependencies;
                      if (o !== null) {
                          a = s.child;
                          for (var u = o.firstContext; u !== null; ) {
                              if (u.context === r) {
                                  if (s.tag === 1) {
                                      u = zn(-1, n & -n),
                                      u.tag = 2;
                                      var l = s.updateQueue;
                                      if (l !== null) {
                                          l = l.shared;
                                          var c = l.pending;
                                          c === null ? u.next = u : (u.next = c.next,
                                          c.next = u),
                                          l.pending = u
                                      }
                                  }
                                  s.lanes |= n,
                                  u = s.alternate,
                                  u !== null && (u.lanes |= n),
                                  ep(s.return, n, t),
                                  o.lanes |= n;
                                  break
                              }
                              u = u.next
                          }
                      } else if (s.tag === 10)
                          a = s.type === t.type ? null : s.child;
                      else if (s.tag === 18) {
                          if (a = s.return,
                          a === null)
                              throw Error(H(341));
                          a.lanes |= n,
                          o = a.alternate,
                          o !== null && (o.lanes |= n),
                          ep(a, n, t),
                          a = s.sibling
                      } else
                          a = s.child;
                      if (a !== null)
                          a.return = s;
                      else
                          for (a = s; a !== null; ) {
                              if (a === t) {
                                  a = null;
                                  break
                              }
                              if (s = a.sibling,
                              s !== null) {
                                  s.return = a.return,
                                  a = s;
                                  break
                              }
                              a = a.return
                          }
                      s = a
                  }
          wt(e, t, i.children, n),
          t = t.child
      }
      return t;
  case 9:
      return i = t.type,
      r = t.pendingProps.children,
      es(t, n),
      i = en(i),
      r = r(i),
      t.flags |= 1,
      wt(e, t, r, n),
      t.child;
  case 14:
      return r = t.type,
      i = un(r, t.pendingProps),
      i = un(r.type, i),
      Wg(e, t, r, i, n);
  case 15:
      return Jb(e, t, t.type, t.pendingProps, n);
  case 17:
      return r = t.type,
      i = t.pendingProps,
      i = t.elementType === r ? i : un(r, i),
      Iu(e, t),
      t.tag = 1,
      kt(r) ? (e = !0,
      il(t)) : e = !1,
      es(t, n),
      Tb(t, r, i),
      np(t, r, i, n),
      sp(null, t, r, !0, e, n);
  case 19:
      return r2(e, t, n);
  case 22:
      return Zb(e, t, n)
  }
  throw Error(H(156, t.tag))
}
;
function w2(e, t) {
  return qw(e, t)
}
function O5(e, t, n, r) {
  this.tag = e,
  this.key = n,
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
  this.index = 0,
  this.ref = null,
  this.pendingProps = t,
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
  this.mode = r,
  this.subtreeFlags = this.flags = 0,
  this.deletions = null,
  this.childLanes = this.lanes = 0,
  this.alternate = null
}
function Xt(e, t, n, r) {
  return new O5(e,t,n,r)
}
function wm(e) {
  return e = e.prototype,
  !(!e || !e.isReactComponent)
}
function k5(e) {
  if (typeof e == "function")
      return wm(e) ? 1 : 0;
  if (e != null) {
      if (e = e.$$typeof,
      e === Lh)
          return 11;
      if (e === Fh)
          return 14
  }
  return 2
}
function _r(e, t) {
  var n = e.alternate;
  return n === null ? (n = Xt(e.tag, t, e.key, e.mode),
  n.elementType = e.elementType,
  n.type = e.type,
  n.stateNode = e.stateNode,
  n.alternate = e,
  e.alternate = n) : (n.pendingProps = t,
  n.type = e.type,
  n.flags = 0,
  n.subtreeFlags = 0,
  n.deletions = null),
  n.flags = e.flags & 14680064,
  n.childLanes = e.childLanes,
  n.lanes = e.lanes,
  n.child = e.child,
  n.memoizedProps = e.memoizedProps,
  n.memoizedState = e.memoizedState,
  n.updateQueue = e.updateQueue,
  t = e.dependencies,
  n.dependencies = t === null ? null : {
      lanes: t.lanes,
      firstContext: t.firstContext
  },
  n.sibling = e.sibling,
  n.index = e.index,
  n.ref = e.ref,
  n
}
function Ru(e, t, n, r, i, s) {
  var a = 2;
  if (r = e,
  typeof e == "function")
      wm(e) && (a = 1);
  else if (typeof e == "string")
      a = 5;
  else
      e: switch (e) {
      case Ni:
          return ai(n.children, i, s, t);
      case Mh:
          a = 8,
          i |= 8;
          break;
      case Pd:
          return e = Xt(12, n, t, i | 2),
          e.elementType = Pd,
          e.lanes = s,
          e;
      case Td:
          return e = Xt(13, n, t, i),
          e.elementType = Td,
          e.lanes = s,
          e;
      case Od:
          return e = Xt(19, n, t, i),
          e.elementType = Od,
          e.lanes = s,
          e;
      case Ow:
          return lc(n, i, s, t);
      default:
          if (typeof e == "object" && e !== null)
              switch (e.$$typeof) {
              case Pw:
                  a = 10;
                  break e;
              case Tw:
                  a = 9;
                  break e;
              case Lh:
                  a = 11;
                  break e;
              case Fh:
                  a = 14;
                  break e;
              case ar:
                  a = 16,
                  r = null;
                  break e
              }
          throw Error(H(130, e == null ? e : typeof e, ""))
      }
  return t = Xt(a, n, t, i),
  t.elementType = e,
  t.type = r,
  t.lanes = s,
  t
}
function ai(e, t, n, r) {
  return e = Xt(7, e, r, t),
  e.lanes = n,
  e
}
function lc(e, t, n, r) {
  return e = Xt(22, e, r, t),
  e.elementType = Ow,
  e.lanes = n,
  e.stateNode = {
      isHidden: !1
  },
  e
}
function Wf(e, t, n) {
  return e = Xt(6, e, null, t),
  e.lanes = n,
  e
}
function Hf(e, t, n) {
  return t = Xt(4, e.children !== null ? e.children : [], e.key, t),
  t.lanes = n,
  t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation
  },
  t
}
function D5(e, t, n, r, i) {
  this.tag = t,
  this.containerInfo = e,
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
  this.timeoutHandle = -1,
  this.callbackNode = this.pendingContext = this.context = null,
  this.callbackPriority = 0,
  this.eventTimes = Cf(0),
  this.expirationTimes = Cf(-1),
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
  this.entanglements = Cf(0),
  this.identifierPrefix = r,
  this.onRecoverableError = i,
  this.mutableSourceEagerHydrationData = null
}
function bm(e, t, n, r, i, s, a, o, u) {
  return e = new D5(e,t,n,o,u),
  t === 1 ? (t = 1,
  s === !0 && (t |= 8)) : t = 0,
  s = Xt(3, null, null, t),
  e.current = s,
  s.stateNode = e,
  s.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null
  },
  rm(s),
  e
}
function I5(e, t, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
      $$typeof: Ri,
      key: r == null ? null : "" + r,
      children: e,
      containerInfo: t,
      implementation: n
  }
}
function b2(e) {
  if (!e)
      return Ar;
  e = e._reactInternals;
  e: {
      if (wi(e) !== e || e.tag !== 1)
          throw Error(H(170));
      var t = e;
      do {
          switch (t.tag) {
          case 3:
              t = t.stateNode.context;
              break e;
          case 1:
              if (kt(t.type)) {
                  t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                  break e
              }
          }
          t = t.return
      } while (t !== null);
      throw Error(H(171))
  }
  if (e.tag === 1) {
      var n = e.type;
      if (kt(n))
          return wb(e, n, t)
  }
  return t
}
function x2(e, t, n, r, i, s, a, o, u) {
  return e = bm(n, r, !0, e, i, s, a, o, u),
  e.context = b2(null),
  n = e.current,
  r = xt(),
  i = Cr(n),
  s = zn(r, i),
  s.callback = t ?? null,
  Er(n, s, i),
  e.current.lanes = i,
  uo(e, i, r),
  Dt(e, r),
  e
}
function cc(e, t, n, r) {
  var i = t.current
    , s = xt()
    , a = Cr(i);
  return n = b2(n),
  t.context === null ? t.context = n : t.pendingContext = n,
  t = zn(s, a),
  t.payload = {
      element: e
  },
  r = r === void 0 ? null : r,
  r !== null && (t.callback = r),
  e = Er(i, t, a),
  e !== null && (pn(e, i, a, s),
  Ou(e, i, a)),
  a
}
function gl(e) {
  if (e = e.current,
  !e.child)
      return null;
  switch (e.child.tag) {
  case 5:
      return e.child.stateNode;
  default:
      return e.child.stateNode
  }
}
function t0(e, t) {
  if (e = e.memoizedState,
  e !== null && e.dehydrated !== null) {
      var n = e.retryLane;
      e.retryLane = n !== 0 && n < t ? n : t
  }
}
function xm(e, t) {
  t0(e, t),
  (e = e.alternate) && t0(e, t)
}
function A5() {
  return null
}
var E2 = typeof reportError == "function" ? reportError : function(e) {
  console.error(e)
}
;
function Em(e) {
  this._internalRoot = e
}
fc.prototype.render = Em.prototype.render = function(e) {
  var t = this._internalRoot;
  if (t === null)
      throw Error(H(409));
  cc(e, t, null, null)
}
;
fc.prototype.unmount = Em.prototype.unmount = function() {
  var e = this._internalRoot;
  if (e !== null) {
      this._internalRoot = null;
      var t = e.containerInfo;
      hi(function() {
          cc(null, e, null, null)
      }),
      t[qn] = null
  }
}
;
function fc(e) {
  this._internalRoot = e
}
fc.prototype.unstable_scheduleHydration = function(e) {
  if (e) {
      var t = Jw();
      e = {
          blockedOn: null,
          target: e,
          priority: t
      };
      for (var n = 0; n < cr.length && t !== 0 && t < cr[n].priority; n++)
          ;
      cr.splice(n, 0, e),
      n === 0 && eb(e)
  }
}
;
function Sm(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11)
}
function dc(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
}
function n0() {}
function $5(e, t, n, r, i) {
  if (i) {
      if (typeof r == "function") {
          var s = r;
          r = function() {
              var l = gl(a);
              s.call(l)
          }
      }
      var a = x2(t, r, e, 0, null, !1, !1, "", n0);
      return e._reactRootContainer = a,
      e[qn] = a.current,
      Sa(e.nodeType === 8 ? e.parentNode : e),
      hi(),
      a
  }
  for (; i = e.lastChild; )
      e.removeChild(i);
  if (typeof r == "function") {
      var o = r;
      r = function() {
          var l = gl(u);
          o.call(l)
      }
  }
  var u = bm(e, 0, !1, null, null, !1, !1, "", n0);
  return e._reactRootContainer = u,
  e[qn] = u.current,
  Sa(e.nodeType === 8 ? e.parentNode : e),
  hi(function() {
      cc(t, u, n, r)
  }),
  u
}
function pc(e, t, n, r, i) {
  var s = n._reactRootContainer;
  if (s) {
      var a = s;
      if (typeof i == "function") {
          var o = i;
          i = function() {
              var u = gl(a);
              o.call(u)
          }
      }
      cc(t, a, e, i)
  } else
      a = $5(n, t, e, i, r);
  return gl(a)
}
Yw = function(e) {
  switch (e.tag) {
  case 3:
      var t = e.stateNode;
      if (t.current.memoizedState.isDehydrated) {
          var n = Zs(t.pendingLanes);
          n !== 0 && (Bh(t, n | 1),
          Dt(t, Le()),
          !(fe & 6) && (cs = Le() + 500,
          Ur()))
      }
      break;
  case 13:
      hi(function() {
          var r = Vn(e, 1);
          if (r !== null) {
              var i = xt();
              pn(r, e, 1, i)
          }
      }),
      xm(e, 1)
  }
}
;
Wh = function(e) {
  if (e.tag === 13) {
      var t = Vn(e, 134217728);
      if (t !== null) {
          var n = xt();
          pn(t, e, 134217728, n)
      }
      xm(e, 134217728)
  }
}
;
Xw = function(e) {
  if (e.tag === 13) {
      var t = Cr(e)
        , n = Vn(e, t);
      if (n !== null) {
          var r = xt();
          pn(n, e, t, r)
      }
      xm(e, t)
  }
}
;
Jw = function() {
  return de
}
;
Zw = function(e, t) {
  var n = de;
  try {
      return de = e,
      t()
  } finally {
      de = n
  }
}
;
Ld = function(e, t, n) {
  switch (t) {
  case "input":
      if (Id(e, n),
      t = n.name,
      n.type === "radio" && t != null) {
          for (n = e; n.parentNode; )
              n = n.parentNode;
          for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'),
          t = 0; t < n.length; t++) {
              var r = n[t];
              if (r !== e && r.form === e.form) {
                  var i = rc(r);
                  if (!i)
                      throw Error(H(90));
                  Dw(r),
                  Id(r, i)
              }
          }
      }
      break;
  case "textarea":
      Aw(e, n);
      break;
  case "select":
      t = n.value,
      t != null && Yi(e, !!n.multiple, t, !1)
  }
}
;
Fw = ym;
Uw = hi;
var R5 = {
  usingClientEntryPoint: !1,
  Events: [co, Fi, rc, Mw, Lw, ym]
}
, zs = {
  findFiberByHostInstance: ei,
  bundleType: 0,
  version: "18.2.0",
  rendererPackageName: "react-dom"
}
, N5 = {
  bundleType: zs.bundleType,
  version: zs.version,
  rendererPackageName: zs.rendererPackageName,
  rendererConfig: zs.rendererConfig,
  overrideHookState: null,
  overrideHookStateDeletePath: null,
  overrideHookStateRenamePath: null,
  overrideProps: null,
  overridePropsDeletePath: null,
  overridePropsRenamePath: null,
  setErrorHandler: null,
  setSuspenseHandler: null,
  scheduleUpdate: null,
  currentDispatcherRef: Jn.ReactCurrentDispatcher,
  findHostInstanceByFiber: function(e) {
      return e = Ww(e),
      e === null ? null : e.stateNode
  },
  findFiberByHostInstance: zs.findFiberByHostInstance || A5,
  findHostInstancesForRefresh: null,
  scheduleRefresh: null,
  scheduleRoot: null,
  setRefreshHandler: null,
  getCurrentFiber: null,
  reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var tu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!tu.isDisabled && tu.supportsFiber)
      try {
          Zl = tu.inject(N5),
          Tn = tu
      } catch {}
}
Ut.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = R5;
Ut.createPortal = function(e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!Sm(t))
      throw Error(H(200));
  return I5(e, t, null, n)
}
;
Ut.createRoot = function(e, t) {
  if (!Sm(e))
      throw Error(H(299));
  var n = !1
    , r = ""
    , i = E2;
  return t != null && (t.unstable_strictMode === !0 && (n = !0),
  t.identifierPrefix !== void 0 && (r = t.identifierPrefix),
  t.onRecoverableError !== void 0 && (i = t.onRecoverableError)),
  t = bm(e, 1, !1, null, null, n, !1, r, i),
  e[qn] = t.current,
  Sa(e.nodeType === 8 ? e.parentNode : e),
  new Em(t)
}
;
Ut.findDOMNode = function(e) {
  if (e == null)
      return null;
  if (e.nodeType === 1)
      return e;
  var t = e._reactInternals;
  if (t === void 0)
      throw typeof e.render == "function" ? Error(H(188)) : (e = Object.keys(e).join(","),
      Error(H(268, e)));
  return e = Ww(t),
  e = e === null ? null : e.stateNode,
  e
}
;
Ut.flushSync = function(e) {
  return hi(e)
}
;
Ut.hydrate = function(e, t, n) {
  if (!dc(t))
      throw Error(H(200));
  return pc(null, e, t, !0, n)
}
;
Ut.hydrateRoot = function(e, t, n) {
  if (!Sm(e))
      throw Error(H(405));
  var r = n != null && n.hydratedSources || null
    , i = !1
    , s = ""
    , a = E2;
  if (n != null && (n.unstable_strictMode === !0 && (i = !0),
  n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
  n.onRecoverableError !== void 0 && (a = n.onRecoverableError)),
  t = x2(t, null, e, 1, n ?? null, i, !1, s, a),
  e[qn] = t.current,
  Sa(e),
  r)
      for (e = 0; e < r.length; e++)
          n = r[e],
          i = n._getVersion,
          i = i(n._source),
          t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i);
  return new fc(t)
}
;
Ut.render = function(e, t, n) {
  if (!dc(t))
      throw Error(H(200));
  return pc(null, e, t, !1, n)
}
;
Ut.unmountComponentAtNode = function(e) {
  if (!dc(e))
      throw Error(H(40));
  return e._reactRootContainer ? (hi(function() {
      pc(null, null, e, !1, function() {
          e._reactRootContainer = null,
          e[qn] = null
      })
  }),
  !0) : !1
}
;
Ut.unstable_batchedUpdates = ym;
Ut.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
  if (!dc(n))
      throw Error(H(200));
  if (e == null || e._reactInternals === void 0)
      throw Error(H(38));
  return pc(e, t, n, !1, r)
}
;
Ut.version = "18.2.0-next-9e3b772b8-20220608";
function S2() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(S2)
      } catch (e) {
          console.error(e)
      }
}
S2(),
xw.exports = Ut;
var Cm = xw.exports;
const HU = gi(Cm);
var r0 = Cm;
Ku.createRoot = r0.createRoot,
Ku.hydrateRoot = r0.hydrateRoot;
function j5({storage: e, key: t="REACT_QUERY_OFFLINE_CACHE", throttleTime: n=1e3, serialize: r=JSON.stringify, deserialize: i=JSON.parse, retry: s}) {
  if (e) {
      const a = o => {
          try {
              e.setItem(t, r(o));
              return
          } catch (u) {
              return u
          }
      }
      ;
      return {
          persistClient: M5(o => {
              let u = o
                , l = a(u)
                , c = 0;
              for (; l && u; )
                  c++,
                  u = s == null ? void 0 : s({
                      persistedClient: u,
                      error: l,
                      errorCount: c
                  }),
                  u && (l = a(u))
          }
          , n),
          restoreClient: () => {
              const o = e.getItem(t);
              if (o)
                  return i(o)
          }
          ,
          removeClient: () => {
              e.removeItem(t)
          }
      }
  }
  return {
      persistClient: i0,
      restoreClient: () => {}
      ,
      removeClient: i0
  }
}
function M5(e, t=100) {
  let n = null, r;
  return function(...i) {
      r = i,
      n === null && (n = setTimeout( () => {
          e(...r),
          n = null
      }
      , t))
  }
}
function i0() {}
class bs {
  constructor() {
      this.listeners = new Set,
      this.subscribe = this.subscribe.bind(this)
  }
  subscribe(t) {
      const n = {
          listener: t
      };
      return this.listeners.add(n),
      this.onSubscribe(),
      () => {
          this.listeners.delete(n),
          this.onUnsubscribe()
      }
  }
  hasListeners() {
      return this.listeners.size > 0
  }
  onSubscribe() {}
  onUnsubscribe() {}
}
const Aa = typeof window > "u" || "Deno"in window;
function Gt() {}
function L5(e, t) {
  return typeof e == "function" ? e(t) : e
}
function gp(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0
}
function C2(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0)
}
function nu(e, t, n) {
  return po(e) ? typeof t == "function" ? {
      ...n,
      queryKey: e,
      queryFn: t
  } : {
      ...t,
      queryKey: e
  } : e
}
function _2(e, t, n) {
  return po(e) ? typeof t == "function" ? {
      ...n,
      mutationKey: e,
      mutationFn: t
  } : {
      ...t,
      mutationKey: e
  } : typeof e == "function" ? {
      ...t,
      mutationFn: e
  } : {
      ...e
  }
}
function ur(e, t, n) {
  return po(e) ? [{
      ...t,
      queryKey: e
  }, n] : [e || {}, t]
}
function s0(e, t) {
  const {type: n="all", exact: r, fetchStatus: i, predicate: s, queryKey: a, stale: o} = e;
  if (po(a)) {
      if (r) {
          if (t.queryHash !== _m(a, t.options))
              return !1
      } else if (!vl(t.queryKey, a))
          return !1
  }
  if (n !== "all") {
      const u = t.isActive();
      if (n === "active" && !u || n === "inactive" && u)
          return !1
  }
  return !(typeof o == "boolean" && t.isStale() !== o || typeof i < "u" && i !== t.state.fetchStatus || s && !s(t))
}
function a0(e, t) {
  const {exact: n, fetching: r, predicate: i, mutationKey: s} = e;
  if (po(s)) {
      if (!t.options.mutationKey)
          return !1;
      if (n) {
          if (ri(t.options.mutationKey) !== ri(s))
              return !1
      } else if (!vl(t.options.mutationKey, s))
          return !1
  }
  return !(typeof r == "boolean" && t.state.status === "loading" !== r || i && !i(t))
}
function _m(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || ri)(e)
}
function ri(e) {
  return JSON.stringify(e, (t, n) => vp(n) ? Object.keys(n).sort().reduce( (r, i) => (r[i] = n[i],
  r), {}) : n)
}
function vl(e, t) {
  return P2(e, t)
}
function P2(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some(n => !P2(e[n], t[n])) : !1
}
function hc(e, t) {
  if (e === t)
      return e;
  const n = o0(e) && o0(t);
  if (n || vp(e) && vp(t)) {
      const r = n ? e.length : Object.keys(e).length
        , i = n ? t : Object.keys(t)
        , s = i.length
        , a = n ? [] : {};
      let o = 0;
      for (let u = 0; u < s; u++) {
          const l = n ? u : i[u];
          a[l] = hc(e[l], t[l]),
          a[l] === e[l] && o++
      }
      return r === s && o === r ? e : a
  }
  return t
}
function wl(e, t) {
  if (e && !t || t && !e)
      return !1;
  for (const n in e)
      if (e[n] !== t[n])
          return !1;
  return !0
}
function o0(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length
}
function vp(e) {
  if (!u0(e))
      return !1;
  const t = e.constructor;
  if (typeof t > "u")
      return !0;
  const n = t.prototype;
  return !(!u0(n) || !n.hasOwnProperty("isPrototypeOf"))
}
function u0(e) {
  return Object.prototype.toString.call(e) === "[object Object]"
}
function po(e) {
  return Array.isArray(e)
}
function T2(e) {
  return new Promise(t => {
      setTimeout(t, e)
  }
  )
}
function l0(e) {
  T2(0).then(e)
}
function F5() {
  if (typeof AbortController == "function")
      return new AbortController
}
function wp(e, t, n) {
  return n.isDataEqual != null && n.isDataEqual(e, t) ? e : typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? hc(e, t) : t
}
class U5 extends bs {
  constructor() {
      super(),
      this.setup = t => {
          if (!Aa && window.addEventListener) {
              const n = () => t();
              return window.addEventListener("visibilitychange", n, !1),
              window.addEventListener("focus", n, !1),
              () => {
                  window.removeEventListener("visibilitychange", n),
                  window.removeEventListener("focus", n)
              }
          }
      }
  }
  onSubscribe() {
      this.cleanup || this.setEventListener(this.setup)
  }
  onUnsubscribe() {
      if (!this.hasListeners()) {
          var t;
          (t = this.cleanup) == null || t.call(this),
          this.cleanup = void 0
      }
  }
  setEventListener(t) {
      var n;
      this.setup = t,
      (n = this.cleanup) == null || n.call(this),
      this.cleanup = t(r => {
          typeof r == "boolean" ? this.setFocused(r) : this.onFocus()
      }
      )
  }
  setFocused(t) {
      this.focused !== t && (this.focused = t,
      this.onFocus())
  }
  onFocus() {
      this.listeners.forEach( ({listener: t}) => {
          t()
      }
      )
  }
  isFocused() {
      return typeof this.focused == "boolean" ? this.focused : typeof document > "u" ? !0 : [void 0, "visible", "prerender"].includes(document.visibilityState)
  }
}
const bl = new U5
, c0 = ["online", "offline"];
class z5 extends bs {
  constructor() {
      super(),
      this.setup = t => {
          if (!Aa && window.addEventListener) {
              const n = () => t();
              return c0.forEach(r => {
                  window.addEventListener(r, n, !1)
              }
              ),
              () => {
                  c0.forEach(r => {
                      window.removeEventListener(r, n)
                  }
                  )
              }
          }
      }
  }
  onSubscribe() {
      this.cleanup || this.setEventListener(this.setup)
  }
  onUnsubscribe() {
      if (!this.hasListeners()) {
          var t;
          (t = this.cleanup) == null || t.call(this),
          this.cleanup = void 0
      }
  }
  setEventListener(t) {
      var n;
      this.setup = t,
      (n = this.cleanup) == null || n.call(this),
      this.cleanup = t(r => {
          typeof r == "boolean" ? this.setOnline(r) : this.onOnline()
      }
      )
  }
  setOnline(t) {
      this.online !== t && (this.online = t,
      this.onOnline())
  }
  onOnline() {
      this.listeners.forEach( ({listener: t}) => {
          t()
      }
      )
  }
  isOnline() {
      return typeof this.online == "boolean" ? this.online : typeof navigator > "u" || typeof navigator.onLine > "u" ? !0 : navigator.onLine
  }
}
const xl = new z5;
function B5(e) {
  return Math.min(1e3 * 2 ** e, 3e4)
}
function mc(e) {
  return (e ?? "online") === "online" ? xl.isOnline() : !0
}
class O2 {
  constructor(t) {
      this.revert = t == null ? void 0 : t.revert,
      this.silent = t == null ? void 0 : t.silent
  }
}
function Nu(e) {
  return e instanceof O2
}
function k2(e) {
  let t = !1, n = 0, r = !1, i, s, a;
  const o = new Promise( (b, w) => {
      s = b,
      a = w
  }
  )
    , u = b => {
      r || (y(new O2(b)),
      e.abort == null || e.abort())
  }
    , l = () => {
      t = !0
  }
    , c = () => {
      t = !1
  }
    , f = () => !bl.isFocused() || e.networkMode !== "always" && !xl.isOnline()
    , d = b => {
      r || (r = !0,
      e.onSuccess == null || e.onSuccess(b),
      i == null || i(),
      s(b))
  }
    , y = b => {
      r || (r = !0,
      e.onError == null || e.onError(b),
      i == null || i(),
      a(b))
  }
    , m = () => new Promise(b => {
      i = w => {
          const h = r || !f();
          return h && b(w),
          h
      }
      ,
      e.onPause == null || e.onPause()
  }
  ).then( () => {
      i = void 0,
      r || e.onContinue == null || e.onContinue()
  }
  )
    , v = () => {
      if (r)
          return;
      let b;
      try {
          b = e.fn()
      } catch (w) {
          b = Promise.reject(w)
      }
      Promise.resolve(b).then(d).catch(w => {
          var h, g;
          if (r)
              return;
          const x = (h = e.retry) != null ? h : 3
            , S = (g = e.retryDelay) != null ? g : B5
            , E = typeof S == "function" ? S(n, w) : S
            , p = x === !0 || typeof x == "number" && n < x || typeof x == "function" && x(n, w);
          if (t || !p) {
              y(w);
              return
          }
          n++,
          e.onFail == null || e.onFail(n, w),
          T2(E).then( () => {
              if (f())
                  return m()
          }
          ).then( () => {
              t ? y(w) : v()
          }
          )
      }
      )
  }
  ;
  return mc(e.networkMode) ? v() : m().then(v),
  {
      promise: o,
      cancel: u,
      continue: () => (i == null ? void 0 : i()) ? o : Promise.resolve(),
      cancelRetry: l,
      continueRetry: c
  }
}
const Pm = console;
function W5() {
  let e = []
    , t = 0
    , n = c => {
      c()
  }
    , r = c => {
      c()
  }
  ;
  const i = c => {
      let f;
      t++;
      try {
          f = c()
      } finally {
          t--,
          t || o()
      }
      return f
  }
    , s = c => {
      t ? e.push(c) : l0( () => {
          n(c)
      }
      )
  }
    , a = c => (...f) => {
      s( () => {
          c(...f)
      }
      )
  }
    , o = () => {
      const c = e;
      e = [],
      c.length && l0( () => {
          r( () => {
              c.forEach(f => {
                  n(f)
              }
              )
          }
          )
      }
      )
  }
  ;
  return {
      batch: i,
      batchCalls: a,
      schedule: s,
      setNotifyFunction: c => {
          n = c
      }
      ,
      setBatchNotifyFunction: c => {
          r = c
      }
  }
}
const Ne = W5();
class D2 {
  destroy() {
      this.clearGcTimeout()
  }
  scheduleGc() {
      this.clearGcTimeout(),
      gp(this.cacheTime) && (this.gcTimeout = setTimeout( () => {
          this.optionalRemove()
      }
      , this.cacheTime))
  }
  updateCacheTime(t) {
      this.cacheTime = Math.max(this.cacheTime || 0, t ?? (Aa ? 1 / 0 : 5 * 60 * 1e3))
  }
  clearGcTimeout() {
      this.gcTimeout && (clearTimeout(this.gcTimeout),
      this.gcTimeout = void 0)
  }
}
class H5 extends D2 {
  constructor(t) {
      super(),
      this.abortSignalConsumed = !1,
      this.defaultOptions = t.defaultOptions,
      this.setOptions(t.options),
      this.observers = [],
      this.cache = t.cache,
      this.logger = t.logger || Pm,
      this.queryKey = t.queryKey,
      this.queryHash = t.queryHash,
      this.initialState = t.state || q5(this.options),
      this.state = this.initialState,
      this.scheduleGc()
  }
  get meta() {
      return this.options.meta
  }
  setOptions(t) {
      this.options = {
          ...this.defaultOptions,
          ...t
      },
      this.updateCacheTime(this.options.cacheTime)
  }
  optionalRemove() {
      !this.observers.length && this.state.fetchStatus === "idle" && this.cache.remove(this)
  }
  setData(t, n) {
      const r = wp(this.state.data, t, this.options);
      return this.dispatch({
          data: r,
          type: "success",
          dataUpdatedAt: n == null ? void 0 : n.updatedAt,
          manual: n == null ? void 0 : n.manual
      }),
      r
  }
  setState(t, n) {
      this.dispatch({
          type: "setState",
          state: t,
          setStateOptions: n
      })
  }
  cancel(t) {
      var n;
      const r = this.promise;
      return (n = this.retryer) == null || n.cancel(t),
      r ? r.then(Gt).catch(Gt) : Promise.resolve()
  }
  destroy() {
      super.destroy(),
      this.cancel({
          silent: !0
      })
  }
  reset() {
      this.destroy(),
      this.setState(this.initialState)
  }
  isActive() {
      return this.observers.some(t => t.options.enabled !== !1)
  }
  isDisabled() {
      return this.getObserversCount() > 0 && !this.isActive()
  }
  isStale() {
      return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(t => t.getCurrentResult().isStale)
  }
  isStaleByTime(t=0) {
      return this.state.isInvalidated || !this.state.dataUpdatedAt || !C2(this.state.dataUpdatedAt, t)
  }
  onFocus() {
      var t;
      const n = this.observers.find(r => r.shouldFetchOnWindowFocus());
      n && n.refetch({
          cancelRefetch: !1
      }),
      (t = this.retryer) == null || t.continue()
  }
  onOnline() {
      var t;
      const n = this.observers.find(r => r.shouldFetchOnReconnect());
      n && n.refetch({
          cancelRefetch: !1
      }),
      (t = this.retryer) == null || t.continue()
  }
  addObserver(t) {
      this.observers.includes(t) || (this.observers.push(t),
      this.clearGcTimeout(),
      this.cache.notify({
          type: "observerAdded",
          query: this,
          observer: t
      }))
  }
  removeObserver(t) {
      this.observers.includes(t) && (this.observers = this.observers.filter(n => n !== t),
      this.observers.length || (this.retryer && (this.abortSignalConsumed ? this.retryer.cancel({
          revert: !0
      }) : this.retryer.cancelRetry()),
      this.scheduleGc()),
      this.cache.notify({
          type: "observerRemoved",
          query: this,
          observer: t
      }))
  }
  getObserversCount() {
      return this.observers.length
  }
  invalidate() {
      this.state.isInvalidated || this.dispatch({
          type: "invalidate"
      })
  }
  fetch(t, n) {
      var r, i;
      if (this.state.fetchStatus !== "idle") {
          if (this.state.dataUpdatedAt && n != null && n.cancelRefetch)
              this.cancel({
                  silent: !0
              });
          else if (this.promise) {
              var s;
              return (s = this.retryer) == null || s.continueRetry(),
              this.promise
          }
      }
      if (t && this.setOptions(t),
      !this.options.queryFn) {
          const y = this.observers.find(m => m.options.queryFn);
          y && this.setOptions(y.options)
      }
      const a = F5()
        , o = {
          queryKey: this.queryKey,
          pageParam: void 0,
          meta: this.meta
      }
        , u = y => {
          Object.defineProperty(y, "signal", {
              enumerable: !0,
              get: () => {
                  if (a)
                      return this.abortSignalConsumed = !0,
                      a.signal
              }
          })
      }
      ;
      u(o);
      const l = () => this.options.queryFn ? (this.abortSignalConsumed = !1,
      this.options.queryFn(o)) : Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'")
        , c = {
          fetchOptions: n,
          options: this.options,
          queryKey: this.queryKey,
          state: this.state,
          fetchFn: l
      };
      if (u(c),
      (r = this.options.behavior) == null || r.onFetch(c),
      this.revertState = this.state,
      this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((i = c.fetchOptions) == null ? void 0 : i.meta)) {
          var f;
          this.dispatch({
              type: "fetch",
              meta: (f = c.fetchOptions) == null ? void 0 : f.meta
          })
      }
      const d = y => {
          if (Nu(y) && y.silent || this.dispatch({
              type: "error",
              error: y
          }),
          !Nu(y)) {
              var m, v, b, w;
              (m = (v = this.cache.config).onError) == null || m.call(v, y, this),
              (b = (w = this.cache.config).onSettled) == null || b.call(w, this.state.data, y, this)
          }
          this.isFetchingOptimistic || this.scheduleGc(),
          this.isFetchingOptimistic = !1
      }
      ;
      return this.retryer = k2({
          fn: c.fetchFn,
          abort: a == null ? void 0 : a.abort.bind(a),
          onSuccess: y => {
              var m, v, b, w;
              if (typeof y > "u") {
                  d(new Error(this.queryHash + " data is undefined"));
                  return
              }
              this.setData(y),
              (m = (v = this.cache.config).onSuccess) == null || m.call(v, y, this),
              (b = (w = this.cache.config).onSettled) == null || b.call(w, y, this.state.error, this),
              this.isFetchingOptimistic || this.scheduleGc(),
              this.isFetchingOptimistic = !1
          }
          ,
          onError: d,
          onFail: (y, m) => {
              this.dispatch({
                  type: "failed",
                  failureCount: y,
                  error: m
              })
          }
          ,
          onPause: () => {
              this.dispatch({
                  type: "pause"
              })
          }
          ,
          onContinue: () => {
              this.dispatch({
                  type: "continue"
              })
          }
          ,
          retry: c.options.retry,
          retryDelay: c.options.retryDelay,
          networkMode: c.options.networkMode
      }),
      this.promise = this.retryer.promise,
      this.promise
  }
  dispatch(t) {
      const n = r => {
          var i, s;
          switch (t.type) {
          case "failed":
              return {
                  ...r,
                  fetchFailureCount: t.failureCount,
                  fetchFailureReason: t.error
              };
          case "pause":
              return {
                  ...r,
                  fetchStatus: "paused"
              };
          case "continue":
              return {
                  ...r,
                  fetchStatus: "fetching"
              };
          case "fetch":
              return {
                  ...r,
                  fetchFailureCount: 0,
                  fetchFailureReason: null,
                  fetchMeta: (i = t.meta) != null ? i : null,
                  fetchStatus: mc(this.options.networkMode) ? "fetching" : "paused",
                  ...!r.dataUpdatedAt && {
                      error: null,
                      status: "loading"
                  }
              };
          case "success":
              return {
                  ...r,
                  data: t.data,
                  dataUpdateCount: r.dataUpdateCount + 1,
                  dataUpdatedAt: (s = t.dataUpdatedAt) != null ? s : Date.now(),
                  error: null,
                  isInvalidated: !1,
                  status: "success",
                  ...!t.manual && {
                      fetchStatus: "idle",
                      fetchFailureCount: 0,
                      fetchFailureReason: null
                  }
              };
          case "error":
              const a = t.error;
              return Nu(a) && a.revert && this.revertState ? {
                  ...this.revertState,
                  fetchStatus: "idle"
              } : {
                  ...r,
                  error: a,
                  errorUpdateCount: r.errorUpdateCount + 1,
                  errorUpdatedAt: Date.now(),
                  fetchFailureCount: r.fetchFailureCount + 1,
                  fetchFailureReason: a,
                  fetchStatus: "idle",
                  status: "error"
              };
          case "invalidate":
              return {
                  ...r,
                  isInvalidated: !0
              };
          case "setState":
              return {
                  ...r,
                  ...t.state
              }
          }
      }
      ;
      this.state = n(this.state),
      Ne.batch( () => {
          this.observers.forEach(r => {
              r.onQueryUpdate(t)
          }
          ),
          this.cache.notify({
              query: this,
              type: "updated",
              action: t
          })
      }
      )
  }
}
function q5(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData
    , n = typeof t < "u"
    , r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
      data: t,
      dataUpdateCount: 0,
      dataUpdatedAt: n ? r ?? Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchMeta: null,
      isInvalidated: !1,
      status: n ? "success" : "loading",
      fetchStatus: "idle"
  }
}
class V5 extends bs {
  constructor(t) {
      super(),
      this.config = t || {},
      this.queries = [],
      this.queriesMap = {}
  }
  build(t, n, r) {
      var i;
      const s = n.queryKey
        , a = (i = n.queryHash) != null ? i : _m(s, n);
      let o = this.get(a);
      return o || (o = new H5({
          cache: this,
          logger: t.getLogger(),
          queryKey: s,
          queryHash: a,
          options: t.defaultQueryOptions(n),
          state: r,
          defaultOptions: t.getQueryDefaults(s)
      }),
      this.add(o)),
      o
  }
  add(t) {
      this.queriesMap[t.queryHash] || (this.queriesMap[t.queryHash] = t,
      this.queries.push(t),
      this.notify({
          type: "added",
          query: t
      }))
  }
  remove(t) {
      const n = this.queriesMap[t.queryHash];
      n && (t.destroy(),
      this.queries = this.queries.filter(r => r !== t),
      n === t && delete this.queriesMap[t.queryHash],
      this.notify({
          type: "removed",
          query: t
      }))
  }
  clear() {
      Ne.batch( () => {
          this.queries.forEach(t => {
              this.remove(t)
          }
          )
      }
      )
  }
  get(t) {
      return this.queriesMap[t]
  }
  getAll() {
      return this.queries
  }
  find(t, n) {
      const [r] = ur(t, n);
      return typeof r.exact > "u" && (r.exact = !0),
      this.queries.find(i => s0(r, i))
  }
  findAll(t, n) {
      const [r] = ur(t, n);
      return Object.keys(r).length > 0 ? this.queries.filter(i => s0(r, i)) : this.queries
  }
  notify(t) {
      Ne.batch( () => {
          this.listeners.forEach( ({listener: n}) => {
              n(t)
          }
          )
      }
      )
  }
  onFocus() {
      Ne.batch( () => {
          this.queries.forEach(t => {
              t.onFocus()
          }
          )
      }
      )
  }
  onOnline() {
      Ne.batch( () => {
          this.queries.forEach(t => {
              t.onOnline()
          }
          )
      }
      )
  }
}
class K5 extends D2 {
  constructor(t) {
      super(),
      this.defaultOptions = t.defaultOptions,
      this.mutationId = t.mutationId,
      this.mutationCache = t.mutationCache,
      this.logger = t.logger || Pm,
      this.observers = [],
      this.state = t.state || I2(),
      this.setOptions(t.options),
      this.scheduleGc()
  }
  setOptions(t) {
      this.options = {
          ...this.defaultOptions,
          ...t
      },
      this.updateCacheTime(this.options.cacheTime)
  }
  get meta() {
      return this.options.meta
  }
  setState(t) {
      this.dispatch({
          type: "setState",
          state: t
      })
  }
  addObserver(t) {
      this.observers.includes(t) || (this.observers.push(t),
      this.clearGcTimeout(),
      this.mutationCache.notify({
          type: "observerAdded",
          mutation: this,
          observer: t
      }))
  }
  removeObserver(t) {
      this.observers = this.observers.filter(n => n !== t),
      this.scheduleGc(),
      this.mutationCache.notify({
          type: "observerRemoved",
          mutation: this,
          observer: t
      })
  }
  optionalRemove() {
      this.observers.length || (this.state.status === "loading" ? this.scheduleGc() : this.mutationCache.remove(this))
  }
  continue() {
      var t, n;
      return (t = (n = this.retryer) == null ? void 0 : n.continue()) != null ? t : this.execute()
  }
  async execute() {
      const t = () => {
          var p;
          return this.retryer = k2({
              fn: () => this.options.mutationFn ? this.options.mutationFn(this.state.variables) : Promise.reject("No mutationFn found"),
              onFail: (C, T) => {
                  this.dispatch({
                      type: "failed",
                      failureCount: C,
                      error: T
                  })
              }
              ,
              onPause: () => {
                  this.dispatch({
                      type: "pause"
                  })
              }
              ,
              onContinue: () => {
                  this.dispatch({
                      type: "continue"
                  })
              }
              ,
              retry: (p = this.options.retry) != null ? p : 0,
              retryDelay: this.options.retryDelay,
              networkMode: this.options.networkMode
          }),
          this.retryer.promise
      }
        , n = this.state.status === "loading";
      try {
          var r, i, s, a, o, u, l, c;
          if (!n) {
              var f, d, y, m;
              this.dispatch({
                  type: "loading",
                  variables: this.options.variables
              }),
              await ((f = (d = this.mutationCache.config).onMutate) == null ? void 0 : f.call(d, this.state.variables, this));
              const C = await ((y = (m = this.options).onMutate) == null ? void 0 : y.call(m, this.state.variables));
              C !== this.state.context && this.dispatch({
                  type: "loading",
                  context: C,
                  variables: this.state.variables
              })
          }
          const p = await t();
          return await ((r = (i = this.mutationCache.config).onSuccess) == null ? void 0 : r.call(i, p, this.state.variables, this.state.context, this)),
          await ((s = (a = this.options).onSuccess) == null ? void 0 : s.call(a, p, this.state.variables, this.state.context)),
          await ((o = (u = this.mutationCache.config).onSettled) == null ? void 0 : o.call(u, p, null, this.state.variables, this.state.context, this)),
          await ((l = (c = this.options).onSettled) == null ? void 0 : l.call(c, p, null, this.state.variables, this.state.context)),
          this.dispatch({
              type: "success",
              data: p
          }),
          p
      } catch (p) {
          try {
              var v, b, w, h, g, x, S, E;
              throw await ((v = (b = this.mutationCache.config).onError) == null ? void 0 : v.call(b, p, this.state.variables, this.state.context, this)),
              await ((w = (h = this.options).onError) == null ? void 0 : w.call(h, p, this.state.variables, this.state.context)),
              await ((g = (x = this.mutationCache.config).onSettled) == null ? void 0 : g.call(x, void 0, p, this.state.variables, this.state.context, this)),
              await ((S = (E = this.options).onSettled) == null ? void 0 : S.call(E, void 0, p, this.state.variables, this.state.context)),
              p
          } finally {
              this.dispatch({
                  type: "error",
                  error: p
              })
          }
      }
  }
  dispatch(t) {
      const n = r => {
          switch (t.type) {
          case "failed":
              return {
                  ...r,
                  failureCount: t.failureCount,
                  failureReason: t.error
              };
          case "pause":
              return {
                  ...r,
                  isPaused: !0
              };
          case "continue":
              return {
                  ...r,
                  isPaused: !1
              };
          case "loading":
              return {
                  ...r,
                  context: t.context,
                  data: void 0,
                  failureCount: 0,
                  failureReason: null,
                  error: null,
                  isPaused: !mc(this.options.networkMode),
                  status: "loading",
                  variables: t.variables
              };
          case "success":
              return {
                  ...r,
                  data: t.data,
                  failureCount: 0,
                  failureReason: null,
                  error: null,
                  status: "success",
                  isPaused: !1
              };
          case "error":
              return {
                  ...r,
                  data: void 0,
                  error: t.error,
                  failureCount: r.failureCount + 1,
                  failureReason: t.error,
                  isPaused: !1,
                  status: "error"
              };
          case "setState":
              return {
                  ...r,
                  ...t.state
              }
          }
      }
      ;
      this.state = n(this.state),
      Ne.batch( () => {
          this.observers.forEach(r => {
              r.onMutationUpdate(t)
          }
          ),
          this.mutationCache.notify({
              mutation: this,
              type: "updated",
              action: t
          })
      }
      )
  }
}
function I2() {
  return {
      context: void 0,
      data: void 0,
      error: null,
      failureCount: 0,
      failureReason: null,
      isPaused: !1,
      status: "idle",
      variables: void 0
  }
}
class G5 extends bs {
  constructor(t) {
      super(),
      this.config = t || {},
      this.mutations = [],
      this.mutationId = 0
  }
  build(t, n, r) {
      const i = new K5({
          mutationCache: this,
          logger: t.getLogger(),
          mutationId: ++this.mutationId,
          options: t.defaultMutationOptions(n),
          state: r,
          defaultOptions: n.mutationKey ? t.getMutationDefaults(n.mutationKey) : void 0
      });
      return this.add(i),
      i
  }
  add(t) {
      this.mutations.push(t),
      this.notify({
          type: "added",
          mutation: t
      })
  }
  remove(t) {
      this.mutations = this.mutations.filter(n => n !== t),
      this.notify({
          type: "removed",
          mutation: t
      })
  }
  clear() {
      Ne.batch( () => {
          this.mutations.forEach(t => {
              this.remove(t)
          }
          )
      }
      )
  }
  getAll() {
      return this.mutations
  }
  find(t) {
      return typeof t.exact > "u" && (t.exact = !0),
      this.mutations.find(n => a0(t, n))
  }
  findAll(t) {
      return this.mutations.filter(n => a0(t, n))
  }
  notify(t) {
      Ne.batch( () => {
          this.listeners.forEach( ({listener: n}) => {
              n(t)
          }
          )
      }
      )
  }
  resumePausedMutations() {
      var t;
      return this.resuming = ((t = this.resuming) != null ? t : Promise.resolve()).then( () => {
          const n = this.mutations.filter(r => r.state.isPaused);
          return Ne.batch( () => n.reduce( (r, i) => r.then( () => i.continue().catch(Gt)), Promise.resolve()))
      }
      ).then( () => {
          this.resuming = void 0
      }
      ),
      this.resuming
  }
}
function Q5() {
  return {
      onFetch: e => {
          e.fetchFn = () => {
              var t, n, r, i, s, a;
              const o = (t = e.fetchOptions) == null || (n = t.meta) == null ? void 0 : n.refetchPage
                , u = (r = e.fetchOptions) == null || (i = r.meta) == null ? void 0 : i.fetchMore
                , l = u == null ? void 0 : u.pageParam
                , c = (u == null ? void 0 : u.direction) === "forward"
                , f = (u == null ? void 0 : u.direction) === "backward"
                , d = ((s = e.state.data) == null ? void 0 : s.pages) || []
                , y = ((a = e.state.data) == null ? void 0 : a.pageParams) || [];
              let m = y
                , v = !1;
              const b = E => {
                  Object.defineProperty(E, "signal", {
                      enumerable: !0,
                      get: () => {
                          var p;
                          if ((p = e.signal) != null && p.aborted)
                              v = !0;
                          else {
                              var C;
                              (C = e.signal) == null || C.addEventListener("abort", () => {
                                  v = !0
                              }
                              )
                          }
                          return e.signal
                      }
                  })
              }
                , w = e.options.queryFn || ( () => Promise.reject("Missing queryFn for queryKey '" + e.options.queryHash + "'"))
                , h = (E, p, C, T) => (m = T ? [p, ...m] : [...m, p],
              T ? [C, ...E] : [...E, C])
                , g = (E, p, C, T) => {
                  if (v)
                      return Promise.reject("Cancelled");
                  if (typeof C > "u" && !p && E.length)
                      return Promise.resolve(E);
                  const O = {
                      queryKey: e.queryKey,
                      pageParam: C,
                      meta: e.options.meta
                  };
                  b(O);
                  const R = w(O);
                  return Promise.resolve(R).then(L => h(E, C, L, T))
              }
              ;
              let x;
              if (!d.length)
                  x = g([]);
              else if (c) {
                  const E = typeof l < "u"
                    , p = E ? l : f0(e.options, d);
                  x = g(d, E, p)
              } else if (f) {
                  const E = typeof l < "u"
                    , p = E ? l : Y5(e.options, d);
                  x = g(d, E, p, !0)
              } else {
                  m = [];
                  const E = typeof e.options.getNextPageParam > "u";
                  x = (o && d[0] ? o(d[0], 0, d) : !0) ? g([], E, y[0]) : Promise.resolve(h([], y[0], d[0]));
                  for (let C = 1; C < d.length; C++)
                      x = x.then(T => {
                          if (o && d[C] ? o(d[C], C, d) : !0) {
                              const R = E ? y[C] : f0(e.options, T);
                              return g(T, E, R)
                          }
                          return Promise.resolve(h(T, y[C], d[C]))
                      }
                      )
              }
              return x.then(E => ({
                  pages: E,
                  pageParams: m
              }))
          }
      }
  }
}
function f0(e, t) {
  return e.getNextPageParam == null ? void 0 : e.getNextPageParam(t[t.length - 1], t)
}
function Y5(e, t) {
  return e.getPreviousPageParam == null ? void 0 : e.getPreviousPageParam(t[0], t)
}
class X5 {
  constructor(t={}) {
      this.queryCache = t.queryCache || new V5,
      this.mutationCache = t.mutationCache || new G5,
      this.logger = t.logger || Pm,
      this.defaultOptions = t.defaultOptions || {},
      this.queryDefaults = [],
      this.mutationDefaults = [],
      this.mountCount = 0
  }
  mount() {
      this.mountCount++,
      this.mountCount === 1 && (this.unsubscribeFocus = bl.subscribe( () => {
          bl.isFocused() && (this.resumePausedMutations(),
          this.queryCache.onFocus())
      }
      ),
      this.unsubscribeOnline = xl.subscribe( () => {
          xl.isOnline() && (this.resumePausedMutations(),
          this.queryCache.onOnline())
      }
      ))
  }
  unmount() {
      var t, n;
      this.mountCount--,
      this.mountCount === 0 && ((t = this.unsubscribeFocus) == null || t.call(this),
      this.unsubscribeFocus = void 0,
      (n = this.unsubscribeOnline) == null || n.call(this),
      this.unsubscribeOnline = void 0)
  }
  isFetching(t, n) {
      const [r] = ur(t, n);
      return r.fetchStatus = "fetching",
      this.queryCache.findAll(r).length
  }
  isMutating(t) {
      return this.mutationCache.findAll({
          ...t,
          fetching: !0
      }).length
  }
  getQueryData(t, n) {
      var r;
      return (r = this.queryCache.find(t, n)) == null ? void 0 : r.state.data
  }
  ensureQueryData(t, n, r) {
      const i = nu(t, n, r)
        , s = this.getQueryData(i.queryKey);
      return s ? Promise.resolve(s) : this.fetchQuery(i)
  }
  getQueriesData(t) {
      return this.getQueryCache().findAll(t).map( ({queryKey: n, state: r}) => {
          const i = r.data;
          return [n, i]
      }
      )
  }
  setQueryData(t, n, r) {
      const i = this.queryCache.find(t)
        , s = i == null ? void 0 : i.state.data
        , a = L5(n, s);
      if (typeof a > "u")
          return;
      const o = nu(t)
        , u = this.defaultQueryOptions(o);
      return this.queryCache.build(this, u).setData(a, {
          ...r,
          manual: !0
      })
  }
  setQueriesData(t, n, r) {
      return Ne.batch( () => this.getQueryCache().findAll(t).map( ({queryKey: i}) => [i, this.setQueryData(i, n, r)]))
  }
  getQueryState(t, n) {
      var r;
      return (r = this.queryCache.find(t, n)) == null ? void 0 : r.state
  }
  removeQueries(t, n) {
      const [r] = ur(t, n)
        , i = this.queryCache;
      Ne.batch( () => {
          i.findAll(r).forEach(s => {
              i.remove(s)
          }
          )
      }
      )
  }
  resetQueries(t, n, r) {
      const [i,s] = ur(t, n, r)
        , a = this.queryCache
        , o = {
          type: "active",
          ...i
      };
      return Ne.batch( () => (a.findAll(i).forEach(u => {
          u.reset()
      }
      ),
      this.refetchQueries(o, s)))
  }
  cancelQueries(t, n, r) {
      const [i,s={}] = ur(t, n, r);
      typeof s.revert > "u" && (s.revert = !0);
      const a = Ne.batch( () => this.queryCache.findAll(i).map(o => o.cancel(s)));
      return Promise.all(a).then(Gt).catch(Gt)
  }
  invalidateQueries(t, n, r) {
      const [i,s] = ur(t, n, r);
      return Ne.batch( () => {
          var a, o;
          if (this.queryCache.findAll(i).forEach(l => {
              l.invalidate()
          }
          ),
          i.refetchType === "none")
              return Promise.resolve();
          const u = {
              ...i,
              type: (a = (o = i.refetchType) != null ? o : i.type) != null ? a : "active"
          };
          return this.refetchQueries(u, s)
      }
      )
  }
  refetchQueries(t, n, r) {
      const [i,s] = ur(t, n, r)
        , a = Ne.batch( () => this.queryCache.findAll(i).filter(u => !u.isDisabled()).map(u => {
          var l;
          return u.fetch(void 0, {
              ...s,
              cancelRefetch: (l = s == null ? void 0 : s.cancelRefetch) != null ? l : !0,
              meta: {
                  refetchPage: i.refetchPage
              }
          })
      }
      ));
      let o = Promise.all(a).then(Gt);
      return s != null && s.throwOnError || (o = o.catch(Gt)),
      o
  }
  fetchQuery(t, n, r) {
      const i = nu(t, n, r)
        , s = this.defaultQueryOptions(i);
      typeof s.retry > "u" && (s.retry = !1);
      const a = this.queryCache.build(this, s);
      return a.isStaleByTime(s.staleTime) ? a.fetch(s) : Promise.resolve(a.state.data)
  }
  prefetchQuery(t, n, r) {
      return this.fetchQuery(t, n, r).then(Gt).catch(Gt)
  }
  fetchInfiniteQuery(t, n, r) {
      const i = nu(t, n, r);
      return i.behavior = Q5(),
      this.fetchQuery(i)
  }
  prefetchInfiniteQuery(t, n, r) {
      return this.fetchInfiniteQuery(t, n, r).then(Gt).catch(Gt)
  }
  resumePausedMutations() {
      return this.mutationCache.resumePausedMutations()
  }
  getQueryCache() {
      return this.queryCache
  }
  getMutationCache() {
      return this.mutationCache
  }
  getLogger() {
      return this.logger
  }
  getDefaultOptions() {
      return this.defaultOptions
  }
  setDefaultOptions(t) {
      this.defaultOptions = t
  }
  setQueryDefaults(t, n) {
      const r = this.queryDefaults.find(i => ri(t) === ri(i.queryKey));
      r ? r.defaultOptions = n : this.queryDefaults.push({
          queryKey: t,
          defaultOptions: n
      })
  }
  getQueryDefaults(t) {
      if (!t)
          return;
      const n = this.queryDefaults.find(r => vl(t, r.queryKey));
      return n == null ? void 0 : n.defaultOptions
  }
  setMutationDefaults(t, n) {
      const r = this.mutationDefaults.find(i => ri(t) === ri(i.mutationKey));
      r ? r.defaultOptions = n : this.mutationDefaults.push({
          mutationKey: t,
          defaultOptions: n
      })
  }
  getMutationDefaults(t) {
      if (!t)
          return;
      const n = this.mutationDefaults.find(r => vl(t, r.mutationKey));
      return n == null ? void 0 : n.defaultOptions
  }
  defaultQueryOptions(t) {
      if (t != null && t._defaulted)
          return t;
      const n = {
          ...this.defaultOptions.queries,
          ...this.getQueryDefaults(t == null ? void 0 : t.queryKey),
          ...t,
          _defaulted: !0
      };
      return !n.queryHash && n.queryKey && (n.queryHash = _m(n.queryKey, n)),
      typeof n.refetchOnReconnect > "u" && (n.refetchOnReconnect = n.networkMode !== "always"),
      typeof n.useErrorBoundary > "u" && (n.useErrorBoundary = !!n.suspense),
      n
  }
  defaultMutationOptions(t) {
      return t != null && t._defaulted ? t : {
          ...this.defaultOptions.mutations,
          ...this.getMutationDefaults(t == null ? void 0 : t.mutationKey),
          ...t,
          _defaulted: !0
      }
  }
  clear() {
      this.queryCache.clear(),
      this.mutationCache.clear()
  }
}
class J5 extends bs {
  constructor(t, n) {
      super(),
      this.client = t,
      this.options = n,
      this.trackedProps = new Set,
      this.selectError = null,
      this.bindMethods(),
      this.setOptions(n)
  }
  bindMethods() {
      this.remove = this.remove.bind(this),
      this.refetch = this.refetch.bind(this)
  }
  onSubscribe() {
      this.listeners.size === 1 && (this.currentQuery.addObserver(this),
      d0(this.currentQuery, this.options) && this.executeFetch(),
      this.updateTimers())
  }
  onUnsubscribe() {
      this.hasListeners() || this.destroy()
  }
  shouldFetchOnReconnect() {
      return bp(this.currentQuery, this.options, this.options.refetchOnReconnect)
  }
  shouldFetchOnWindowFocus() {
      return bp(this.currentQuery, this.options, this.options.refetchOnWindowFocus)
  }
  destroy() {
      this.listeners = new Set,
      this.clearStaleTimeout(),
      this.clearRefetchInterval(),
      this.currentQuery.removeObserver(this)
  }
  setOptions(t, n) {
      const r = this.options
        , i = this.currentQuery;
      if (this.options = this.client.defaultQueryOptions(t),
      wl(r, this.options) || this.client.getQueryCache().notify({
          type: "observerOptionsUpdated",
          query: this.currentQuery,
          observer: this
      }),
      typeof this.options.enabled < "u" && typeof this.options.enabled != "boolean")
          throw new Error("Expected enabled to be a boolean");
      this.options.queryKey || (this.options.queryKey = r.queryKey),
      this.updateQuery();
      const s = this.hasListeners();
      s && p0(this.currentQuery, i, this.options, r) && this.executeFetch(),
      this.updateResult(n),
      s && (this.currentQuery !== i || this.options.enabled !== r.enabled || this.options.staleTime !== r.staleTime) && this.updateStaleTimeout();
      const a = this.computeRefetchInterval();
      s && (this.currentQuery !== i || this.options.enabled !== r.enabled || a !== this.currentRefetchInterval) && this.updateRefetchInterval(a)
  }
  getOptimisticResult(t) {
      const n = this.client.getQueryCache().build(this.client, t)
        , r = this.createResult(n, t);
      return e_(this, r, t) && (this.currentResult = r,
      this.currentResultOptions = this.options,
      this.currentResultState = this.currentQuery.state),
      r
  }
  getCurrentResult() {
      return this.currentResult
  }
  trackResult(t) {
      const n = {};
      return Object.keys(t).forEach(r => {
          Object.defineProperty(n, r, {
              configurable: !1,
              enumerable: !0,
              get: () => (this.trackedProps.add(r),
              t[r])
          })
      }
      ),
      n
  }
  getCurrentQuery() {
      return this.currentQuery
  }
  remove() {
      this.client.getQueryCache().remove(this.currentQuery)
  }
  refetch({refetchPage: t, ...n}={}) {
      return this.fetch({
          ...n,
          meta: {
              refetchPage: t
          }
      })
  }
  fetchOptimistic(t) {
      const n = this.client.defaultQueryOptions(t)
        , r = this.client.getQueryCache().build(this.client, n);
      return r.isFetchingOptimistic = !0,
      r.fetch().then( () => this.createResult(r, n))
  }
  fetch(t) {
      var n;
      return this.executeFetch({
          ...t,
          cancelRefetch: (n = t.cancelRefetch) != null ? n : !0
      }).then( () => (this.updateResult(),
      this.currentResult))
  }
  executeFetch(t) {
      this.updateQuery();
      let n = this.currentQuery.fetch(this.options, t);
      return t != null && t.throwOnError || (n = n.catch(Gt)),
      n
  }
  updateStaleTimeout() {
      if (this.clearStaleTimeout(),
      Aa || this.currentResult.isStale || !gp(this.options.staleTime))
          return;
      const n = C2(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;
      this.staleTimeoutId = setTimeout( () => {
          this.currentResult.isStale || this.updateResult()
      }
      , n)
  }
  computeRefetchInterval() {
      var t;
      return typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (t = this.options.refetchInterval) != null ? t : !1
  }
  updateRefetchInterval(t) {
      this.clearRefetchInterval(),
      this.currentRefetchInterval = t,
      !(Aa || this.options.enabled === !1 || !gp(this.currentRefetchInterval) || this.currentRefetchInterval === 0) && (this.refetchIntervalId = setInterval( () => {
          (this.options.refetchIntervalInBackground || bl.isFocused()) && this.executeFetch()
      }
      , this.currentRefetchInterval))
  }
  updateTimers() {
      this.updateStaleTimeout(),
      this.updateRefetchInterval(this.computeRefetchInterval())
  }
  clearStaleTimeout() {
      this.staleTimeoutId && (clearTimeout(this.staleTimeoutId),
      this.staleTimeoutId = void 0)
  }
  clearRefetchInterval() {
      this.refetchIntervalId && (clearInterval(this.refetchIntervalId),
      this.refetchIntervalId = void 0)
  }
  createResult(t, n) {
      const r = this.currentQuery
        , i = this.options
        , s = this.currentResult
        , a = this.currentResultState
        , o = this.currentResultOptions
        , u = t !== r
        , l = u ? t.state : this.currentQueryInitialState
        , c = u ? this.currentResult : this.previousQueryResult
        , {state: f} = t;
      let {dataUpdatedAt: d, error: y, errorUpdatedAt: m, fetchStatus: v, status: b} = f, w = !1, h = !1, g;
      if (n._optimisticResults) {
          const C = this.hasListeners()
            , T = !C && d0(t, n)
            , O = C && p0(t, r, n, i);
          (T || O) && (v = mc(t.options.networkMode) ? "fetching" : "paused",
          d || (b = "loading")),
          n._optimisticResults === "isRestoring" && (v = "idle")
      }
      if (n.keepPreviousData && !f.dataUpdatedAt && c != null && c.isSuccess && b !== "error")
          g = c.data,
          d = c.dataUpdatedAt,
          b = c.status,
          w = !0;
      else if (n.select && typeof f.data < "u")
          if (s && f.data === (a == null ? void 0 : a.data) && n.select === this.selectFn)
              g = this.selectResult;
          else
              try {
                  this.selectFn = n.select,
                  g = n.select(f.data),
                  g = wp(s == null ? void 0 : s.data, g, n),
                  this.selectResult = g,
                  this.selectError = null
              } catch (C) {
                  this.selectError = C
              }
      else
          g = f.data;
      if (typeof n.placeholderData < "u" && typeof g > "u" && b === "loading") {
          let C;
          if (s != null && s.isPlaceholderData && n.placeholderData === (o == null ? void 0 : o.placeholderData))
              C = s.data;
          else if (C = typeof n.placeholderData == "function" ? n.placeholderData() : n.placeholderData,
          n.select && typeof C < "u")
              try {
                  C = n.select(C),
                  this.selectError = null
              } catch (T) {
                  this.selectError = T
              }
          typeof C < "u" && (b = "success",
          g = wp(s == null ? void 0 : s.data, C, n),
          h = !0)
      }
      this.selectError && (y = this.selectError,
      g = this.selectResult,
      m = Date.now(),
      b = "error");
      const x = v === "fetching"
        , S = b === "loading"
        , E = b === "error";
      return {
          status: b,
          fetchStatus: v,
          isLoading: S,
          isSuccess: b === "success",
          isError: E,
          isInitialLoading: S && x,
          data: g,
          dataUpdatedAt: d,
          error: y,
          errorUpdatedAt: m,
          failureCount: f.fetchFailureCount,
          failureReason: f.fetchFailureReason,
          errorUpdateCount: f.errorUpdateCount,
          isFetched: f.dataUpdateCount > 0 || f.errorUpdateCount > 0,
          isFetchedAfterMount: f.dataUpdateCount > l.dataUpdateCount || f.errorUpdateCount > l.errorUpdateCount,
          isFetching: x,
          isRefetching: x && !S,
          isLoadingError: E && f.dataUpdatedAt === 0,
          isPaused: v === "paused",
          isPlaceholderData: h,
          isPreviousData: w,
          isRefetchError: E && f.dataUpdatedAt !== 0,
          isStale: Tm(t, n),
          refetch: this.refetch,
          remove: this.remove
      }
  }
  updateResult(t) {
      const n = this.currentResult
        , r = this.createResult(this.currentQuery, this.options);
      if (this.currentResultState = this.currentQuery.state,
      this.currentResultOptions = this.options,
      wl(r, n))
          return;
      this.currentResult = r;
      const i = {
          cache: !0
      }
        , s = () => {
          if (!n)
              return !0;
          const {notifyOnChangeProps: a} = this.options
            , o = typeof a == "function" ? a() : a;
          if (o === "all" || !o && !this.trackedProps.size)
              return !0;
          const u = new Set(o ?? this.trackedProps);
          return this.options.useErrorBoundary && u.add("error"),
          Object.keys(this.currentResult).some(l => {
              const c = l;
              return this.currentResult[c] !== n[c] && u.has(c)
          }
          )
      }
      ;
      (t == null ? void 0 : t.listeners) !== !1 && s() && (i.listeners = !0),
      this.notify({
          ...i,
          ...t
      })
  }
  updateQuery() {
      const t = this.client.getQueryCache().build(this.client, this.options);
      if (t === this.currentQuery)
          return;
      const n = this.currentQuery;
      this.currentQuery = t,
      this.currentQueryInitialState = t.state,
      this.previousQueryResult = this.currentResult,
      this.hasListeners() && (n == null || n.removeObserver(this),
      t.addObserver(this))
  }
  onQueryUpdate(t) {
      const n = {};
      t.type === "success" ? n.onSuccess = !t.manual : t.type === "error" && !Nu(t.error) && (n.onError = !0),
      this.updateResult(n),
      this.hasListeners() && this.updateTimers()
  }
  notify(t) {
      Ne.batch( () => {
          if (t.onSuccess) {
              var n, r, i, s;
              (n = (r = this.options).onSuccess) == null || n.call(r, this.currentResult.data),
              (i = (s = this.options).onSettled) == null || i.call(s, this.currentResult.data, null)
          } else if (t.onError) {
              var a, o, u, l;
              (a = (o = this.options).onError) == null || a.call(o, this.currentResult.error),
              (u = (l = this.options).onSettled) == null || u.call(l, void 0, this.currentResult.error)
          }
          t.listeners && this.listeners.forEach( ({listener: c}) => {
              c(this.currentResult)
          }
          ),
          t.cache && this.client.getQueryCache().notify({
              query: this.currentQuery,
              type: "observerResultsUpdated"
          })
      }
      )
  }
}
function Z5(e, t) {
  return t.enabled !== !1 && !e.state.dataUpdatedAt && !(e.state.status === "error" && t.retryOnMount === !1)
}
function d0(e, t) {
  return Z5(e, t) || e.state.dataUpdatedAt > 0 && bp(e, t, t.refetchOnMount)
}
function bp(e, t, n) {
  if (t.enabled !== !1) {
      const r = typeof n == "function" ? n(e) : n;
      return r === "always" || r !== !1 && Tm(e, t)
  }
  return !1
}
function p0(e, t, n, r) {
  return n.enabled !== !1 && (e !== t || r.enabled === !1) && (!n.suspense || e.state.status !== "error") && Tm(e, n)
}
function Tm(e, t) {
  return e.isStaleByTime(t.staleTime)
}
function e_(e, t, n) {
  return n.keepPreviousData ? !1 : n.placeholderData !== void 0 ? t.isPlaceholderData : !wl(e.getCurrentResult(), t)
}
let t_ = class extends bs {
  constructor(t, n) {
      super(),
      this.client = t,
      this.setOptions(n),
      this.bindMethods(),
      this.updateResult()
  }
  bindMethods() {
      this.mutate = this.mutate.bind(this),
      this.reset = this.reset.bind(this)
  }
  setOptions(t) {
      var n;
      const r = this.options;
      this.options = this.client.defaultMutationOptions(t),
      wl(r, this.options) || this.client.getMutationCache().notify({
          type: "observerOptionsUpdated",
          mutation: this.currentMutation,
          observer: this
      }),
      (n = this.currentMutation) == null || n.setOptions(this.options)
  }
  onUnsubscribe() {
      if (!this.hasListeners()) {
          var t;
          (t = this.currentMutation) == null || t.removeObserver(this)
      }
  }
  onMutationUpdate(t) {
      this.updateResult();
      const n = {
          listeners: !0
      };
      t.type === "success" ? n.onSuccess = !0 : t.type === "error" && (n.onError = !0),
      this.notify(n)
  }
  getCurrentResult() {
      return this.currentResult
  }
  reset() {
      this.currentMutation = void 0,
      this.updateResult(),
      this.notify({
          listeners: !0
      })
  }
  mutate(t, n) {
      return this.mutateOptions = n,
      this.currentMutation && this.currentMutation.removeObserver(this),
      this.currentMutation = this.client.getMutationCache().build(this.client, {
          ...this.options,
          variables: typeof t < "u" ? t : this.options.variables
      }),
      this.currentMutation.addObserver(this),
      this.currentMutation.execute()
  }
  updateResult() {
      const t = this.currentMutation ? this.currentMutation.state : I2()
        , n = {
          ...t,
          isLoading: t.status === "loading",
          isSuccess: t.status === "success",
          isError: t.status === "error",
          isIdle: t.status === "idle",
          mutate: this.mutate,
          reset: this.reset
      };
      this.currentResult = n
  }
  notify(t) {
      Ne.batch( () => {
          if (this.mutateOptions && this.hasListeners()) {
              if (t.onSuccess) {
                  var n, r, i, s;
                  (n = (r = this.mutateOptions).onSuccess) == null || n.call(r, this.currentResult.data, this.currentResult.variables, this.currentResult.context),
                  (i = (s = this.mutateOptions).onSettled) == null || i.call(s, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context)
              } else if (t.onError) {
                  var a, o, u, l;
                  (a = (o = this.mutateOptions).onError) == null || a.call(o, this.currentResult.error, this.currentResult.variables, this.currentResult.context),
                  (u = (l = this.mutateOptions).onSettled) == null || u.call(l, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context)
              }
          }
          t.listeners && this.listeners.forEach( ({listener: c}) => {
              c(this.currentResult)
          }
          )
      }
      )
  }
}
;
function n_(e) {
  return {
      mutationKey: e.options.mutationKey,
      state: e.state
  }
}
function r_(e) {
  return {
      state: e.state,
      queryKey: e.queryKey,
      queryHash: e.queryHash
  }
}
function i_(e) {
  return e.state.isPaused
}
function s_(e) {
  return e.state.status === "success"
}
function a_(e, t={}) {
  const n = []
    , r = [];
  if (t.dehydrateMutations !== !1) {
      const i = t.shouldDehydrateMutation || i_;
      e.getMutationCache().getAll().forEach(s => {
          i(s) && n.push(n_(s))
      }
      )
  }
  if (t.dehydrateQueries !== !1) {
      const i = t.shouldDehydrateQuery || s_;
      e.getQueryCache().getAll().forEach(s => {
          i(s) && r.push(r_(s))
      }
      )
  }
  return {
      mutations: n,
      queries: r
  }
}
function o_(e, t, n) {
  if (typeof t != "object" || t === null)
      return;
  const r = e.getMutationCache()
    , i = e.getQueryCache()
    , s = t.mutations || []
    , a = t.queries || [];
  s.forEach(o => {
      var u;
      r.build(e, {
          ...n == null || (u = n.defaultOptions) == null ? void 0 : u.mutations,
          mutationKey: o.mutationKey
      }, o.state)
  }
  ),
  a.forEach( ({queryKey: o, state: u, queryHash: l}) => {
      var c;
      const f = i.get(l);
      if (f) {
          if (f.state.dataUpdatedAt < u.dataUpdatedAt) {
              const {fetchStatus: d, ...y} = u;
              f.setState(y)
          }
          return
      }
      i.build(e, {
          ...n == null || (c = n.defaultOptions) == null ? void 0 : c.queries,
          queryKey: o,
          queryHash: l
      }, {
          ...u,
          fetchStatus: "idle"
      })
  }
  )
}
var A2 = {
  exports: {}
}
, $2 = {};
/**
* @license React
* use-sync-external-store-shim.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var fs = _;
function u_(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var l_ = typeof Object.is == "function" ? Object.is : u_
, c_ = fs.useState
, f_ = fs.useEffect
, d_ = fs.useLayoutEffect
, p_ = fs.useDebugValue;
function h_(e, t) {
  var n = t()
    , r = c_({
      inst: {
          value: n,
          getSnapshot: t
      }
  })
    , i = r[0].inst
    , s = r[1];
  return d_(function() {
      i.value = n,
      i.getSnapshot = t,
      qf(i) && s({
          inst: i
      })
  }, [e, n, t]),
  f_(function() {
      return qf(i) && s({
          inst: i
      }),
      e(function() {
          qf(i) && s({
              inst: i
          })
      })
  }, [e]),
  p_(n),
  n
}
function qf(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
      var n = t();
      return !l_(e, n)
  } catch {
      return !0
  }
}
function m_(e, t) {
  return t()
}
var y_ = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? m_ : h_;
$2.useSyncExternalStore = fs.useSyncExternalStore !== void 0 ? fs.useSyncExternalStore : y_;
A2.exports = $2;
var Om = A2.exports;
const g_ = Om.useSyncExternalStore
, h0 = _.createContext(void 0)
, R2 = _.createContext(!1);
function N2(e, t) {
  return e || (t && typeof window < "u" ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = h0),
  window.ReactQueryClientContext) : h0)
}
const km = ({context: e}={}) => {
  const t = _.useContext(N2(e, _.useContext(R2)));
  if (!t)
      throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return t
}
, v_ = ({client: e, children: t, context: n, contextSharing: r=!1}) => {
  _.useEffect( () => (e.mount(),
  () => {
      e.unmount()
  }
  ), [e]);
  const i = N2(n, r);
  return _.createElement(R2.Provider, {
      value: !n && r
  }, _.createElement(i.Provider, {
      value: e
  }, t))
}
, j2 = _.createContext(!1)
, w_ = () => _.useContext(j2);
j2.Provider;
function b_() {
  let e = !1;
  return {
      clearReset: () => {
          e = !1
      }
      ,
      reset: () => {
          e = !0
      }
      ,
      isReset: () => e
  }
}
const x_ = _.createContext(b_())
, E_ = () => _.useContext(x_);
function S_(e, t) {
  return typeof e == "function" ? e(...t) : !!e
}
function C_(e, t, n) {
  const r = _2(e, t, n)
    , i = km({
      context: r.context
  })
    , [s] = _.useState( () => new t_(i,r));
  _.useEffect( () => {
      s.setOptions(r)
  }
  , [s, r]);
  const a = g_(_.useCallback(u => s.subscribe(Ne.batchCalls(u)), [s]), () => s.getCurrentResult(), () => s.getCurrentResult())
    , o = _.useCallback( (u, l) => {
      s.mutate(u, l).catch(__)
  }
  , [s]);
  if (a.error && S_(s.options.useErrorBoundary, [a.error]))
      throw a.error;
  return {
      ...a,
      mutate: o,
      mutateAsync: a.mutate
  }
}
function __() {}
const P_ = ["added", "removed", "updated"];
function m0(e) {
  return P_.includes(e)
}
async function T_({queryClient: e, persister: t, maxAge: n=1e3 * 60 * 60 * 24, buster: r="", hydrateOptions: i}) {
  try {
      const s = await t.restoreClient();
      if (s)
          if (s.timestamp) {
              const a = Date.now() - s.timestamp > n
                , o = s.buster !== r;
              a || o ? t.removeClient() : o_(e, s.clientState, i)
          } else
              t.removeClient()
  } catch {
      t.removeClient()
  }
}
async function y0({queryClient: e, persister: t, buster: n="", dehydrateOptions: r}) {
  const i = {
      buster: n,
      timestamp: Date.now(),
      clientState: a_(e, r)
  };
  await t.persistClient(i)
}
function O_(e) {
  const t = e.queryClient.getQueryCache().subscribe(r => {
      m0(r.type) && y0(e)
  }
  )
    , n = e.queryClient.getMutationCache().subscribe(r => {
      m0(r.type) && y0(e)
  }
  );
  return () => {
      t(),
      n()
  }
}
function k_(e) {
  let t = !1, n;
  const r = () => {
      t = !0,
      n == null || n()
  }
    , i = T_(e).then( () => {
      t || (n = O_(e))
  }
  );
  return [r, i]
}
function M2(e, t={}) {
  const {fees: n=e.fees, formatters: r=e.formatters, serializers: i=e.serializers} = t;
  return {
      ...e,
      fees: n,
      formatters: r,
      serializers: i
  }
}
const D_ = "1.21.3"
, I_ = e => e
, yc = e => e
, A_ = () => `viem@${D_}`;
class V extends Error {
  constructor(t, n={}) {
      var s;
      super(),
      Object.defineProperty(this, "details", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "docsPath", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "metaMessages", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "shortMessage", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ViemError"
      }),
      Object.defineProperty(this, "version", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: A_()
      });
      const r = n.cause instanceof V ? n.cause.details : (s = n.cause) != null && s.message ? n.cause.message : n.details
        , i = n.cause instanceof V && n.cause.docsPath || n.docsPath;
      this.message = [t || "An error occurred.", "", ...n.metaMessages ? [...n.metaMessages, ""] : [], ...i ? [`Docs: https://viem.sh${i}.html${n.docsSlug ? `#${n.docsSlug}` : ""}`] : [], ...r ? [`Details: ${r}`] : [], `Version: ${this.version}`].join(`
`),
      n.cause && (this.cause = n.cause),
      this.details = r,
      this.docsPath = i,
      this.metaMessages = n.metaMessages,
      this.shortMessage = t
  }
  walk(t) {
      return L2(this, t)
  }
}
function L2(e, t) {
  return t != null && t(e) ? e : e && typeof e == "object" && "cause"in e ? L2(e.cause, t) : t ? null : e
}
class $_ extends V {
  constructor({max: t, min: n, signed: r, size: i, value: s}) {
      super(`Number "${s}" is not in safe ${i ? `${i * 8}-bit ${r ? "signed" : "unsigned"} ` : ""}integer range ${t ? `(${n} to ${t})` : `(above ${n})`}`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "IntegerOutOfRangeError"
      })
  }
}
class R_ extends V {
  constructor(t) {
      super(`Hex value "${t}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InvalidHexBooleanError"
      })
  }
}
class N_ extends V {
  constructor({givenSize: t, maxSize: n}) {
      super(`Size cannot exceed ${n} bytes. Given size: ${t} bytes.`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "SizeOverflowError"
      })
  }
}
function kn(e, {strict: t=!0}={}) {
  return !e || typeof e != "string" ? !1 : t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x")
}
function Ke(e) {
  return kn(e, {
      strict: !1
  }) ? Math.ceil((e.length - 2) / 2) : e.length
}
function oi(e, {dir: t="left"}={}) {
  let n = typeof e == "string" ? e.replace("0x", "") : e
    , r = 0;
  for (let i = 0; i < n.length - 1 && n[t === "left" ? i : n.length - i - 1].toString() === "0"; i++)
      r++;
  return n = t === "left" ? n.slice(r) : n.slice(0, n.length - r),
  typeof e == "string" ? (n.length === 1 && t === "right" && (n = `${n}0`),
  `0x${n.length % 2 === 1 ? `0${n}` : n}`) : n
}
class F2 extends V {
  constructor({offset: t, position: n, size: r}) {
      super(`Slice ${n === "start" ? "starting" : "ending"} at offset "${t}" is out-of-bounds (size: ${r}).`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "SliceOffsetOutOfBoundsError"
      })
  }
}
class U2 extends V {
  constructor({size: t, targetSize: n, type: r}) {
      super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${t}) exceeds padding size (${n}).`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "SizeExceedsPaddingSizeError"
      })
  }
}
function xs(e, {dir: t, size: n=32}={}) {
  return typeof e == "string" ? Pr(e, {
      dir: t,
      size: n
  }) : j_(e, {
      dir: t,
      size: n
  })
}
function Pr(e, {dir: t, size: n=32}={}) {
  if (n === null)
      return e;
  const r = e.replace("0x", "");
  if (r.length > n * 2)
      throw new U2({
          size: Math.ceil(r.length / 2),
          targetSize: n,
          type: "hex"
      });
  return `0x${r[t === "right" ? "padEnd" : "padStart"](n * 2, "0")}`
}
function j_(e, {dir: t, size: n=32}={}) {
  if (n === null)
      return e;
  if (e.length > n)
      throw new U2({
          size: e.length,
          targetSize: n,
          type: "bytes"
      });
  const r = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
      const s = t === "right";
      r[s ? i : n - i - 1] = e[s ? i : e.length - i - 1]
  }
  return r
}
const M_ = Array.from({
  length: 256
}, (e, t) => t.toString(16).padStart(2, "0"));
function Zn(e, t={}) {
  return typeof e == "number" || typeof e == "bigint" ? ie(e, t) : typeof e == "string" ? Dm(e, t) : typeof e == "boolean" ? z2(e, t) : $a(e, t)
}
function z2(e, t={}) {
  const n = `0x${Number(e)}`;
  return typeof t.size == "number" ? (zr(n, {
      size: t.size
  }),
  xs(n, {
      size: t.size
  })) : n
}
function $a(e, t={}) {
  let n = "";
  for (let i = 0; i < e.length; i++)
      n += M_[e[i]];
  const r = `0x${n}`;
  return typeof t.size == "number" ? (zr(r, {
      size: t.size
  }),
  xs(r, {
      dir: "right",
      size: t.size
  })) : r
}
function ie(e, t={}) {
  const {signed: n, size: r} = t
    , i = BigInt(e);
  let s;
  r ? n ? s = (1n << BigInt(r) * 8n - 1n) - 1n : s = 2n ** (BigInt(r) * 8n) - 1n : typeof e == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const a = typeof s == "bigint" && n ? -s - 1n : 0;
  if (s && i > s || i < a) {
      const u = typeof e == "bigint" ? "n" : "";
      throw new $_({
          max: s ? `${s}${u}` : void 0,
          min: `${a}${u}`,
          signed: n,
          size: r,
          value: `${e}${u}`
      })
  }
  const o = `0x${(n && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(16)}`;
  return r ? xs(o, {
      size: r
  }) : o
}
const L_ = new TextEncoder;
function Dm(e, t={}) {
  const n = L_.encode(e);
  return $a(n, t)
}
const F_ = new TextEncoder;
function $r(e, t={}) {
  return typeof e == "number" || typeof e == "bigint" ? z_(e, t) : typeof e == "boolean" ? U_(e, t) : kn(e) ? Im(e, t) : Bn(e, t)
}
function U_(e, t={}) {
  const n = new Uint8Array(1);
  return n[0] = Number(e),
  typeof t.size == "number" ? (zr(n, {
      size: t.size
  }),
  xs(n, {
      size: t.size
  })) : n
}
const An = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function g0(e) {
  if (e >= An.zero && e <= An.nine)
      return e - An.zero;
  if (e >= An.A && e <= An.F)
      return e - (An.A - 10);
  if (e >= An.a && e <= An.f)
      return e - (An.a - 10)
}
function Im(e, t={}) {
  let n = e;
  t.size && (zr(n, {
      size: t.size
  }),
  n = xs(n, {
      dir: "right",
      size: t.size
  }));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const i = r.length / 2
    , s = new Uint8Array(i);
  for (let a = 0, o = 0; a < i; a++) {
      const u = g0(r.charCodeAt(o++))
        , l = g0(r.charCodeAt(o++));
      if (u === void 0 || l === void 0)
          throw new V(`Invalid byte sequence ("${r[o - 2]}${r[o - 1]}" in "${r}").`);
      s[a] = u * 16 + l
  }
  return s
}
function z_(e, t) {
  const n = ie(e, t);
  return Im(n)
}
function Bn(e, t={}) {
  const n = F_.encode(e);
  return typeof t.size == "number" ? (zr(n, {
      size: t.size
  }),
  xs(n, {
      dir: "right",
      size: t.size
  })) : n
}
function zr(e, {size: t}) {
  if (Ke(e) > t)
      throw new N_({
          givenSize: Ke(e),
          maxSize: t
      })
}
function gc(e, t={}) {
  const {signed: n} = t;
  t.size && zr(e, {
      size: t.size
  });
  const r = BigInt(e);
  if (!n)
      return r;
  const i = (e.length - 2) / 2
    , s = (1n << BigInt(i) * 8n - 1n) - 1n;
  return r <= s ? r : r - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n
}
function B_(e, t={}) {
  let n = e;
  if (t.size && (zr(n, {
      size: t.size
  }),
  n = oi(n)),
  oi(n) === "0x00")
      return !1;
  if (oi(n) === "0x01")
      return !0;
  throw new R_(n)
}
function yt(e, t={}) {
  return Number(gc(e, t))
}
function Am(e, t={}) {
  let n = Im(e);
  return t.size && (zr(n, {
      size: t.size
  }),
  n = oi(n, {
      dir: "right"
  })),
  new TextDecoder().decode(n)
}
const B2 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559"
};
function W2(e) {
  const t = {
      ...e,
      blockHash: e.blockHash ? e.blockHash : null,
      blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
      chainId: e.chainId ? yt(e.chainId) : void 0,
      gas: e.gas ? BigInt(e.gas) : void 0,
      gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
      maxFeePerGas: e.maxFeePerGas ? BigInt(e.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: e.maxPriorityFeePerGas ? BigInt(e.maxPriorityFeePerGas) : void 0,
      nonce: e.nonce ? yt(e.nonce) : void 0,
      to: e.to ? e.to : null,
      transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
      type: e.type ? B2[e.type] : void 0,
      typeHex: e.type ? e.type : void 0,
      value: e.value ? BigInt(e.value) : void 0,
      v: e.v ? BigInt(e.v) : void 0
  };
  return t.yParity = ( () => {
      if (e.yParity)
          return Number(e.yParity);
      if (typeof t.v == "bigint") {
          if (t.v === 0n || t.v === 27n)
              return 0;
          if (t.v === 1n || t.v === 28n)
              return 1;
          if (t.v >= 35n)
              return t.v % 2n === 0n ? 1 : 0
      }
  }
  )(),
  t.type === "legacy" && (delete t.accessList,
  delete t.maxFeePerGas,
  delete t.maxPriorityFeePerGas,
  delete t.yParity),
  t.type === "eip2930" && (delete t.maxFeePerGas,
  delete t.maxPriorityFeePerGas),
  t
}
function H2(e) {
  var n;
  const t = (n = e.transactions) == null ? void 0 : n.map(r => typeof r == "string" ? r : W2(r));
  return {
      ...e,
      baseFeePerGas: e.baseFeePerGas ? BigInt(e.baseFeePerGas) : null,
      difficulty: e.difficulty ? BigInt(e.difficulty) : void 0,
      gasLimit: e.gasLimit ? BigInt(e.gasLimit) : void 0,
      gasUsed: e.gasUsed ? BigInt(e.gasUsed) : void 0,
      hash: e.hash ? e.hash : null,
      logsBloom: e.logsBloom ? e.logsBloom : null,
      nonce: e.nonce ? e.nonce : null,
      number: e.number ? BigInt(e.number) : null,
      size: e.size ? BigInt(e.size) : void 0,
      timestamp: e.timestamp ? BigInt(e.timestamp) : void 0,
      transactions: t,
      totalDifficulty: e.totalDifficulty ? BigInt(e.totalDifficulty) : null
  }
}
function mn(e, {args: t, eventName: n}={}) {
  return {
      ...e,
      blockHash: e.blockHash ? e.blockHash : null,
      blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
      logIndex: e.logIndex ? Number(e.logIndex) : null,
      transactionHash: e.transactionHash ? e.transactionHash : null,
      transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
      ...n ? {
          args: t,
          eventName: n
      } : {}
  }
}
const W_ = {
  "0x0": "reverted",
  "0x1": "success"
};
function H_(e) {
  return {
      ...e,
      blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
      contractAddress: e.contractAddress ? e.contractAddress : null,
      cumulativeGasUsed: e.cumulativeGasUsed ? BigInt(e.cumulativeGasUsed) : null,
      effectiveGasPrice: e.effectiveGasPrice ? BigInt(e.effectiveGasPrice) : null,
      gasUsed: e.gasUsed ? BigInt(e.gasUsed) : null,
      logs: e.logs ? e.logs.map(t => mn(t)) : null,
      to: e.to ? e.to : null,
      transactionIndex: e.transactionIndex ? yt(e.transactionIndex) : null,
      status: e.status ? W_[e.status] : null,
      type: e.type ? B2[e.type] || e.type : null
  }
}
const q_ = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2"
};
function vc(e) {
  return {
      ...e,
      gas: typeof e.gas < "u" ? ie(e.gas) : void 0,
      gasPrice: typeof e.gasPrice < "u" ? ie(e.gasPrice) : void 0,
      maxFeePerGas: typeof e.maxFeePerGas < "u" ? ie(e.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: typeof e.maxPriorityFeePerGas < "u" ? ie(e.maxPriorityFeePerGas) : void 0,
      nonce: typeof e.nonce < "u" ? ie(e.nonce) : void 0,
      type: typeof e.type < "u" ? q_[e.type] : void 0,
      value: typeof e.value < "u" ? ie(e.value) : void 0
  }
}
class Ra extends V {
  constructor({address: t}) {
      super(`Address "${t}" is invalid.`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InvalidAddressError"
      })
  }
}
class xp extends V {
  constructor({blockNumber: t, chain: n, contract: r}) {
      super(`Chain "${n.name}" does not support contract "${r.name}".`, {
          metaMessages: ["This could be due to any of the following:", ...t && r.blockCreated && r.blockCreated > t ? [`- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${t}).`] : [`- The chain does not have the contract "${r.name}" configured.`]]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ChainDoesNotSupportContract"
      })
  }
}
let V_ = class extends V {
  constructor({chain: t, currentChainId: n}) {
      super(`The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${t.id}  ${t.name}).`, {
          metaMessages: [`Current Chain ID:  ${n}`, `Expected Chain ID: ${t.id}  ${t.name}`]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ChainMismatchError"
      })
  }
}
;
class K_ extends V {
  constructor() {
      super(["No chain was provided to the request.", "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join(`
`)),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ChainNotFoundError"
      })
  }
}
class q2 extends V {
  constructor() {
      super("No chain was provided to the Client."),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ClientChainNotConfiguredError"
      })
  }
}
const G_ = {
  gwei: 9,
  wei: 18
}
, Q_ = {
  ether: -9,
  wei: 9
}
, Y_ = {
  ether: -18,
  gwei: -9
};
function El(e, t) {
  let n = e.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)),
  n = n.padStart(t, "0");
  let[i,s] = [n.slice(0, n.length - t), n.slice(n.length - t)];
  return s = s.replace(/(0+)$/, ""),
  `${r ? "-" : ""}${i || "0"}${s ? `.${s}` : ""}`
}
function It(e, t="wei") {
  return El(e, Q_[t])
}
class Vi extends V {
  constructor({cause: t, message: n}={}) {
      var i;
      const r = (i = n == null ? void 0 : n.replace("execution reverted: ", "")) == null ? void 0 : i.replace("execution reverted", "");
      super(`Execution reverted ${r ? `with reason: ${r}` : "for an unknown reason"}.`, {
          cause: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ExecutionRevertedError"
      })
  }
}
Object.defineProperty(Vi, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(Vi, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class Sl extends V {
  constructor({cause: t, maxFeePerGas: n}={}) {
      super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${It(n)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
          cause: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "FeeCapTooHigh"
      })
  }
}
Object.defineProperty(Sl, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class Ep extends V {
  constructor({cause: t, maxFeePerGas: n}={}) {
      super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${It(n)}` : ""} gwei) cannot be lower than the block base fee.`, {
          cause: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "FeeCapTooLow"
      })
  }
}
Object.defineProperty(Ep, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class Sp extends V {
  constructor({cause: t, nonce: n}={}) {
      super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}is higher than the next one expected.`, {
          cause: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "NonceTooHighError"
      })
  }
}
Object.defineProperty(Sp, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class Cp extends V {
  constructor({cause: t, nonce: n}={}) {
      super([`Nonce provided for the transaction ${n ? `(${n}) ` : ""}is lower than the current nonce of the account.`, "Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join(`
`), {
          cause: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "NonceTooLowError"
      })
  }
}
Object.defineProperty(Cp, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class _p extends V {
  constructor({cause: t, nonce: n}={}) {
      super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}exceeds the maximum allowed nonce.`, {
          cause: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "NonceMaxValueError"
      })
  }
}
Object.defineProperty(_p, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class Pp extends V {
  constructor({cause: t}={}) {
      super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join(`
`), {
          cause: t,
          metaMessages: ["This error could arise when the account does not have enough funds to:", " - pay for the total gas fee,", " - pay for the value to send.", " ", "The cost of the transaction is calculated as `gas * gas fee + value`, where:", " - `gas` is the amount of gas needed for transaction to execute,", " - `gas fee` is the gas fee,", " - `value` is the amount of ether to send to the recipient."]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InsufficientFundsError"
      })
  }
}
Object.defineProperty(Pp, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds/
});
class Tp extends V {
  constructor({cause: t, gas: n}={}) {
      super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
          cause: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "IntrinsicGasTooHighError"
      })
  }
}
Object.defineProperty(Tp, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class Op extends V {
  constructor({cause: t, gas: n}={}) {
      super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction is too low.`, {
          cause: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "IntrinsicGasTooLowError"
      })
  }
}
Object.defineProperty(Op, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class kp extends V {
  constructor({cause: t}) {
      super("The transaction type is not supported for this chain.", {
          cause: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "TransactionTypeNotSupportedError"
      })
  }
}
Object.defineProperty(kp, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class Cl extends V {
  constructor({cause: t, maxPriorityFeePerGas: n, maxFeePerGas: r}={}) {
      super([`The provided tip (\`maxPriorityFeePerGas\`${n ? ` = ${It(n)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r ? ` = ${It(r)} gwei` : ""}).`].join(`
`), {
          cause: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "TipAboveFeeCapError"
      })
  }
}
Object.defineProperty(Cl, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class wc extends V {
  constructor({cause: t}) {
      super(`An error occurred while executing: ${t == null ? void 0 : t.shortMessage}`, {
          cause: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "UnknownNodeError"
      })
  }
}
const X_ = /^0x[a-fA-F0-9]{40}$/;
function Rr(e) {
  return X_.test(e)
}
function Gn(e) {
  return typeof e[0] == "string" ? $m(e) : J_(e)
}
function J_(e) {
  let t = 0;
  for (const i of e)
      t += i.length;
  const n = new Uint8Array(t);
  let r = 0;
  for (const i of e)
      n.set(i, r),
      r += i.length;
  return n
}
function $m(e) {
  return `0x${e.reduce( (t, n) => t + n.replace("0x", ""), "")}`
}
function Z_(e, t) {
  const n = e.exec(t);
  return n == null ? void 0 : n.groups
}
const v0 = /^tuple(?<array>(\[(\d*)\])*)$/;
function Dp(e) {
  let t = e.type;
  if (v0.test(e.type) && "components"in e) {
      t = "(";
      const n = e.components.length;
      for (let i = 0; i < n; i++) {
          const s = e.components[i];
          t += Dp(s),
          i < n - 1 && (t += ", ")
      }
      const r = Z_(v0, e.type);
      return t += `)${(r == null ? void 0 : r.array) ?? ""}`,
      Dp({
          ...e,
          type: t
      })
  }
  return "indexed"in e && e.indexed && (t = `${t} indexed`),
  e.name ? `${t} ${e.name}` : t
}
function Bs(e) {
  let t = "";
  const n = e.length;
  for (let r = 0; r < n; r++) {
      const i = e[r];
      t += Dp(i),
      r !== n - 1 && (t += ", ")
  }
  return t
}
function eP(e) {
  return e.type === "function" ? `function ${e.name}(${Bs(e.inputs)})${e.stateMutability && e.stateMutability !== "nonpayable" ? ` ${e.stateMutability}` : ""}${e.outputs.length ? ` returns (${Bs(e.outputs)})` : ""}` : e.type === "event" ? `event ${e.name}(${Bs(e.inputs)})` : e.type === "error" ? `error ${e.name}(${Bs(e.inputs)})` : e.type === "constructor" ? `constructor(${Bs(e.inputs)})${e.stateMutability === "payable" ? " payable" : ""}` : e.type === "fallback" ? "fallback()" : "receive() external payable"
}
function ne(e, t, n) {
  return r => {
      var i;
      return ((i = e[t.name || n]) == null ? void 0 : i.call(e, r)) ?? t(e, r)
  }
}
function Qn(e, {includeName: t=!1}={}) {
  if (e.type !== "function" && e.type !== "event" && e.type !== "error")
      throw new hP(e.type);
  return `${e.name}(${bc(e.inputs, {
      includeName: t
  })})`
}
function bc(e, {includeName: t=!1}={}) {
  return e ? e.map(n => tP(n, {
      includeName: t
  })).join(t ? ", " : ",") : ""
}
function tP(e, {includeName: t}) {
  return e.type.startsWith("tuple") ? `(${bc(e.components, {
      includeName: t
  })})${e.type.slice(5)}` : e.type + (t && e.name ? ` ${e.name}` : "")
}
class nP extends V {
  constructor({docsPath: t}) {
      super(["A constructor was not found on the ABI.", "Make sure you are using the correct ABI and that the constructor exists on it."].join(`
`), {
          docsPath: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiConstructorNotFoundError"
      })
  }
}
class w0 extends V {
  constructor({docsPath: t}) {
      super(["Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.", "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."].join(`
`), {
          docsPath: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiConstructorParamsNotFoundError"
      })
  }
}
class Rm extends V {
  constructor({data: t, params: n, size: r}) {
      super([`Data size of ${r} bytes is too small for given parameters.`].join(`
`), {
          metaMessages: [`Params: (${bc(n, {
              includeName: !0
          })})`, `Data:   ${t} (${r} bytes)`]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiDecodingDataSizeTooSmallError"
      }),
      Object.defineProperty(this, "data", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "params", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "size", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      this.data = t,
      this.params = n,
      this.size = r
  }
}
class xc extends V {
  constructor() {
      super('Cannot decode zero data ("0x") with ABI parameters.'),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiDecodingZeroDataError"
      })
  }
}
class rP extends V {
  constructor({expectedLength: t, givenLength: n, type: r}) {
      super([`ABI encoding array length mismatch for type ${r}.`, `Expected length: ${t}`, `Given length: ${n}`].join(`
`)),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiEncodingArrayLengthMismatchError"
      })
  }
}
class iP extends V {
  constructor({expectedSize: t, value: n}) {
      super(`Size of bytes "${n}" (bytes${Ke(n)}) does not match expected size (bytes${t}).`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiEncodingBytesSizeMismatchError"
      })
  }
}
class sP extends V {
  constructor({expectedLength: t, givenLength: n}) {
      super(["ABI encoding params/values length mismatch.", `Expected length (params): ${t}`, `Given length (values): ${n}`].join(`
`)),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiEncodingLengthMismatchError"
      })
  }
}
class V2 extends V {
  constructor(t, {docsPath: n}) {
      super([`Encoded error signature "${t}" not found on ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${t}.`].join(`
`), {
          docsPath: n
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiErrorSignatureNotFoundError"
      }),
      Object.defineProperty(this, "signature", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      this.signature = t
  }
}
class aP extends V {
  constructor({docsPath: t}) {
      super("Cannot extract event signature from empty topics.", {
          docsPath: t
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiEventSignatureEmptyTopicsError"
      })
  }
}
class oP extends V {
  constructor(t, {docsPath: n}) {
      super([`Encoded event signature "${t}" not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${t}.`].join(`
`), {
          docsPath: n
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiEventSignatureNotFoundError"
      })
  }
}
class b0 extends V {
  constructor(t, {docsPath: n}={}) {
      super([`Event ${t ? `"${t}" ` : ""}not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it."].join(`
`), {
          docsPath: n
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiEventNotFoundError"
      })
  }
}
class _l extends V {
  constructor(t, {docsPath: n}={}) {
      super([`Function ${t ? `"${t}" ` : ""}not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it."].join(`
`), {
          docsPath: n
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiFunctionNotFoundError"
      })
  }
}
class uP extends V {
  constructor(t, {docsPath: n}) {
      super([`Function "${t}" does not contain any \`outputs\` on ABI.`, "Cannot decode function result without knowing what the parameter types are.", "Make sure you are using the correct ABI and that the function exists on it."].join(`
`), {
          docsPath: n
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiFunctionOutputsNotFoundError"
      })
  }
}
class lP extends V {
  constructor(t, n) {
      super("Found ambiguous types in overloaded ABI items.", {
          metaMessages: [`\`${t.type}\` in \`${Qn(t.abiItem)}\`, and`, `\`${n.type}\` in \`${Qn(n.abiItem)}\``, "", "These types encode differently and cannot be distinguished at runtime.", "Remove one of the ambiguous items in the ABI."]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AbiItemAmbiguityError"
      })
  }
}
class cP extends V {
  constructor({expectedSize: t, givenSize: n}) {
      super(`Expected bytes${t}, got bytes${n}.`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "BytesSizeMismatchError"
      })
  }
}
class mi extends V {
  constructor({abiItem: t, data: n, params: r, size: i}) {
      super([`Data size of ${i} bytes is too small for non-indexed event parameters.`].join(`
`), {
          metaMessages: [`Params: (${bc(r, {
              includeName: !0
          })})`, `Data:   ${n} (${i} bytes)`]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "DecodeLogDataMismatch"
      }),
      Object.defineProperty(this, "abiItem", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "data", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "params", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "size", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      this.abiItem = t,
      this.data = n,
      this.params = r,
      this.size = i
  }
}
class Es extends V {
  constructor({abiItem: t, param: n}) {
      super([`Expected a topic for indexed event parameter${n.name ? ` "${n.name}"` : ""} on event "${Qn(t, {
          includeName: !0
      })}".`].join(`
`)),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "DecodeLogTopicsMismatch"
      }),
      Object.defineProperty(this, "abiItem", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      this.abiItem = t
  }
}
class fP extends V {
  constructor(t, {docsPath: n}) {
      super([`Type "${t}" is not a valid encoding type.`, "Please provide a valid ABI type."].join(`
`), {
          docsPath: n
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InvalidAbiEncodingType"
      })
  }
}
class dP extends V {
  constructor(t, {docsPath: n}) {
      super([`Type "${t}" is not a valid decoding type.`, "Please provide a valid ABI type."].join(`
`), {
          docsPath: n
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InvalidAbiDecodingType"
      })
  }
}
class pP extends V {
  constructor(t) {
      super([`Value "${t}" is not a valid array.`].join(`
`)),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InvalidArrayError"
      })
  }
}
class hP extends V {
  constructor(t) {
      super([`"${t}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join(`
`)),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InvalidDefinitionTypeError"
      })
  }
}
class mP extends V {
  constructor(t) {
      super(`Filter type "${t}" is not supported.`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "FilterTypeNotSupportedError"
      })
  }
}
function yP(e) {
  let t = !0
    , n = ""
    , r = 0
    , i = ""
    , s = !1;
  for (let a = 0; a < e.length; a++) {
      const o = e[a];
      if (["(", ")", ","].includes(o) && (t = !0),
      o === "(" && r++,
      o === ")" && r--,
      !!t) {
          if (r === 0) {
              if (o === " " && ["event", "function", ""].includes(i))
                  i = "";
              else if (i += o,
              o === ")") {
                  s = !0;
                  break
              }
              continue
          }
          if (o === " ") {
              e[a - 1] !== "," && n !== "," && n !== ",(" && (n = "",
              t = !1);
              continue
          }
          i += o,
          n += o
      }
  }
  if (!s)
      throw new V("Unable to normalize signature.");
  return i
}
const K2 = e => {
  const t = typeof e == "string" ? e : eP(e);
  return yP(t)
}
, gP = e => K2(e);
function x0(e) {
  if (!Number.isSafeInteger(e) || e < 0)
      throw new Error(`Wrong positive integer: ${e}`)
}
function G2(e, ...t) {
  if (!(e instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
      throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)
}
function E0(e, t=!0) {
  if (e.destroyed)
      throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
      throw new Error("Hash#digest() has already been called")
}
function vP(e, t) {
  G2(e);
  const n = t.outputLen;
  if (e.length < n)
      throw new Error(`digestInto() expects output buffer of length at least ${n}`)
}
const ru = BigInt(2 ** 32 - 1)
, S0 = BigInt(32);
function wP(e, t=!1) {
  return t ? {
      h: Number(e & ru),
      l: Number(e >> S0 & ru)
  } : {
      h: Number(e >> S0 & ru) | 0,
      l: Number(e & ru) | 0
  }
}
function bP(e, t=!1) {
  let n = new Uint32Array(e.length)
    , r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
      const {h: s, l: a} = wP(e[i], t);
      [n[i],r[i]] = [s, a]
  }
  return [n, r]
}
const xP = (e, t, n) => e << n | t >>> 32 - n
, EP = (e, t, n) => t << n | e >>> 32 - n
, SP = (e, t, n) => t << n - 32 | e >>> 64 - n
, CP = (e, t, n) => e << n - 32 | t >>> 64 - n;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _P = e => e instanceof Uint8Array
, PP = e => new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength / 4))
, TP = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!TP)
  throw new Error("Non little-endian hardware is not supported");
function OP(e) {
  if (typeof e != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e))
}
function Q2(e) {
  if (typeof e == "string" && (e = OP(e)),
  !_P(e))
      throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e
}
class kP {
  clone() {
      return this._cloneInto()
  }
}
function DP(e) {
  const t = r => e().update(Q2(r)).digest()
    , n = e();
  return t.outputLen = n.outputLen,
  t.blockLen = n.blockLen,
  t.create = () => e(),
  t
}
const [Y2,X2,J2] = [[], [], []]
, IP = BigInt(0)
, Ws = BigInt(1)
, AP = BigInt(2)
, $P = BigInt(7)
, RP = BigInt(256)
, NP = BigInt(113);
for (let e = 0, t = Ws, n = 1, r = 0; e < 24; e++) {
  [n,r] = [r, (2 * n + 3 * r) % 5],
  Y2.push(2 * (5 * r + n)),
  X2.push((e + 1) * (e + 2) / 2 % 64);
  let i = IP;
  for (let s = 0; s < 7; s++)
      t = (t << Ws ^ (t >> $P) * NP) % RP,
      t & AP && (i ^= Ws << (Ws << BigInt(s)) - Ws);
  J2.push(i)
}
const [jP,MP] = bP(J2, !0)
, C0 = (e, t, n) => n > 32 ? SP(e, t, n) : xP(e, t, n)
, _0 = (e, t, n) => n > 32 ? CP(e, t, n) : EP(e, t, n);
function LP(e, t=24) {
  const n = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
      for (let a = 0; a < 10; a++)
          n[a] = e[a] ^ e[a + 10] ^ e[a + 20] ^ e[a + 30] ^ e[a + 40];
      for (let a = 0; a < 10; a += 2) {
          const o = (a + 8) % 10
            , u = (a + 2) % 10
            , l = n[u]
            , c = n[u + 1]
            , f = C0(l, c, 1) ^ n[o]
            , d = _0(l, c, 1) ^ n[o + 1];
          for (let y = 0; y < 50; y += 10)
              e[a + y] ^= f,
              e[a + y + 1] ^= d
      }
      let i = e[2]
        , s = e[3];
      for (let a = 0; a < 24; a++) {
          const o = X2[a]
            , u = C0(i, s, o)
            , l = _0(i, s, o)
            , c = Y2[a];
          i = e[c],
          s = e[c + 1],
          e[c] = u,
          e[c + 1] = l
      }
      for (let a = 0; a < 50; a += 10) {
          for (let o = 0; o < 10; o++)
              n[o] = e[a + o];
          for (let o = 0; o < 10; o++)
              e[a + o] ^= ~n[(o + 2) % 10] & n[(o + 4) % 10]
      }
      e[0] ^= jP[r],
      e[1] ^= MP[r]
  }
  n.fill(0)
}
class Nm extends kP {
  constructor(t, n, r, i=!1, s=24) {
      if (super(),
      this.blockLen = t,
      this.suffix = n,
      this.outputLen = r,
      this.enableXOF = i,
      this.rounds = s,
      this.pos = 0,
      this.posOut = 0,
      this.finished = !1,
      this.destroyed = !1,
      x0(r),
      0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200),
      this.state32 = PP(this.state)
  }
  keccak() {
      LP(this.state32, this.rounds),
      this.posOut = 0,
      this.pos = 0
  }
  update(t) {
      E0(this);
      const {blockLen: n, state: r} = this;
      t = Q2(t);
      const i = t.length;
      for (let s = 0; s < i; ) {
          const a = Math.min(n - this.pos, i - s);
          for (let o = 0; o < a; o++)
              r[this.pos++] ^= t[s++];
          this.pos === n && this.keccak()
      }
      return this
  }
  finish() {
      if (this.finished)
          return;
      this.finished = !0;
      const {state: t, suffix: n, pos: r, blockLen: i} = this;
      t[r] ^= n,
      n & 128 && r === i - 1 && this.keccak(),
      t[i - 1] ^= 128,
      this.keccak()
  }
  writeInto(t) {
      E0(this, !1),
      G2(t),
      this.finish();
      const n = this.state
        , {blockLen: r} = this;
      for (let i = 0, s = t.length; i < s; ) {
          this.posOut >= r && this.keccak();
          const a = Math.min(r - this.posOut, s - i);
          t.set(n.subarray(this.posOut, this.posOut + a), i),
          this.posOut += a,
          i += a
      }
      return t
  }
  xofInto(t) {
      if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
      return this.writeInto(t)
  }
  xof(t) {
      return x0(t),
      this.xofInto(new Uint8Array(t))
  }
  digestInto(t) {
      if (vP(t, this),
      this.finished)
          throw new Error("digest() was already called");
      return this.writeInto(t),
      this.destroy(),
      t
  }
  digest() {
      return this.digestInto(new Uint8Array(this.outputLen))
  }
  destroy() {
      this.destroyed = !0,
      this.state.fill(0)
  }
  _cloneInto(t) {
      const {blockLen: n, suffix: r, outputLen: i, rounds: s, enableXOF: a} = this;
      return t || (t = new Nm(n,r,i,a,s)),
      t.state32.set(this.state32),
      t.pos = this.pos,
      t.posOut = this.posOut,
      t.finished = this.finished,
      t.rounds = s,
      t.suffix = r,
      t.outputLen = i,
      t.enableXOF = a,
      t.destroyed = this.destroyed,
      t
  }
}
const FP = (e, t, n) => DP( () => new Nm(t,e,n))
, UP = FP(1, 136, 256 / 8);
function bt(e, t) {
  const n = t || "hex"
    , r = UP(kn(e, {
      strict: !1
  }) ? $r(e) : e);
  return n === "bytes" ? r : Zn(r)
}
const zP = e => bt($r(e))
, jm = e => zP(gP(e));
function Be(e, t, n, {strict: r}={}) {
  return kn(e, {
      strict: !1
  }) ? WP(e, t, n, {
      strict: r
  }) : BP(e, t, n, {
      strict: r
  })
}
function Z2(e, t) {
  if (typeof t == "number" && t > 0 && t > Ke(e) - 1)
      throw new F2({
          offset: t,
          position: "start",
          size: Ke(e)
      })
}
function ex(e, t, n) {
  if (typeof t == "number" && typeof n == "number" && Ke(e) !== n - t)
      throw new F2({
          offset: n,
          position: "end",
          size: Ke(e)
      })
}
function BP(e, t, n, {strict: r}={}) {
  Z2(e, t);
  const i = e.slice(t, n);
  return r && ex(i, t, n),
  i
}
function WP(e, t, n, {strict: r}={}) {
  Z2(e, t);
  const i = `0x${e.replace("0x", "").slice((t ?? 0) * 2, (n ?? e.length) * 2)}`;
  return r && ex(i, t, n),
  i
}
function ho(e, t) {
  if (e.length !== t.length)
      throw new sP({
          expectedLength: e.length,
          givenLength: t.length
      });
  const n = HP({
      params: e,
      values: t
  })
    , r = Lm(n);
  return r.length === 0 ? "0x" : r
}
function HP({params: e, values: t}) {
  const n = [];
  for (let r = 0; r < e.length; r++)
      n.push(Mm({
          param: e[r],
          value: t[r]
      }));
  return n
}
function Mm({param: e, value: t}) {
  const n = Ec(e.type);
  if (n) {
      const [r,i] = n;
      return VP(t, {
          length: r,
          param: {
              ...e,
              type: i
          }
      })
  }
  if (e.type === "tuple")
      return XP(t, {
          param: e
      });
  if (e.type === "address")
      return qP(t);
  if (e.type === "bool")
      return GP(t);
  if (e.type.startsWith("uint") || e.type.startsWith("int")) {
      const r = e.type.startsWith("int");
      return QP(t, {
          signed: r
      })
  }
  if (e.type.startsWith("bytes"))
      return KP(t, {
          param: e
      });
  if (e.type === "string")
      return YP(t);
  throw new fP(e.type,{
      docsPath: "/docs/contract/encodeAbiParameters"
  })
}
function Lm(e) {
  let t = 0;
  for (let s = 0; s < e.length; s++) {
      const {dynamic: a, encoded: o} = e[s];
      a ? t += 32 : t += Ke(o)
  }
  const n = []
    , r = [];
  let i = 0;
  for (let s = 0; s < e.length; s++) {
      const {dynamic: a, encoded: o} = e[s];
      a ? (n.push(ie(t + i, {
          size: 32
      })),
      r.push(o),
      i += Ke(o)) : n.push(o)
  }
  return Gn([...n, ...r])
}
function qP(e) {
  if (!Rr(e))
      throw new Ra({
          address: e
      });
  return {
      dynamic: !1,
      encoded: Pr(e.toLowerCase())
  }
}
function VP(e, {length: t, param: n}) {
  const r = t === null;
  if (!Array.isArray(e))
      throw new pP(e);
  if (!r && e.length !== t)
      throw new rP({
          expectedLength: t,
          givenLength: e.length,
          type: `${n.type}[${t}]`
      });
  let i = !1;
  const s = [];
  for (let a = 0; a < e.length; a++) {
      const o = Mm({
          param: n,
          value: e[a]
      });
      o.dynamic && (i = !0),
      s.push(o)
  }
  if (r || i) {
      const a = Lm(s);
      if (r) {
          const o = ie(s.length, {
              size: 32
          });
          return {
              dynamic: !0,
              encoded: s.length > 0 ? Gn([o, a]) : o
          }
      }
      if (i)
          return {
              dynamic: !0,
              encoded: a
          }
  }
  return {
      dynamic: !1,
      encoded: Gn(s.map( ({encoded: a}) => a))
  }
}
function KP(e, {param: t}) {
  const [,n] = t.type.split("bytes")
    , r = Ke(e);
  if (!n) {
      let i = e;
      return r % 32 !== 0 && (i = Pr(i, {
          dir: "right",
          size: Math.ceil((e.length - 2) / 2 / 32) * 32
      })),
      {
          dynamic: !0,
          encoded: Gn([Pr(ie(r, {
              size: 32
          })), i])
      }
  }
  if (r !== parseInt(n))
      throw new iP({
          expectedSize: parseInt(n),
          value: e
      });
  return {
      dynamic: !1,
      encoded: Pr(e, {
          dir: "right"
      })
  }
}
function GP(e) {
  return {
      dynamic: !1,
      encoded: Pr(z2(e))
  }
}
function QP(e, {signed: t}) {
  return {
      dynamic: !1,
      encoded: ie(e, {
          size: 32,
          signed: t
      })
  }
}
function YP(e) {
  const t = Dm(e)
    , n = Math.ceil(Ke(t) / 32)
    , r = [];
  for (let i = 0; i < n; i++)
      r.push(Pr(Be(t, i * 32, (i + 1) * 32), {
          dir: "right"
      }));
  return {
      dynamic: !0,
      encoded: Gn([Pr(ie(Ke(t), {
          size: 32
      })), ...r])
  }
}
function XP(e, {param: t}) {
  let n = !1;
  const r = [];
  for (let i = 0; i < t.components.length; i++) {
      const s = t.components[i]
        , a = Array.isArray(e) ? i : s.name
        , o = Mm({
          param: s,
          value: e[a]
      });
      r.push(o),
      o.dynamic && (n = !0)
  }
  return {
      dynamic: n,
      encoded: n ? Lm(r) : Gn(r.map( ({encoded: i}) => i))
  }
}
function Ec(e) {
  const t = e.match(/^(.*)\[(\d+)?\]$/);
  return t ? [t[2] ? Number(t[2]) : null, t[1]] : void 0
}
const JP = e => bt($r(e))
, Fm = e => Be(JP(K2(e)), 0, 4);
function mo({abi: e, args: t=[], name: n}) {
  const r = kn(n, {
      strict: !1
  })
    , i = e.filter(a => r ? a.type === "function" ? Fm(a) === n : a.type === "event" ? jm(a) === n : !1 : "name"in a && a.name === n);
  if (i.length === 0)
      return;
  if (i.length === 1)
      return i[0];
  let s;
  for (const a of i) {
      if (!("inputs"in a))
          continue;
      if (!t || t.length === 0) {
          if (!a.inputs || a.inputs.length === 0)
              return a;
          continue
      }
      if (!a.inputs || a.inputs.length === 0 || a.inputs.length !== t.length)
          continue;
      if (t.every( (u, l) => {
          const c = "inputs"in a && a.inputs[l];
          return c ? Ip(u, c) : !1
      }
      )) {
          if (s && "inputs"in s && s.inputs) {
              const u = tx(a.inputs, s.inputs, t);
              if (u)
                  throw new lP({
                      abiItem: a,
                      type: u[0]
                  },{
                      abiItem: s,
                      type: u[1]
                  })
          }
          s = a
      }
  }
  return s || i[0]
}
function Ip(e, t) {
  const n = typeof e
    , r = t.type;
  switch (r) {
  case "address":
      return Rr(e);
  case "bool":
      return n === "boolean";
  case "function":
      return n === "string";
  case "string":
      return n === "string";
  default:
      return r === "tuple" && "components"in t ? Object.values(t.components).every( (i, s) => Ip(Object.values(e)[s], i)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r) ? n === "number" || n === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r) ? n === "string" || e instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r) ? Array.isArray(e) && e.every(i => Ip(i, {
          ...t,
          type: r.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1
  }
}
function tx(e, t, n) {
  for (const r in e) {
      const i = e[r]
        , s = t[r];
      if (i.type === "tuple" && s.type === "tuple" && "components"in i && "components"in s)
          return tx(i.components, s.components, n[r]);
      const a = [i.type, s.type];
      if (a.includes("address") && a.includes("bytes20") ? !0 : a.includes("address") && a.includes("string") || a.includes("address") && a.includes("bytes") ? Rr(n[r]) : !1)
          return a
  }
}
function yo({abi: e, eventName: t, args: n}) {
  var o;
  let r = e[0];
  if (t && (r = mo({
      abi: e,
      args: n,
      name: t
  }),
  !r))
      throw new b0(t,{
          docsPath: "/docs/contract/encodeEventTopics"
      });
  if (r.type !== "event")
      throw new b0(void 0,{
          docsPath: "/docs/contract/encodeEventTopics"
      });
  const i = Qn(r)
    , s = jm(i);
  let a = [];
  if (n && "inputs"in r) {
      const u = (o = r.inputs) == null ? void 0 : o.filter(c => "indexed"in c && c.indexed)
        , l = Array.isArray(n) ? n : Object.values(n).length > 0 ? (u == null ? void 0 : u.map(c => n[c.name])) ?? [] : [];
      l.length > 0 && (a = (u == null ? void 0 : u.map( (c, f) => Array.isArray(l[f]) ? l[f].map( (d, y) => P0({
          param: c,
          value: l[f][y]
      })) : l[f] ? P0({
          param: c,
          value: l[f]
      }) : null)) ?? [])
  }
  return [s, ...a]
}
function P0({param: e, value: t}) {
  if (e.type === "string" || e.type === "bytes")
      return bt($r(t));
  if (e.type === "tuple" || e.type.match(/^(.*)\[(\d+)?\]$/))
      throw new mP(e.type);
  return ho([e], [t])
}
function Sc(e, {method: t}) {
  var r, i;
  const n = {};
  return e.transport.type === "fallback" && ((i = (r = e.transport).onResponse) == null || i.call(r, ({method: s, response: a, status: o, transport: u}) => {
      o === "success" && t === s && (n[a] = u.request)
  }
  )),
  s => n[s] || e.request
}
async function nx(e, {address: t, abi: n, args: r, eventName: i, fromBlock: s, strict: a, toBlock: o}) {
  const u = Sc(e, {
      method: "eth_newFilter"
  })
    , l = i ? yo({
      abi: n,
      args: r,
      eventName: i
  }) : void 0
    , c = await e.request({
      method: "eth_newFilter",
      params: [{
          address: t,
          fromBlock: typeof s == "bigint" ? ie(s) : s,
          toBlock: typeof o == "bigint" ? ie(o) : o,
          topics: l
      }]
  });
  return {
      abi: n,
      args: r,
      eventName: i,
      id: c,
      request: u(c),
      strict: a,
      type: "event"
  }
}
function rn(e) {
  return typeof e == "string" ? {
      address: e,
      type: "json-rpc"
  } : e
}
function Br({abi: e, args: t, functionName: n}) {
  let r = e[0];
  if (n && (r = mo({
      abi: e,
      args: t,
      name: n
  }),
  !r))
      throw new _l(n,{
          docsPath: "/docs/contract/encodeFunctionData"
      });
  if (r.type !== "function")
      throw new _l(void 0,{
          docsPath: "/docs/contract/encodeFunctionData"
      });
  const i = Qn(r)
    , s = Fm(i)
    , a = "inputs"in r && r.inputs ? ho(r.inputs, t ?? []) : void 0;
  return $m([s, a ?? "0x"])
}
const rx = {
  1: "An `assert` condition failed.",
  17: "Arithmic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}
, ZP = {
  inputs: [{
      name: "message",
      type: "string"
  }],
  name: "Error",
  type: "error"
}
, e3 = {
  inputs: [{
      name: "reason",
      type: "uint256"
  }],
  name: "Panic",
  type: "error"
};
function Um(e, t) {
  const n = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase()
    , r = bt(Bn(n), "bytes")
    , i = (t ? n.substring(`${t}0x`.length) : n).split("");
  for (let s = 0; s < 40; s += 2)
      r[s >> 1] >> 4 >= 8 && i[s] && (i[s] = i[s].toUpperCase()),
      (r[s >> 1] & 15) >= 8 && i[s + 1] && (i[s + 1] = i[s + 1].toUpperCase());
  return `0x${i.join("")}`
}
function Tr(e, t) {
  if (!Rr(e))
      throw new Ra({
          address: e
      });
  return Um(e, t)
}
function Cc(e, t) {
  if (t === "0x" && e.length > 0)
      throw new xc;
  if (Ke(t) && Ke(t) < 32)
      throw new Rm({
          data: t,
          params: e,
          size: Ke(t)
      });
  return t3({
      data: t,
      params: e
  })
}
function t3({data: e, params: t}) {
  const n = [];
  let r = 0;
  for (let i = 0; i < t.length; i++) {
      if (r >= Ke(e))
          throw new Rm({
              data: e,
              params: t,
              size: Ke(e)
          });
      const s = t[i]
        , {consumed: a, value: o} = ns({
          data: e,
          param: s,
          position: r
      });
      n.push(o),
      r += a
  }
  return n
}
function ns({data: e, param: t, position: n}) {
  const r = Ec(t.type);
  if (r) {
      const [s,a] = r;
      return r3(e, {
          length: s,
          param: {
              ...t,
              type: a
          },
          position: n
      })
  }
  if (t.type === "tuple")
      return u3(e, {
          param: t,
          position: n
      });
  if (t.type === "string")
      return o3(e, {
          position: n
      });
  if (t.type.startsWith("bytes"))
      return s3(e, {
          param: t,
          position: n
      });
  const i = Be(e, n, n + 32, {
      strict: !0
  });
  if (t.type.startsWith("uint") || t.type.startsWith("int"))
      return a3(i, {
          param: t
      });
  if (t.type === "address")
      return n3(i);
  if (t.type === "bool")
      return i3(i);
  throw new dP(t.type,{
      docsPath: "/docs/contract/decodeAbiParameters"
  })
}
function n3(e) {
  return {
      consumed: 32,
      value: Um(Be(e, -20))
  }
}
function r3(e, {param: t, length: n, position: r}) {
  if (!n) {
      const a = yt(Be(e, r, r + 32, {
          strict: !0
      }))
        , o = yt(Be(e, a, a + 32, {
          strict: !0
      }));
      let u = 0;
      const l = [];
      for (let c = 0; c < o; ++c) {
          const f = ns({
              data: Be(e, a + 32),
              param: t,
              position: u
          });
          u += f.consumed,
          l.push(f.value)
      }
      return {
          value: l,
          consumed: 32
      }
  }
  if (Pl(t)) {
      const a = Ec(t.type)
        , o = !(a != null && a[0]);
      let u = 0;
      const l = [];
      for (let c = 0; c < n; ++c) {
          const f = yt(Be(e, r, r + 32, {
              strict: !0
          }))
            , d = ns({
              data: Be(e, f),
              param: t,
              position: o ? u : c * 32
          });
          u += d.consumed,
          l.push(d.value)
      }
      return {
          value: l,
          consumed: 32
      }
  }
  let i = 0;
  const s = [];
  for (let a = 0; a < n; ++a) {
      const o = ns({
          data: e,
          param: t,
          position: r + i
      });
      i += o.consumed,
      s.push(o.value)
  }
  return {
      value: s,
      consumed: i
  }
}
function i3(e) {
  return {
      consumed: 32,
      value: B_(e)
  }
}
function s3(e, {param: t, position: n}) {
  const [r,i] = t.type.split("bytes");
  if (!i) {
      const a = yt(Be(e, n, n + 32, {
          strict: !0
      }))
        , o = yt(Be(e, a, a + 32, {
          strict: !0
      }));
      return o === 0 ? {
          consumed: 32,
          value: "0x"
      } : {
          consumed: 32,
          value: Be(e, a + 32, a + 32 + o, {
              strict: !0
          })
      }
  }
  return {
      consumed: 32,
      value: Be(e, n, n + parseInt(i), {
          strict: !0
      })
  }
}
function a3(e, {param: t}) {
  const n = t.type.startsWith("int");
  return {
      consumed: 32,
      value: parseInt(t.type.split("int")[1] || "256") > 48 ? gc(e, {
          signed: n
      }) : yt(e, {
          signed: n
      })
  }
}
function o3(e, {position: t}) {
  const n = yt(Be(e, t, t + 32, {
      strict: !0
  }))
    , r = yt(Be(e, n, n + 32, {
      strict: !0
  }));
  return r === 0 ? {
      consumed: 32,
      value: ""
  } : {
      consumed: 32,
      value: Am(oi(Be(e, n + 32, n + 32 + r, {
          strict: !0
      })))
  }
}
function u3(e, {param: t, position: n}) {
  const r = t.components.length === 0 || t.components.some( ({name: a}) => !a)
    , i = r ? [] : {};
  let s = 0;
  if (Pl(t)) {
      const a = yt(Be(e, n, n + 32, {
          strict: !0
      }));
      for (let o = 0; o < t.components.length; ++o) {
          const u = t.components[o]
            , l = ns({
              data: Be(e, a),
              param: u,
              position: s
          });
          s += l.consumed,
          i[r ? o : u == null ? void 0 : u.name] = l.value
      }
      return {
          consumed: 32,
          value: i
      }
  }
  for (let a = 0; a < t.components.length; ++a) {
      const o = t.components[a]
        , u = ns({
          data: e,
          param: o,
          position: n + s
      });
      s += u.consumed,
      i[r ? a : o == null ? void 0 : o.name] = u.value
  }
  return {
      consumed: s,
      value: i
  }
}
function Pl(e) {
  var r;
  const {type: t} = e;
  if (t === "string" || t === "bytes" || t.endsWith("[]"))
      return !0;
  if (t === "tuple")
      return (r = e.components) == null ? void 0 : r.some(Pl);
  const n = Ec(e.type);
  return !!(n && Pl({
      ...e,
      type: n[1]
  }))
}
function l3({abi: e, data: t}) {
  const n = Be(t, 0, 4);
  if (n === "0x")
      throw new xc;
  const i = [...e || [], ZP, e3].find(s => s.type === "error" && n === Fm(Qn(s)));
  if (!i)
      throw new V2(n,{
          docsPath: "/docs/contract/decodeErrorResult"
      });
  return {
      abiItem: i,
      args: "inputs"in i && i.inputs && i.inputs.length > 0 ? Cc(i.inputs, Be(t, 4)) : void 0,
      errorName: i.name
  }
}
const Et = (e, t, n) => JSON.stringify(e, (r, i) => {
  const s = typeof i == "bigint" ? i.toString() : i;
  return typeof t == "function" ? t(r, s) : s
}
, n);
function ix({abiItem: e, args: t, includeFunctionName: n=!0, includeName: r=!1}) {
  if ("name"in e && "inputs"in e && e.inputs)
      return `${n ? e.name : ""}(${e.inputs.map( (i, s) => `${r && i.name ? `${i.name}: ` : ""}${typeof t[s] == "object" ? Et(t[s]) : t[s]}`).join(", ")})`
}
function zm(e, t="wei") {
  return El(e, G_[t])
}
function go(e) {
  const t = Object.entries(e).map( ([r,i]) => i === void 0 || i === !1 ? null : [r, i]).filter(Boolean)
    , n = t.reduce( (r, [i]) => Math.max(r, i.length), 0);
  return t.map( ([r,i]) => `  ${`${r}:`.padEnd(n + 1)}  ${i}`).join(`
`)
}
class c3 extends V {
  constructor() {
      super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.", "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join(`
`)),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "FeeConflictError"
      })
  }
}
class f3 extends V {
  constructor({transaction: t}) {
      super("Cannot infer a transaction type from provided transaction.", {
          metaMessages: ["Provided Transaction:", "{", go(t), "}", "", "To infer the type, either provide:", "- a `type` to the Transaction, or", "- an EIP-1559 Transaction with `maxFeePerGas`, or", "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or", "- a Legacy Transaction with `gasPrice`"]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InvalidSerializableTransactionError"
      })
  }
}
class d3 extends V {
  constructor(t, {account: n, docsPath: r, chain: i, data: s, gas: a, gasPrice: o, maxFeePerGas: u, maxPriorityFeePerGas: l, nonce: c, to: f, value: d}) {
      var m;
      const y = go({
          chain: i && `${i == null ? void 0 : i.name} (id: ${i == null ? void 0 : i.id})`,
          from: n == null ? void 0 : n.address,
          to: f,
          value: typeof d < "u" && `${zm(d)} ${((m = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : m.symbol) || "ETH"}`,
          data: s,
          gas: a,
          gasPrice: typeof o < "u" && `${It(o)} gwei`,
          maxFeePerGas: typeof u < "u" && `${It(u)} gwei`,
          maxPriorityFeePerGas: typeof l < "u" && `${It(l)} gwei`,
          nonce: c
      });
      super(t.shortMessage, {
          cause: t,
          docsPath: r,
          metaMessages: [...t.metaMessages ? [...t.metaMessages, " "] : [], "Request Arguments:", y].filter(Boolean)
      }),
      Object.defineProperty(this, "cause", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "TransactionExecutionError"
      }),
      this.cause = t
  }
}
class sx extends V {
  constructor({blockHash: t, blockNumber: n, blockTag: r, hash: i, index: s}) {
      let a = "Transaction";
      r && s !== void 0 && (a = `Transaction at block time "${r}" at index "${s}"`),
      t && s !== void 0 && (a = `Transaction at block hash "${t}" at index "${s}"`),
      n && s !== void 0 && (a = `Transaction at block number "${n}" at index "${s}"`),
      i && (a = `Transaction with hash "${i}"`),
      super(`${a} could not be found.`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "TransactionNotFoundError"
      })
  }
}
class ax extends V {
  constructor({hash: t}) {
      super(`Transaction receipt with hash "${t}" could not be found. The Transaction may not be processed on a block yet.`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "TransactionReceiptNotFoundError"
      })
  }
}
class p3 extends V {
  constructor({hash: t}) {
      super(`Timed out while waiting for transaction with hash "${t}" to be confirmed.`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "WaitForTransactionReceiptTimeoutError"
      })
  }
}
class ox extends V {
  constructor(t, {account: n, docsPath: r, chain: i, data: s, gas: a, gasPrice: o, maxFeePerGas: u, maxPriorityFeePerGas: l, nonce: c, to: f, value: d}) {
      var v;
      const y = n ? rn(n) : void 0
        , m = go({
          from: y == null ? void 0 : y.address,
          to: f,
          value: typeof d < "u" && `${zm(d)} ${((v = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : v.symbol) || "ETH"}`,
          data: s,
          gas: a,
          gasPrice: typeof o < "u" && `${It(o)} gwei`,
          maxFeePerGas: typeof u < "u" && `${It(u)} gwei`,
          maxPriorityFeePerGas: typeof l < "u" && `${It(l)} gwei`,
          nonce: c
      });
      super(t.shortMessage, {
          cause: t,
          docsPath: r,
          metaMessages: [...t.metaMessages ? [...t.metaMessages, " "] : [], "Raw Call Arguments:", m].filter(Boolean)
      }),
      Object.defineProperty(this, "cause", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "CallExecutionError"
      }),
      this.cause = t
  }
}
class Bm extends V {
  constructor(t, {abi: n, args: r, contractAddress: i, docsPath: s, functionName: a, sender: o}) {
      const u = mo({
          abi: n,
          args: r,
          name: a
      })
        , l = u ? ix({
          abiItem: u,
          args: r,
          includeFunctionName: !1,
          includeName: !1
      }) : void 0
        , c = u ? Qn(u, {
          includeName: !0
      }) : void 0
        , f = go({
          address: i && I_(i),
          function: c,
          args: l && l !== "()" && `${[...Array((a == null ? void 0 : a.length) ?? 0).keys()].map( () => " ").join("")}${l}`,
          sender: o
      });
      super(t.shortMessage || `An unknown error occurred while executing the contract function "${a}".`, {
          cause: t,
          docsPath: s,
          metaMessages: [...t.metaMessages ? [...t.metaMessages, " "] : [], "Contract Call:", f].filter(Boolean)
      }),
      Object.defineProperty(this, "abi", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "args", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "cause", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "contractAddress", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "formattedArgs", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "functionName", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "sender", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ContractFunctionExecutionError"
      }),
      this.abi = n,
      this.args = r,
      this.cause = t,
      this.contractAddress = i,
      this.functionName = a,
      this.sender = o
  }
}
class Ap extends V {
  constructor({abi: t, data: n, functionName: r, message: i}) {
      let s, a, o, u;
      if (n && n !== "0x")
          try {
              a = l3({
                  abi: t,
                  data: n
              });
              const {abiItem: c, errorName: f, args: d} = a;
              if (f === "Error")
                  u = d[0];
              else if (f === "Panic") {
                  const [y] = d;
                  u = rx[y]
              } else {
                  const y = c ? Qn(c, {
                      includeName: !0
                  }) : void 0
                    , m = c && d ? ix({
                      abiItem: c,
                      args: d,
                      includeFunctionName: !1,
                      includeName: !1
                  }) : void 0;
                  o = [y ? `Error: ${y}` : "", m && m !== "()" ? `       ${[...Array((f == null ? void 0 : f.length) ?? 0).keys()].map( () => " ").join("")}${m}` : ""]
              }
          } catch (c) {
              s = c
          }
      else
          i && (u = i);
      let l;
      s instanceof V2 && (l = s.signature,
      o = [`Unable to decode signature "${l}" as it was not found on the provided ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${l}.`]),
      super(u && u !== "execution reverted" || l ? [`The contract function "${r}" reverted with the following ${l ? "signature" : "reason"}:`, u || l].join(`
`) : `The contract function "${r}" reverted.`, {
          cause: s,
          metaMessages: o
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ContractFunctionRevertedError"
      }),
      Object.defineProperty(this, "data", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "reason", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "signature", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      this.data = a,
      this.reason = u,
      this.signature = l
  }
}
class h3 extends V {
  constructor({functionName: t}) {
      super(`The contract function "${t}" returned no data ("0x").`, {
          metaMessages: ["This could be due to any of the following:", `  - The contract does not have the function "${t}",`, "  - The parameters passed to the contract function may be invalid, or", "  - The address is not a contract."]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ContractFunctionZeroDataError"
      })
  }
}
class Wm extends V {
  constructor({data: t, message: n}) {
      super(n || ""),
      Object.defineProperty(this, "code", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: 3
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "RawContractError"
      }),
      Object.defineProperty(this, "data", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      this.data = t
  }
}
class da extends V {
  constructor({body: t, details: n, headers: r, status: i, url: s}) {
      super("HTTP request failed.", {
          details: n,
          metaMessages: [i && `Status: ${i}`, `URL: ${yc(s)}`, t && `Request body: ${Et(t)}`].filter(Boolean)
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "HttpRequestError"
      }),
      Object.defineProperty(this, "body", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "headers", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "status", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "url", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      this.body = t,
      this.headers = r,
      this.status = i,
      this.url = s
  }
}
class m3 extends V {
  constructor({body: t, details: n, url: r}) {
      super("WebSocket request failed.", {
          details: n,
          metaMessages: [`URL: ${yc(r)}`, `Request body: ${Et(t)}`]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "WebSocketRequestError"
      })
  }
}
class Hm extends V {
  constructor({body: t, error: n, url: r}) {
      super("RPC Request failed.", {
          cause: n,
          details: n.message,
          metaMessages: [`URL: ${yc(r)}`, `Request body: ${Et(t)}`]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "RpcRequestError"
      }),
      Object.defineProperty(this, "code", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      this.code = n.code
  }
}
class $p extends V {
  constructor({body: t, url: n}) {
      super("The request took too long to respond.", {
          details: "The request timed out.",
          metaMessages: [`URL: ${yc(n)}`, `Request body: ${Et(t)}`]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "TimeoutError"
      })
  }
}
const y3 = -1;
class $t extends V {
  constructor(t, {code: n, docsPath: r, metaMessages: i, shortMessage: s}) {
      super(s, {
          cause: t,
          docsPath: r,
          metaMessages: i || (t == null ? void 0 : t.metaMessages)
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "RpcError"
      }),
      Object.defineProperty(this, "code", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      this.name = t.name,
      this.code = t instanceof Hm ? t.code : n ?? y3
  }
}
class Ss extends $t {
  constructor(t, n) {
      super(t, n),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ProviderRpcError"
      }),
      Object.defineProperty(this, "data", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      this.data = n.data
  }
}
class Na extends $t {
  constructor(t) {
      super(t, {
          code: Na.code,
          shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ParseRpcError"
      })
  }
}
Object.defineProperty(Na, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class ja extends $t {
  constructor(t) {
      super(t, {
          code: ja.code,
          shortMessage: "JSON is not a valid request object."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InvalidRequestRpcError"
      })
  }
}
Object.defineProperty(ja, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class Ma extends $t {
  constructor(t) {
      super(t, {
          code: Ma.code,
          shortMessage: "The method does not exist / is not available."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "MethodNotFoundRpcError"
      })
  }
}
Object.defineProperty(Ma, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class La extends $t {
  constructor(t) {
      super(t, {
          code: La.code,
          shortMessage: ["Invalid parameters were provided to the RPC method.", "Double check you have provided the correct parameters."].join(`
`)
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InvalidParamsRpcError"
      })
  }
}
Object.defineProperty(La, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class ds extends $t {
  constructor(t) {
      super(t, {
          code: ds.code,
          shortMessage: "An internal error was received."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InternalRpcError"
      })
  }
}
Object.defineProperty(ds, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class yi extends $t {
  constructor(t) {
      super(t, {
          code: yi.code,
          shortMessage: ["Missing or invalid parameters.", "Double check you have provided the correct parameters."].join(`
`)
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "InvalidInputRpcError"
      })
  }
}
Object.defineProperty(yi, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class Fa extends $t {
  constructor(t) {
      super(t, {
          code: Fa.code,
          shortMessage: "Requested resource not found."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ResourceNotFoundRpcError"
      })
  }
}
Object.defineProperty(Fa, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class ps extends $t {
  constructor(t) {
      super(t, {
          code: ps.code,
          shortMessage: "Requested resource not available."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ResourceUnavailableRpcError"
      })
  }
}
Object.defineProperty(ps, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class Ua extends $t {
  constructor(t) {
      super(t, {
          code: Ua.code,
          shortMessage: "Transaction creation failed."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "TransactionRejectedRpcError"
      })
  }
}
Object.defineProperty(Ua, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class za extends $t {
  constructor(t) {
      super(t, {
          code: za.code,
          shortMessage: "Method is not implemented."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "MethodNotSupportedRpcError"
      })
  }
}
Object.defineProperty(za, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class Ba extends $t {
  constructor(t) {
      super(t, {
          code: Ba.code,
          shortMessage: "Request exceeds defined limit."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "LimitExceededRpcError"
      })
  }
}
Object.defineProperty(Ba, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class Wa extends $t {
  constructor(t) {
      super(t, {
          code: Wa.code,
          shortMessage: "Version of JSON-RPC protocol is not supported."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "JsonRpcVersionUnsupportedError"
      })
  }
}
Object.defineProperty(Wa, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class Jt extends Ss {
  constructor(t) {
      super(t, {
          code: Jt.code,
          shortMessage: "User rejected the request."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "UserRejectedRequestError"
      })
  }
}
Object.defineProperty(Jt, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class Ha extends Ss {
  constructor(t) {
      super(t, {
          code: Ha.code,
          shortMessage: "The requested method and/or account has not been authorized by the user."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "UnauthorizedProviderError"
      })
  }
}
Object.defineProperty(Ha, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class qa extends Ss {
  constructor(t) {
      super(t, {
          code: qa.code,
          shortMessage: "The Provider does not support the requested method."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "UnsupportedProviderMethodError"
      })
  }
}
Object.defineProperty(qa, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class Va extends Ss {
  constructor(t) {
      super(t, {
          code: Va.code,
          shortMessage: "The Provider is disconnected from all chains."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ProviderDisconnectedError"
      })
  }
}
Object.defineProperty(Va, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class Ka extends Ss {
  constructor(t) {
      super(t, {
          code: Ka.code,
          shortMessage: "The Provider is not connected to the requested chain."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "ChainDisconnectedError"
      })
  }
}
Object.defineProperty(Ka, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class Nr extends Ss {
  constructor(t) {
      super(t, {
          code: Nr.code,
          shortMessage: "An error occurred when attempting to switch chain."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "SwitchChainError"
      })
  }
}
Object.defineProperty(Nr, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class g3 extends $t {
  constructor(t) {
      super(t, {
          shortMessage: "An unknown RPC error occurred."
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "UnknownRpcError"
      })
  }
}
const v3 = 3;
function Ga(e, {abi: t, address: n, args: r, docsPath: i, functionName: s, sender: a}) {
  const {code: o, data: u, message: l, shortMessage: c} = e instanceof Wm ? e : e instanceof V ? e.walk(d => "data"in d) || e.walk() : {}
    , f = e instanceof xc ? new h3({
      functionName: s
  }) : [v3, ds.code].includes(o) && (u || l || c) ? new Ap({
      abi: t,
      data: typeof u == "object" ? u.data : u,
      functionName: s,
      message: c ?? l
  }) : e;
  return new Bm(f,{
      abi: t,
      args: r,
      contractAddress: n,
      docsPath: i,
      functionName: s,
      sender: a
  })
}
class Cs extends V {
  constructor({docsPath: t}={}) {
      super(["Could not find an Account to execute with this Action.", "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."].join(`
`), {
          docsPath: t,
          docsSlug: "account"
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "AccountNotFoundError"
      })
  }
}
class w3 extends V {
  constructor(t, {account: n, docsPath: r, chain: i, data: s, gas: a, gasPrice: o, maxFeePerGas: u, maxPriorityFeePerGas: l, nonce: c, to: f, value: d}) {
      var m;
      const y = go({
          from: n == null ? void 0 : n.address,
          to: f,
          value: typeof d < "u" && `${zm(d)} ${((m = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : m.symbol) || "ETH"}`,
          data: s,
          gas: a,
          gasPrice: typeof o < "u" && `${It(o)} gwei`,
          maxFeePerGas: typeof u < "u" && `${It(u)} gwei`,
          maxPriorityFeePerGas: typeof l < "u" && `${It(l)} gwei`,
          nonce: c
      });
      super(t.shortMessage, {
          cause: t,
          docsPath: r,
          metaMessages: [...t.metaMessages ? [...t.metaMessages, " "] : [], "Estimate Gas Arguments:", y].filter(Boolean)
      }),
      Object.defineProperty(this, "cause", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "EstimateGasExecutionError"
      }),
      this.cause = t
  }
}
function qm(e, t) {
  const n = (e.details || "").toLowerCase()
    , r = e.walk(i => i.code === Vi.code);
  return r instanceof V ? new Vi({
      cause: e,
      message: r.details
  }) : Vi.nodeMessage.test(n) ? new Vi({
      cause: e,
      message: e.details
  }) : Sl.nodeMessage.test(n) ? new Sl({
      cause: e,
      maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : Ep.nodeMessage.test(n) ? new Ep({
      cause: e,
      maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : Sp.nodeMessage.test(n) ? new Sp({
      cause: e,
      nonce: t == null ? void 0 : t.nonce
  }) : Cp.nodeMessage.test(n) ? new Cp({
      cause: e,
      nonce: t == null ? void 0 : t.nonce
  }) : _p.nodeMessage.test(n) ? new _p({
      cause: e,
      nonce: t == null ? void 0 : t.nonce
  }) : Pp.nodeMessage.test(n) ? new Pp({
      cause: e
  }) : Tp.nodeMessage.test(n) ? new Tp({
      cause: e,
      gas: t == null ? void 0 : t.gas
  }) : Op.nodeMessage.test(n) ? new Op({
      cause: e,
      gas: t == null ? void 0 : t.gas
  }) : kp.nodeMessage.test(n) ? new kp({
      cause: e
  }) : Cl.nodeMessage.test(n) ? new Cl({
      cause: e,
      maxFeePerGas: t == null ? void 0 : t.maxFeePerGas,
      maxPriorityFeePerGas: t == null ? void 0 : t.maxPriorityFeePerGas
  }) : new wc({
      cause: e
  })
}
function b3(e, {docsPath: t, ...n}) {
  const r = ( () => {
      const i = qm(e, n);
      return i instanceof wc ? e : i
  }
  )();
  return new w3(r,{
      docsPath: t,
      ...n
  })
}
function Vm(e, {format: t}) {
  if (!t)
      return {};
  const n = {};
  function r(s) {
      const a = Object.keys(s);
      for (const o of a)
          o in e && (n[o] = e[o]),
          s[o] && typeof s[o] == "object" && !Array.isArray(s[o]) && r(s[o])
  }
  const i = t(e || {});
  return r(i),
  n
}
function vo(e) {
  const {account: t, gasPrice: n, maxFeePerGas: r, maxPriorityFeePerGas: i, to: s} = e
    , a = t ? rn(t) : void 0;
  if (a && !Rr(a.address))
      throw new Ra({
          address: a.address
      });
  if (s && !Rr(s))
      throw new Ra({
          address: s
      });
  if (typeof n < "u" && (typeof r < "u" || typeof i < "u"))
      throw new c3;
  if (r && r > 2n ** 256n - 1n)
      throw new Sl({
          maxFeePerGas: r
      });
  if (i && r && i > r)
      throw new Cl({
          maxFeePerGas: r,
          maxPriorityFeePerGas: i
      })
}
class x3 extends V {
  constructor() {
      super("`baseFeeMultiplier` must be greater than 1."),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "BaseFeeScalarError"
      })
  }
}
class Km extends V {
  constructor() {
      super("Chain does not support EIP-1559 fees."),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "Eip1559FeesNotSupportedError"
      })
  }
}
class E3 extends V {
  constructor({maxPriorityFeePerGas: t}) {
      super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${It(t)} gwei).`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "MaxFeePerGasTooLowError"
      })
  }
}
class ux extends V {
  constructor({blockHash: t, blockNumber: n}) {
      let r = "Block";
      t && (r = `Block at hash "${t}"`),
      n && (r = `Block at number "${n}"`),
      super(`${r} could not be found.`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "BlockNotFoundError"
      })
  }
}
async function jr(e, {blockHash: t, blockNumber: n, blockTag: r, includeTransactions: i}={}) {
  var c, f, d;
  const s = r ?? "latest"
    , a = i ?? !1
    , o = n !== void 0 ? ie(n) : void 0;
  let u = null;
  if (t ? u = await e.request({
      method: "eth_getBlockByHash",
      params: [t, a]
  }) : u = await e.request({
      method: "eth_getBlockByNumber",
      params: [o || s, a]
  }),
  !u)
      throw new ux({
          blockHash: t,
          blockNumber: n
      });
  return (((d = (f = (c = e.chain) == null ? void 0 : c.formatters) == null ? void 0 : f.block) == null ? void 0 : d.format) || H2)(u)
}
async function Gm(e) {
  const t = await e.request({
      method: "eth_gasPrice"
  });
  return BigInt(t)
}
async function S3(e, t) {
  return lx(e, t)
}
async function lx(e, t) {
  var s, a, o;
  const {block: n, chain: r=e.chain, request: i} = t || {};
  if (typeof ((s = r == null ? void 0 : r.fees) == null ? void 0 : s.defaultPriorityFee) == "function") {
      const u = n || await ne(e, jr, "getBlock")({});
      return r.fees.defaultPriorityFee({
          block: u,
          client: e,
          request: i
      })
  }
  if (typeof ((a = r == null ? void 0 : r.fees) == null ? void 0 : a.defaultPriorityFee) < "u")
      return (o = r == null ? void 0 : r.fees) == null ? void 0 : o.defaultPriorityFee;
  try {
      const u = await e.request({
          method: "eth_maxPriorityFeePerGas"
      });
      return gc(u)
  } catch {
      const [u,l] = await Promise.all([n ? Promise.resolve(n) : ne(e, jr, "getBlock")({}), ne(e, Gm, "getGasPrice")({})]);
      if (typeof u.baseFeePerGas != "bigint")
          throw new Km;
      const c = l - u.baseFeePerGas;
      return c < 0n ? 0n : c
  }
}
async function C3(e, t) {
  return Rp(e, t)
}
async function Rp(e, t) {
  var d, y;
  const {block: n, chain: r=e.chain, request: i, type: s="eip1559"} = t || {}
    , a = await (async () => {
      var m, v;
      return typeof ((m = r == null ? void 0 : r.fees) == null ? void 0 : m.baseFeeMultiplier) == "function" ? r.fees.baseFeeMultiplier({
          block: n,
          client: e,
          request: i
      }) : ((v = r == null ? void 0 : r.fees) == null ? void 0 : v.baseFeeMultiplier) ?? 1.2
  }
  )();
  if (a < 1)
      throw new x3;
  const u = 10 ** (((d = a.toString().split(".")[1]) == null ? void 0 : d.length) ?? 0)
    , l = m => m * BigInt(Math.ceil(a * u)) / BigInt(u)
    , c = n || await ne(e, jr, "getBlock")({});
  if (typeof ((y = r == null ? void 0 : r.fees) == null ? void 0 : y.estimateFeesPerGas) == "function")
      return r.fees.estimateFeesPerGas({
          block: n,
          client: e,
          multiply: l,
          request: i,
          type: s
      });
  if (s === "eip1559") {
      if (typeof c.baseFeePerGas != "bigint")
          throw new Km;
      const m = i != null && i.maxPriorityFeePerGas ? i.maxPriorityFeePerGas : await lx(e, {
          block: c,
          chain: r,
          request: i
      })
        , v = l(c.baseFeePerGas);
      return {
          maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? v + m,
          maxPriorityFeePerGas: m
      }
  }
  return {
      gasPrice: (i == null ? void 0 : i.gasPrice) ?? l(await ne(e, Gm, "getGasPrice")({}))
  }
}
async function cx(e, {address: t, blockTag: n="latest", blockNumber: r}) {
  const i = await e.request({
      method: "eth_getTransactionCount",
      params: [t, r ? ie(r) : n]
  });
  return yt(i)
}
function _3(e) {
  if (e.type)
      return e.type;
  if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
      return "eip1559";
  if (typeof e.gasPrice < "u")
      return typeof e.accessList < "u" ? "eip2930" : "legacy";
  throw new f3({
      transaction: e
  })
}
async function _c(e, t) {
  const {account: n=e.account, chain: r, gas: i, nonce: s, type: a} = t;
  if (!n)
      throw new Cs;
  const o = rn(n)
    , u = await ne(e, jr, "getBlock")({
      blockTag: "latest"
  })
    , l = {
      ...t,
      from: o.address
  };
  if (typeof s > "u" && (l.nonce = await ne(e, cx, "getTransactionCount")({
      address: o.address,
      blockTag: "pending"
  })),
  typeof a > "u")
      try {
          l.type = _3(l)
      } catch {
          l.type = typeof u.baseFeePerGas == "bigint" ? "eip1559" : "legacy"
      }
  if (l.type === "eip1559") {
      const {maxFeePerGas: c, maxPriorityFeePerGas: f} = await Rp(e, {
          block: u,
          chain: r,
          request: l
      });
      if (typeof t.maxPriorityFeePerGas > "u" && t.maxFeePerGas && t.maxFeePerGas < f)
          throw new E3({
              maxPriorityFeePerGas: f
          });
      l.maxPriorityFeePerGas = f,
      l.maxFeePerGas = c
  } else {
      if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
          throw new Km;
      const {gasPrice: c} = await Rp(e, {
          block: u,
          chain: r,
          request: l,
          type: "legacy"
      });
      l.gasPrice = c
  }
  return typeof i > "u" && (l.gas = await ne(e, Qm, "estimateGas")({
      ...l,
      account: {
          address: o.address,
          type: "json-rpc"
      }
  })),
  vo(l),
  l
}
async function Qm(e, t) {
  var i, s, a;
  const n = t.account ?? e.account;
  if (!n)
      throw new Cs({
          docsPath: "/docs/actions/public/estimateGas"
      });
  const r = rn(n);
  try {
      const {accessList: o, blockNumber: u, blockTag: l, data: c, gas: f, gasPrice: d, maxFeePerGas: y, maxPriorityFeePerGas: m, nonce: v, to: b, value: w, ...h} = r.type === "local" ? await _c(e, t) : t
        , x = (u ? ie(u) : void 0) || l;
      vo(t);
      const S = (a = (s = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionRequest) == null ? void 0 : a.format
        , p = (S || vc)({
          ...Vm(h, {
              format: S
          }),
          from: r.address,
          accessList: o,
          data: c,
          gas: f,
          gasPrice: d,
          maxFeePerGas: y,
          maxPriorityFeePerGas: m,
          nonce: v,
          to: b,
          value: w
      })
        , C = await e.request({
          method: "eth_estimateGas",
          params: x ? [p, x] : [p]
      });
      return BigInt(C)
  } catch (o) {
      throw b3(o, {
          ...t,
          account: r,
          chain: e.chain
      })
  }
}
async function P3(e, {abi: t, address: n, args: r, functionName: i, ...s}) {
  const a = Br({
      abi: t,
      args: r,
      functionName: i
  });
  try {
      return await ne(e, Qm, "estimateGas")({
          data: a,
          to: n,
          ...s
      })
  } catch (o) {
      const u = s.account ? rn(s.account) : void 0;
      throw Ga(o, {
          abi: t,
          address: n,
          args: r,
          docsPath: "/docs/contract/estimateContractGas",
          functionName: i,
          sender: u == null ? void 0 : u.address
      })
  }
}
const T0 = "/docs/contract/decodeEventLog";
function wo({abi: e, data: t, strict: n, topics: r}) {
  const i = n ?? !0
    , [s,...a] = r;
  if (!s)
      throw new aP({
          docsPath: T0
      });
  const o = e.find(m => m.type === "event" && s === jm(Qn(m)));
  if (!(o && "name"in o) || o.type !== "event")
      throw new oP(s,{
          docsPath: T0
      });
  const {name: u, inputs: l} = o
    , c = l == null ? void 0 : l.some(m => !("name"in m && m.name));
  let f = c ? [] : {};
  const d = l.filter(m => "indexed"in m && m.indexed);
  for (let m = 0; m < d.length; m++) {
      const v = d[m]
        , b = a[m];
      if (!b)
          throw new Es({
              abiItem: o,
              param: v
          });
      f[v.name || m] = T3({
          param: v,
          value: b
      })
  }
  const y = l.filter(m => !("indexed"in m && m.indexed));
  if (y.length > 0) {
      if (t && t !== "0x")
          try {
              const m = Cc(y, t);
              if (m)
                  if (c)
                      f = [...f, ...m];
                  else
                      for (let v = 0; v < y.length; v++)
                          f[y[v].name] = m[v]
          } catch (m) {
              if (i)
                  throw m instanceof Rm ? new mi({
                      abiItem: o,
                      data: m.data,
                      params: m.params,
                      size: m.size
                  }) : m
          }
      else if (i)
          throw new mi({
              abiItem: o,
              data: "0x",
              params: y,
              size: 0
          })
  }
  return {
      eventName: u,
      args: Object.values(f).length > 0 ? f : void 0
  }
}
function T3({param: e, value: t}) {
  return e.type === "string" || e.type === "bytes" || e.type === "tuple" || e.type.match(/^(.*)\[(\d+)?\]$/) ? t : (Cc([e], t) || [])[0]
}
async function Ym(e, {address: t, blockHash: n, fromBlock: r, toBlock: i, event: s, events: a, args: o, strict: u}={}) {
  const l = u ?? !1
    , c = a ?? (s ? [s] : void 0);
  let f = [];
  c && (f = [c.flatMap(y => yo({
      abi: [y],
      eventName: y.name,
      args: o
  }))],
  s && (f = f[0]));
  let d;
  return n ? d = await e.request({
      method: "eth_getLogs",
      params: [{
          address: t,
          topics: f,
          blockHash: n
      }]
  }) : d = await e.request({
      method: "eth_getLogs",
      params: [{
          address: t,
          topics: f,
          fromBlock: typeof r == "bigint" ? ie(r) : r,
          toBlock: typeof i == "bigint" ? ie(i) : i
      }]
  }),
  d.map(y => {
      var m;
      try {
          const {eventName: v, args: b} = c ? wo({
              abi: c,
              data: y.data,
              topics: y.topics,
              strict: l
          }) : {
              eventName: void 0,
              args: void 0
          };
          return mn(y, {
              args: b,
              eventName: v
          })
      } catch (v) {
          let b, w;
          if (v instanceof mi || v instanceof Es) {
              if (l)
                  return;
              b = v.abiItem.name,
              w = (m = v.abiItem.inputs) == null ? void 0 : m.some(h => !("name"in h && h.name))
          }
          return mn(y, {
              args: w ? [] : {},
              eventName: b
          })
      }
  }
  ).filter(Boolean)
}
async function fx(e, {abi: t, address: n, args: r, blockHash: i, eventName: s, fromBlock: a, toBlock: o, strict: u}) {
  const l = s ? mo({
      abi: t,
      name: s
  }) : void 0
    , c = l ? void 0 : t.filter(f => f.type === "event");
  return ne(e, Ym, "getLogs")({
      address: n,
      args: r,
      blockHash: i,
      event: l,
      events: c,
      fromBlock: a,
      toBlock: o,
      strict: u
  })
}
const Vf = "/docs/contract/decodeFunctionResult";
function _s({abi: e, args: t, functionName: n, data: r}) {
  let i = e[0];
  if (n && (i = mo({
      abi: e,
      args: t,
      name: n
  }),
  !i))
      throw new _l(n,{
          docsPath: Vf
      });
  if (i.type !== "function")
      throw new _l(void 0,{
          docsPath: Vf
      });
  if (!i.outputs)
      throw new uP(i.name,{
          docsPath: Vf
      });
  const s = Cc(i.outputs, r);
  if (s && s.length > 1)
      return s;
  if (s && s.length === 1)
      return s[0]
}
const O3 = "modulepreload"
, k3 = function(e) {
  return "/" + e
}
, O0 = {}
, sn = function(t, n, r) {
  let i = Promise.resolve();
  if (n && n.length > 0) {
      const s = document.getElementsByTagName("link");
      i = Promise.all(n.map(a => {
          if (a = k3(a),
          a in O0)
              return;
          O0[a] = !0;
          const o = a.endsWith(".css")
            , u = o ? '[rel="stylesheet"]' : "";
          if (!!r)
              for (let f = s.length - 1; f >= 0; f--) {
                  const d = s[f];
                  if (d.href === a && (!o || d.rel === "stylesheet"))
                      return
              }
          else if (document.querySelector(`link[href="${a}"]${u}`))
              return;
          const c = document.createElement("link");
          if (c.rel = o ? "stylesheet" : O3,
          o || (c.as = "script",
          c.crossOrigin = ""),
          c.href = a,
          document.head.appendChild(c),
          o)
              return new Promise( (f, d) => {
                  c.addEventListener("load", f),
                  c.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${a}`)))
              }
              )
      }
      ))
  }
  return i.then( () => t()).catch(s => {
      const a = new Event("vite:preloadError",{
          cancelable: !0
      });
      if (a.payload = s,
      window.dispatchEvent(a),
      !a.defaultPrevented)
          throw s
  }
  )
}
, Np = [{
  inputs: [{
      components: [{
          name: "target",
          type: "address"
      }, {
          name: "allowFailure",
          type: "bool"
      }, {
          name: "callData",
          type: "bytes"
      }],
      name: "calls",
      type: "tuple[]"
  }],
  name: "aggregate3",
  outputs: [{
      components: [{
          name: "success",
          type: "bool"
      }, {
          name: "returnData",
          type: "bytes"
      }],
      name: "returnData",
      type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}]
, dx = [{
  inputs: [],
  name: "ResolverNotFound",
  type: "error"
}, {
  inputs: [],
  name: "ResolverWildcardNotSupported",
  type: "error"
}]
, px = [...dx, {
  name: "resolve",
  type: "function",
  stateMutability: "view",
  inputs: [{
      name: "name",
      type: "bytes"
  }, {
      name: "data",
      type: "bytes"
  }],
  outputs: [{
      name: "",
      type: "bytes"
  }, {
      name: "address",
      type: "address"
  }]
}]
, D3 = [...dx, {
  name: "reverse",
  type: "function",
  stateMutability: "view",
  inputs: [{
      type: "bytes",
      name: "reverseName"
  }],
  outputs: [{
      type: "string",
      name: "resolvedName"
  }, {
      type: "address",
      name: "resolvedAddress"
  }, {
      type: "address",
      name: "reverseResolver"
  }, {
      type: "address",
      name: "resolver"
  }]
}]
, k0 = [{
  name: "text",
  type: "function",
  stateMutability: "view",
  inputs: [{
      name: "name",
      type: "bytes32"
  }, {
      name: "key",
      type: "string"
  }],
  outputs: [{
      name: "",
      type: "string"
  }]
}]
, D0 = [{
  name: "addr",
  type: "function",
  stateMutability: "view",
  inputs: [{
      name: "name",
      type: "bytes32"
  }],
  outputs: [{
      name: "",
      type: "address"
  }]
}, {
  name: "addr",
  type: "function",
  stateMutability: "view",
  inputs: [{
      name: "name",
      type: "bytes32"
  }, {
      name: "coinType",
      type: "uint256"
  }],
  outputs: [{
      name: "",
      type: "bytes"
  }]
}]
, I3 = [{
  inputs: [{
      internalType: "address",
      name: "_signer",
      type: "address"
  }, {
      internalType: "bytes32",
      name: "_hash",
      type: "bytes32"
  }, {
      internalType: "bytes",
      name: "_signature",
      type: "bytes"
  }],
  stateMutability: "nonpayable",
  type: "constructor"
}]
, A3 = "0x82ad56cb";
function Ps({blockNumber: e, chain: t, contract: n}) {
  var i;
  const r = (i = t == null ? void 0 : t.contracts) == null ? void 0 : i[n];
  if (!r)
      throw new xp({
          chain: t,
          contract: {
              name: n
          }
      });
  if (e && r.blockCreated && r.blockCreated > e)
      throw new xp({
          blockNumber: e,
          chain: t,
          contract: {
              name: n,
              blockCreated: r.blockCreated
          }
      });
  return r.address
}
function $3(e, {docsPath: t, ...n}) {
  const r = ( () => {
      const i = qm(e, n);
      return i instanceof wc ? e : i
  }
  )();
  return new ox(r,{
      docsPath: t,
      ...n
  })
}
const Kf = new Map;
function Xm({fn: e, id: t, shouldSplitBatch: n, wait: r=0, sort: i}) {
  const s = async () => {
      const c = u();
      a();
      const f = c.map( ({args: d}) => d);
      f.length !== 0 && e(f).then(d => {
          var y;
          i && Array.isArray(d) && d.sort(i);
          for (let m = 0; m < c.length; m++) {
              const {pendingPromise: v} = c[m];
              (y = v.resolve) == null || y.call(v, [d[m], d])
          }
      }
      ).catch(d => {
          var y;
          for (let m = 0; m < c.length; m++) {
              const {pendingPromise: v} = c[m];
              (y = v.reject) == null || y.call(v, d)
          }
      }
      )
  }
    , a = () => Kf.delete(t)
    , o = () => u().map( ({args: c}) => c)
    , u = () => Kf.get(t) || []
    , l = c => Kf.set(t, [...u(), c]);
  return {
      flush: a,
      async schedule(c) {
          const f = {}
            , d = new Promise( (v, b) => {
              f.resolve = v,
              f.reject = b
          }
          );
          return (n == null ? void 0 : n([...o(), c])) && s(),
          u().length > 0 ? (l({
              args: c,
              pendingPromise: f
          }),
          d) : (l({
              args: c,
              pendingPromise: f
          }),
          setTimeout(s, r),
          d)
      }
  }
}
async function Pc(e, t) {
  var w, h, g, x;
  const {account: n=e.account, batch: r=!!((w = e.batch) != null && w.multicall), blockNumber: i, blockTag: s="latest", accessList: a, data: o, gas: u, gasPrice: l, maxFeePerGas: c, maxPriorityFeePerGas: f, nonce: d, to: y, value: m, ...v} = t
    , b = n ? rn(n) : void 0;
  try {
      vo(t);
      const E = (i ? ie(i) : void 0) || s
        , p = (x = (g = (h = e.chain) == null ? void 0 : h.formatters) == null ? void 0 : g.transactionRequest) == null ? void 0 : x.format
        , T = (p || vc)({
          ...Vm(v, {
              format: p
          }),
          from: b == null ? void 0 : b.address,
          accessList: a,
          data: o,
          gas: u,
          gasPrice: l,
          maxFeePerGas: c,
          maxPriorityFeePerGas: f,
          nonce: d,
          to: y,
          value: m
      });
      if (r && R3({
          request: T
      }))
          try {
              return await N3(e, {
                  ...T,
                  blockNumber: i,
                  blockTag: s
              })
          } catch (R) {
              if (!(R instanceof q2) && !(R instanceof xp))
                  throw R
          }
      const O = await e.request({
          method: "eth_call",
          params: E ? [T, E] : [T]
      });
      return O === "0x" ? {
          data: void 0
      } : {
          data: O
      }
  } catch (S) {
      const E = j3(S)
        , {offchainLookup: p, offchainLookupSignature: C} = await sn( () => import("./ccip-8pT_XD9O.js"), __vite__mapDeps([]));
      if ((E == null ? void 0 : E.slice(0, 10)) === C && y)
          return {
              data: await p(e, {
                  data: E,
                  to: y
              })
          };
      throw $3(S, {
          ...t,
          account: b,
          chain: e.chain
      })
  }
}
function R3({request: e}) {
  const {data: t, to: n, ...r} = e;
  return !(!t || t.startsWith(A3) || !n || Object.values(r).filter(i => typeof i < "u").length > 0)
}
async function N3(e, t) {
  var v;
  const {batchSize: n=1024, wait: r=0} = typeof ((v = e.batch) == null ? void 0 : v.multicall) == "object" ? e.batch.multicall : {}
    , {blockNumber: i, blockTag: s="latest", data: a, multicallAddress: o, to: u} = t;
  let l = o;
  if (!l) {
      if (!e.chain)
          throw new q2;
      l = Ps({
          blockNumber: i,
          chain: e.chain,
          contract: "multicall3"
      })
  }
  const f = (i ? ie(i) : void 0) || s
    , {schedule: d} = Xm({
      id: `${e.uid}.${f}`,
      wait: r,
      shouldSplitBatch(b) {
          return b.reduce( (h, {data: g}) => h + (g.length - 2), 0) > n * 2
      },
      fn: async b => {
          const w = b.map(x => ({
              allowFailure: !0,
              callData: x.data,
              target: x.to
          }))
            , h = Br({
              abi: Np,
              args: [w],
              functionName: "aggregate3"
          })
            , g = await e.request({
              method: "eth_call",
              params: [{
                  data: h,
                  to: l
              }, f]
          });
          return _s({
              abi: Np,
              args: [w],
              functionName: "aggregate3",
              data: g || "0x"
          })
      }
  })
    , [{returnData: y, success: m}] = await d({
      data: a,
      to: u
  });
  if (!m)
      throw new Wm({
          data: y
      });
  return y === "0x" ? {
      data: void 0
  } : {
      data: y
  }
}
function j3(e) {
  if (!(e instanceof V))
      return;
  const t = e.walk();
  return typeof t.data == "object" ? t.data.data : t.data
}
async function Mr(e, {abi: t, address: n, args: r, functionName: i, ...s}) {
  const a = Br({
      abi: t,
      args: r,
      functionName: i
  });
  try {
      const {data: o} = await ne(e, Pc, "call")({
          data: a,
          to: n,
          ...s
      });
      return _s({
          abi: t,
          args: r,
          functionName: i,
          data: o || "0x"
      })
  } catch (o) {
      throw Ga(o, {
          abi: t,
          address: n,
          args: r,
          docsPath: "/docs/contract/readContract",
          functionName: i
      })
  }
}
async function M3(e, {abi: t, address: n, args: r, dataSuffix: i, functionName: s, ...a}) {
  const o = a.account ? rn(a.account) : void 0
    , u = Br({
      abi: t,
      args: r,
      functionName: s
  });
  try {
      const {data: l} = await ne(e, Pc, "call")({
          batch: !1,
          data: `${u}${i ? i.replace("0x", "") : ""}`,
          to: n,
          ...a
      });
      return {
          result: _s({
              abi: t,
              args: r,
              functionName: s,
              data: l || "0x"
          }),
          request: {
              abi: t,
              address: n,
              args: r,
              dataSuffix: i,
              functionName: s,
              ...a
          }
      }
  } catch (l) {
      throw Ga(l, {
          abi: t,
          address: n,
          args: r,
          docsPath: "/docs/contract/simulateContract",
          functionName: s,
          sender: o == null ? void 0 : o.address
      })
  }
}
const Gf = new Map
, I0 = new Map;
let L3 = 0;
function Ts(e, t, n) {
  const r = ++L3
    , i = () => Gf.get(e) || []
    , s = () => {
      const c = i();
      Gf.set(e, c.filter(f => f.id !== r))
  }
    , a = () => {
      const c = I0.get(e);
      i().length === 1 && c && c(),
      s()
  }
    , o = i();
  if (Gf.set(e, [...o, {
      id: r,
      fns: t
  }]),
  o && o.length > 0)
      return a;
  const u = {};
  for (const c in t)
      u[c] = (...f) => {
          var y, m;
          const d = i();
          if (d.length !== 0)
              for (const v of d)
                  (m = (y = v.fns)[c]) == null || m.call(y, ...f)
      }
      ;
  const l = n(u);
  return typeof l == "function" && I0.set(e, l),
  a
}
async function Tl(e) {
  return new Promise(t => setTimeout(t, e))
}
function bo(e, {emitOnBegin: t, initialWaitTime: n, interval: r}) {
  let i = !0;
  const s = () => i = !1;
  return (async () => {
      let o;
      t && (o = await e({
          unpoll: s
      }));
      const u = await (n == null ? void 0 : n(o)) ?? r;
      await Tl(u);
      const l = async () => {
          i && (await e({
              unpoll: s
          }),
          await Tl(r),
          l())
      }
      ;
      l()
  }
  )(),
  s
}
const F3 = new Map
, U3 = new Map;
function z3(e) {
  const t = (i, s) => ({
      clear: () => s.delete(i),
      get: () => s.get(i),
      set: a => s.set(i, a)
  })
    , n = t(e, F3)
    , r = t(e, U3);
  return {
      clear: () => {
          n.clear(),
          r.clear()
      }
      ,
      promise: n,
      response: r
  }
}
async function B3(e, {cacheKey: t, cacheTime: n=1 / 0}) {
  const r = z3(t)
    , i = r.response.get();
  if (i && n > 0 && new Date().getTime() - i.created.getTime() < n)
      return i.data;
  let s = r.promise.get();
  s || (s = e(),
  r.promise.set(s));
  try {
      const a = await s;
      return r.response.set({
          created: new Date,
          data: a
      }),
      a
  } finally {
      r.promise.clear()
  }
}
const W3 = e => `blockNumber.${e}`;
async function xo(e, {cacheTime: t=e.cacheTime, maxAge: n}={}) {
  const r = await B3( () => e.request({
      method: "eth_blockNumber"
  }), {
      cacheKey: W3(e.uid),
      cacheTime: n ?? t
  });
  return BigInt(r)
}
async function Tc(e, {filter: t}) {
  const n = "strict"in t && t.strict;
  return (await t.request({
      method: "eth_getFilterChanges",
      params: [t.id]
  })).map(i => {
      var s;
      if (typeof i == "string")
          return i;
      try {
          const {eventName: a, args: o} = "abi"in t && t.abi ? wo({
              abi: t.abi,
              data: i.data,
              topics: i.topics,
              strict: n
          }) : {
              eventName: void 0,
              args: void 0
          };
          return mn(i, {
              args: o,
              eventName: a
          })
      } catch (a) {
          let o, u;
          if (a instanceof mi || a instanceof Es) {
              if ("strict"in t && t.strict)
                  return;
              o = a.abiItem.name,
              u = (s = a.abiItem.inputs) == null ? void 0 : s.some(l => !("name"in l && l.name))
          }
          return mn(i, {
              args: u ? [] : {},
              eventName: o
          })
      }
  }
  ).filter(Boolean)
}
async function Oc(e, {filter: t}) {
  return t.request({
      method: "eth_uninstallFilter",
      params: [t.id]
  })
}
function H3(e, {abi: t, address: n, args: r, batch: i=!0, eventName: s, onError: a, onLogs: o, poll: u, pollingInterval: l=e.pollingInterval, strict: c}) {
  return (typeof u < "u" ? u : e.transport.type !== "webSocket") ? ( () => {
      const m = Et(["watchContractEvent", n, r, i, e.uid, s, l])
        , v = c ?? !1;
      return Ts(m, {
          onLogs: o,
          onError: a
      }, b => {
          let w, h, g = !1;
          const x = bo(async () => {
              var S;
              if (!g) {
                  try {
                      h = await ne(e, nx, "createContractEventFilter")({
                          abi: t,
                          address: n,
                          args: r,
                          eventName: s,
                          strict: v
                      })
                  } catch {}
                  g = !0;
                  return
              }
              try {
                  let E;
                  if (h)
                      E = await ne(e, Tc, "getFilterChanges")({
                          filter: h
                      });
                  else {
                      const p = await ne(e, xo, "getBlockNumber")({});
                      w && w !== p ? E = await ne(e, fx, "getContractEvents")({
                          abi: t,
                          address: n,
                          args: r,
                          eventName: s,
                          fromBlock: w + 1n,
                          toBlock: p,
                          strict: v
                      }) : E = [],
                      w = p
                  }
                  if (E.length === 0)
                      return;
                  if (i)
                      b.onLogs(E);
                  else
                      for (const p of E)
                          b.onLogs([p])
              } catch (E) {
                  h && E instanceof yi && (g = !1),
                  (S = b.onError) == null || S.call(b, E)
              }
          }
          , {
              emitOnBegin: !0,
              interval: l
          });
          return async () => {
              h && await ne(e, Oc, "uninstallFilter")({
                  filter: h
              }),
              x()
          }
      }
      )
  }
  )() : ( () => {
      let m = !0
        , v = () => m = !1;
      return (async () => {
          try {
              const b = s ? yo({
                  abi: t,
                  eventName: s,
                  args: r
              }) : []
                , {unsubscribe: w} = await e.transport.subscribe({
                  params: ["logs", {
                      address: n,
                      topics: b
                  }],
                  onData(h) {
                      var x;
                      if (!m)
                          return;
                      const g = h.result;
                      try {
                          const {eventName: S, args: E} = wo({
                              abi: t,
                              data: g.data,
                              topics: g.topics,
                              strict: c
                          })
                            , p = mn(g, {
                              args: E,
                              eventName: S
                          });
                          o([p])
                      } catch (S) {
                          let E, p;
                          if (S instanceof mi || S instanceof Es) {
                              if (c)
                                  return;
                              E = S.abiItem.name,
                              p = (x = S.abiItem.inputs) == null ? void 0 : x.some(T => !("name"in T && T.name))
                          }
                          const C = mn(g, {
                              args: p ? [] : {},
                              eventName: E
                          });
                          o([C])
                      }
                  },
                  onError(h) {
                      a == null || a(h)
                  }
              });
              v = w,
              m || v()
          } catch (b) {
              a == null || a(b)
          }
      }
      )(),
      v
  }
  )()
}
function hx({chain: e, currentChainId: t}) {
  if (!e)
      throw new K_;
  if (t !== e.id)
      throw new V_({
          chain: e,
          currentChainId: t
      })
}
function q3(e, {docsPath: t, ...n}) {
  const r = ( () => {
      const i = qm(e, n);
      return i instanceof wc ? e : i
  }
  )();
  return new d3(r,{
      docsPath: t,
      ...n
  })
}
async function Qa(e) {
  const t = await e.request({
      method: "eth_chainId"
  });
  return yt(t)
}
async function Jm(e, {serializedTransaction: t}) {
  return e.request({
      method: "eth_sendRawTransaction",
      params: [t]
  })
}
async function Zm(e, t) {
  var v, b, w, h;
  const {account: n=e.account, chain: r=e.chain, accessList: i, data: s, gas: a, gasPrice: o, maxFeePerGas: u, maxPriorityFeePerGas: l, nonce: c, to: f, value: d, ...y} = t;
  if (!n)
      throw new Cs({
          docsPath: "/docs/actions/wallet/sendTransaction"
      });
  const m = rn(n);
  try {
      vo(t);
      let g;
      if (r !== null && (g = await ne(e, Qa, "getChainId")({}),
      hx({
          currentChainId: g,
          chain: r
      })),
      m.type === "local") {
          const p = await ne(e, _c, "prepareTransactionRequest")({
              account: m,
              accessList: i,
              chain: r,
              data: s,
              gas: a,
              gasPrice: o,
              maxFeePerGas: u,
              maxPriorityFeePerGas: l,
              nonce: c,
              to: f,
              value: d,
              ...y
          });
          g || (g = await ne(e, Qa, "getChainId")({}));
          const C = (v = r == null ? void 0 : r.serializers) == null ? void 0 : v.transaction
            , T = await m.signTransaction({
              ...p,
              chainId: g
          }, {
              serializer: C
          });
          return await ne(e, Jm, "sendRawTransaction")({
              serializedTransaction: T
          })
      }
      const x = (h = (w = (b = e.chain) == null ? void 0 : b.formatters) == null ? void 0 : w.transactionRequest) == null ? void 0 : h.format
        , E = (x || vc)({
          ...Vm(y, {
              format: x
          }),
          accessList: i,
          data: s,
          from: m.address,
          gas: a,
          gasPrice: o,
          maxFeePerGas: u,
          maxPriorityFeePerGas: l,
          nonce: c,
          to: f,
          value: d
      });
      return await e.request({
          method: "eth_sendTransaction",
          params: [E]
      })
  } catch (g) {
      throw q3(g, {
          ...t,
          account: m,
          chain: t.chain || void 0
      })
  }
}
async function V3(e, {abi: t, address: n, args: r, dataSuffix: i, functionName: s, ...a}) {
  const o = Br({
      abi: t,
      args: r,
      functionName: s
  });
  return await ne(e, Zm, "sendTransaction")({
      data: `${o}${i ? i.replace("0x", "") : ""}`,
      to: n,
      ...a
  })
}
async function K3(e, {chain: t}) {
  const {id: n, name: r, nativeCurrency: i, rpcUrls: s, blockExplorers: a} = t;
  await e.request({
      method: "wallet_addEthereumChain",
      params: [{
          chainId: ie(n),
          chainName: r,
          nativeCurrency: i,
          rpcUrls: s.default.http,
          blockExplorerUrls: a ? Object.values(a).map( ({url: o}) => o) : void 0
      }]
  })
}
const jp = 256;
let iu = jp, su;
function G3(e=11) {
  if (!su || iu + e > jp * 2) {
      su = "",
      iu = 0;
      for (let t = 0; t < jp; t++)
          su += (256 + Math.random() * 256 | 0).toString(16).substring(1)
  }
  return su.substring(iu, iu++ + e)
}
function mx(e) {
  const {batch: t, cacheTime: n=e.pollingInterval ?? 4e3, key: r="base", name: i="Base Client", pollingInterval: s=4e3, type: a="base"} = e
    , o = e.chain
    , u = e.account ? rn(e.account) : void 0
    , {config: l, request: c, value: f} = e.transport({
      chain: o,
      pollingInterval: s
  })
    , d = {
      ...l,
      ...f
  }
    , y = {
      account: u,
      batch: t,
      cacheTime: n,
      chain: o,
      key: r,
      name: i,
      pollingInterval: s,
      request: c,
      transport: d,
      type: a,
      uid: G3()
  };
  function m(v) {
      return b => {
          const w = b(v);
          for (const g in y)
              delete w[g];
          const h = {
              ...v,
              ...w
          };
          return Object.assign(h, {
              extend: m(h)
          })
      }
  }
  return Object.assign(y, {
      extend: m(y)
  })
}
function Mp(e, {delay: t=100, retryCount: n=2, shouldRetry: r= () => !0}={}) {
  return new Promise( (i, s) => {
      const a = async ({count: o=0}={}) => {
          const u = async ({error: l}) => {
              const c = typeof t == "function" ? t({
                  count: o,
                  error: l
              }) : t;
              c && await Tl(c),
              a({
                  count: o + 1
              })
          }
          ;
          try {
              const l = await e();
              i(l)
          } catch (l) {
              if (o < n && await r({
                  count: o,
                  error: l
              }))
                  return u({
                      error: l
                  });
              s(l)
          }
      }
      ;
      a()
  }
  )
}
const yx = e => "code"in e ? e.code !== -1 && e.code !== -32004 && e.code !== -32005 && e.code !== -32042 && e.code !== -32603 : e instanceof da && e.status ? e.status !== 403 && e.status !== 408 && e.status !== 413 && e.status !== 429 && e.status !== 500 && e.status !== 502 && e.status !== 503 && e.status !== 504 : !1;
function Q3(e, {retryDelay: t=150, retryCount: n=3}={}) {
  return async r => Mp(async () => {
      try {
          return await e(r)
      } catch (i) {
          const s = i;
          switch (s.code) {
          case Na.code:
              throw new Na(s);
          case ja.code:
              throw new ja(s);
          case Ma.code:
              throw new Ma(s);
          case La.code:
              throw new La(s);
          case ds.code:
              throw new ds(s);
          case yi.code:
              throw new yi(s);
          case Fa.code:
              throw new Fa(s);
          case ps.code:
              throw new ps(s);
          case Ua.code:
              throw new Ua(s);
          case za.code:
              throw new za(s);
          case Ba.code:
              throw new Ba(s);
          case Wa.code:
              throw new Wa(s);
          case Jt.code:
              throw new Jt(s);
          case Ha.code:
              throw new Ha(s);
          case qa.code:
              throw new qa(s);
          case Va.code:
              throw new Va(s);
          case Ka.code:
              throw new Ka(s);
          case Nr.code:
              throw new Nr(s);
          case 5e3:
              throw new Jt(s);
          default:
              throw i instanceof V ? i : new g3(s)
          }
      }
  }
  , {
      delay: ({count: i, error: s}) => {
          var a;
          if (s && s instanceof da) {
              const o = (a = s == null ? void 0 : s.headers) == null ? void 0 : a.get("Retry-After");
              if (o != null && o.match(/\d/))
                  return parseInt(o) * 1e3
          }
          return ~~(1 << i) * t
      }
      ,
      retryCount: n,
      shouldRetry: ({error: i}) => !yx(i)
  })
}
function kc({key: e, name: t, request: n, retryCount: r=3, retryDelay: i=150, timeout: s, type: a}, o) {
  return {
      config: {
          key: e,
          name: t,
          request: n,
          retryCount: r,
          retryDelay: i,
          timeout: s,
          type: a
      },
      request: Q3(n, {
          retryCount: r,
          retryDelay: i
      }),
      value: o
  }
}
function gx(e, t={}) {
  const {key: n="custom", name: r="Custom Provider", retryDelay: i} = t;
  return ({retryCount: s}) => kc({
      key: n,
      name: r,
      request: e.request.bind(e),
      retryCount: t.retryCount ?? s,
      retryDelay: i,
      type: "custom"
  })
}
function A0(e, t={}) {
  const {key: n="fallback", name: r="Fallback", rank: i=!1, retryCount: s, retryDelay: a} = t;
  return ({chain: o, pollingInterval: u=4e3, timeout: l}) => {
      let c = e
        , f = () => {}
      ;
      const d = kc({
          key: n,
          name: r,
          async request({method: y, params: m}) {
              const v = async (b=0) => {
                  const w = c[b]({
                      chain: o,
                      retryCount: 0,
                      timeout: l
                  });
                  try {
                      const h = await w.request({
                          method: y,
                          params: m
                      });
                      return f({
                          method: y,
                          params: m,
                          response: h,
                          transport: w,
                          status: "success"
                      }),
                      h
                  } catch (h) {
                      if (f({
                          error: h,
                          method: y,
                          params: m,
                          transport: w,
                          status: "error"
                      }),
                      yx(h) || b === c.length - 1)
                          throw h;
                      return v(b + 1)
                  }
              }
              ;
              return v()
          },
          retryCount: s,
          retryDelay: a,
          type: "fallback"
      }, {
          onResponse: y => f = y,
          transports: c.map(y => y({
              chain: o,
              retryCount: 0
          }))
      });
      if (i) {
          const y = typeof i == "object" ? i : {};
          Y3({
              chain: o,
              interval: y.interval ?? u,
              onTransports: m => c = m,
              sampleCount: y.sampleCount,
              timeout: y.timeout,
              transports: c,
              weights: y.weights
          })
      }
      return d
  }
}
function Y3({chain: e, interval: t=4e3, onTransports: n, sampleCount: r=10, timeout: i=1e3, transports: s, weights: a={}}) {
  const {stability: o=.7, latency: u=.3} = a
    , l = []
    , c = async () => {
      const f = await Promise.all(s.map(async m => {
          const v = m({
              chain: e,
              retryCount: 0,
              timeout: i
          })
            , b = Date.now();
          let w, h;
          try {
              await v.request({
                  method: "net_listening"
              }),
              h = 1
          } catch {
              h = 0
          } finally {
              w = Date.now()
          }
          return {
              latency: w - b,
              success: h
          }
      }
      ));
      l.push(f),
      l.length > r && l.shift();
      const d = Math.max(...l.map(m => Math.max(...m.map( ({latency: v}) => v))))
        , y = s.map( (m, v) => {
          const b = l.map(S => S[v].latency)
            , h = 1 - b.reduce( (S, E) => S + E, 0) / b.length / d
            , g = l.map(S => S[v].success)
            , x = g.reduce( (S, E) => S + E, 0) / g.length;
          return x === 0 ? [0, v] : [u * h + o * x, v]
      }
      ).sort( (m, v) => v[0] - m[0]);
      n(y.map( ([,m]) => s[m])),
      await Tl(t),
      c()
  }
  ;
  c()
}
class vx extends V {
  constructor() {
      super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
          docsPath: "/docs/clients/intro"
      })
  }
}
function X3() {
  if (typeof WebSocket < "u")
      return WebSocket;
  if (typeof global.WebSocket < "u")
      return global.WebSocket;
  if (typeof window.WebSocket < "u")
      return window.WebSocket;
  if (typeof self.WebSocket < "u")
      return self.WebSocket;
  throw new Error("`WebSocket` is not supported in this environment")
}
const $0 = X3();
function wx(e, {errorInstance: t=new Error("timed out"), timeout: n, signal: r}) {
  return new Promise( (i, s) => {
      (async () => {
          let a;
          try {
              const o = new AbortController;
              n > 0 && (a = setTimeout( () => {
                  r ? o.abort() : s(t)
              }
              , n)),
              i(await e({
                  signal: o == null ? void 0 : o.signal
              }))
          } catch (o) {
              o.name === "AbortError" && s(t),
              s(o)
          } finally {
              clearTimeout(a)
          }
      }
      )()
  }
  )
}
let Lp = 0;
async function J3(e, {body: t, fetchOptions: n={}, timeout: r=1e4}) {
  var o;
  const {headers: i, method: s, signal: a} = n;
  try {
      const u = await wx(async ({signal: c}) => await fetch(e, {
          ...n,
          body: Array.isArray(t) ? Et(t.map(d => ({
              jsonrpc: "2.0",
              id: d.id ?? Lp++,
              ...d
          }))) : Et({
              jsonrpc: "2.0",
              id: t.id ?? Lp++,
              ...t
          }),
          headers: {
              ...i,
              "Content-Type": "application/json"
          },
          method: s || "POST",
          signal: a || (r > 0 ? c : void 0)
      }), {
          errorInstance: new $p({
              body: t,
              url: e
          }),
          timeout: r,
          signal: !0
      });
      let l;
      if ((o = u.headers.get("Content-Type")) != null && o.startsWith("application/json") ? l = await u.json() : l = await u.text(),
      !u.ok)
          throw new da({
              body: t,
              details: Et(l.error) || u.statusText,
              headers: u.headers,
              status: u.status,
              url: e
          });
      return l
  } catch (u) {
      throw u instanceof da || u instanceof $p ? u : new da({
          body: t,
          details: u.message,
          url: e
      })
  }
}
const Qf = new Map;
async function Yf(e) {
  let t = Qf.get(e);
  if (t)
      return t;
  const {schedule: n} = Xm({
      id: e,
      fn: async () => {
          const s = new $0(e)
            , a = new Map
            , o = new Map
            , u = ({data: c}) => {
              const f = JSON.parse(c)
                , d = f.method === "eth_subscription"
                , y = d ? f.params.subscription : f.id
                , m = d ? o : a
                , v = m.get(y);
              v && v({
                  data: c
              }),
              d || m.delete(y)
          }
            , l = () => {
              Qf.delete(e),
              s.removeEventListener("close", l),
              s.removeEventListener("message", u)
          }
          ;
          return s.addEventListener("close", l),
          s.addEventListener("message", u),
          s.readyState === $0.CONNECTING && await new Promise( (c, f) => {
              s && (s.onopen = c,
              s.onerror = f)
          }
          ),
          t = Object.assign(s, {
              requests: a,
              subscriptions: o
          }),
          Qf.set(e, t),
          [t]
      }
  })
    , [r,[i]] = await n();
  return i
}
function Z3(e, {body: t, onResponse: n}) {
  if (e.readyState === e.CLOSED || e.readyState === e.CLOSING)
      throw new m3({
          body: t,
          url: e.url,
          details: "Socket is closed."
      });
  const r = Lp++
    , i = ({data: s}) => {
      var o;
      const a = JSON.parse(s);
      typeof a.id == "number" && r !== a.id || (n == null || n(a),
      t.method === "eth_subscribe" && typeof a.result == "string" && e.subscriptions.set(a.result, i),
      t.method === "eth_unsubscribe" && e.subscriptions.delete((o = t.params) == null ? void 0 : o[0]))
  }
  ;
  return e.requests.set(r, i),
  e.send(JSON.stringify({
      jsonrpc: "2.0",
      ...t,
      id: r
  })),
  e
}
async function eT(e, {body: t, timeout: n=1e4}) {
  return wx( () => new Promise(r => rs.webSocket(e, {
      body: t,
      onResponse: r
  })), {
      errorInstance: new $p({
          body: t,
          url: e.url
      }),
      timeout: n
  })
}
const rs = {
  http: J3,
  webSocket: Z3,
  webSocketAsync: eT
};
function tT(e, t={}) {
  const {batch: n, fetchOptions: r, key: i="http", name: s="HTTP JSON-RPC", retryDelay: a} = t;
  return ({chain: o, retryCount: u, timeout: l}) => {
      const {batchSize: c=1e3, wait: f=0} = typeof n == "object" ? n : {}
        , d = t.retryCount ?? u
        , y = l ?? t.timeout ?? 1e4
        , m = e || (o == null ? void 0 : o.rpcUrls.default.http[0]);
      if (!m)
          throw new vx;
      return kc({
          key: i,
          name: s,
          async request({method: v, params: b}) {
              const w = {
                  method: v,
                  params: b
              }
                , {schedule: h} = Xm({
                  id: `${e}`,
                  wait: f,
                  shouldSplitBatch(E) {
                      return E.length > c
                  },
                  fn: E => rs.http(m, {
                      body: E,
                      fetchOptions: r,
                      timeout: y
                  }),
                  sort: (E, p) => E.id - p.id
              })
                , g = async E => n ? h(E) : [await rs.http(m, {
                  body: E,
                  fetchOptions: r,
                  timeout: y
              })]
                , [{error: x, result: S}] = await g(w);
              if (x)
                  throw new Hm({
                      body: w,
                      error: x,
                      url: m
                  });
              return S
          },
          retryCount: d,
          retryDelay: a,
          timeout: y,
          type: "http"
      }, {
          fetchOptions: r,
          url: e
      })
  }
}
function ey(e, t) {
  var r, i, s;
  if (!(e instanceof V))
      return !1;
  const n = e.walk(a => a instanceof Ap);
  return n instanceof Ap ? !!(((r = n.data) == null ? void 0 : r.errorName) === "ResolverNotFound" || ((i = n.data) == null ? void 0 : i.errorName) === "ResolverWildcardNotSupported" || (s = n.reason) != null && s.includes("Wildcard on non-extended resolvers is not supported") || t === "reverse" && n.reason === rx[50]) : !1
}
function bx(e) {
  if (e.length !== 66 || e.indexOf("[") !== 0 || e.indexOf("]") !== 65)
      return null;
  const t = `0x${e.slice(1, 65)}`;
  return kn(t) ? t : null
}
function ju(e) {
  let t = new Uint8Array(32).fill(0);
  if (!e)
      return $a(t);
  const n = e.split(".");
  for (let r = n.length - 1; r >= 0; r -= 1) {
      const i = bx(n[r])
        , s = i ? $r(i) : bt(Bn(n[r]), "bytes");
      t = bt(Gn([t, s]), "bytes")
  }
  return $a(t)
}
function nT(e) {
  return `[${e.slice(2)}]`
}
function rT(e) {
  const t = new Uint8Array(32).fill(0);
  return e ? bx(e) || bt(Bn(e)) : $a(t)
}
function Dc(e) {
  const t = e.replace(/^\.|\.$/gm, "");
  if (t.length === 0)
      return new Uint8Array(1);
  const n = new Uint8Array(Bn(t).byteLength + 2);
  let r = 0;
  const i = t.split(".");
  for (let s = 0; s < i.length; s++) {
      let a = Bn(i[s]);
      a.byteLength > 255 && (a = Bn(nT(rT(i[s])))),
      n[r] = a.length,
      n.set(a, r + 1),
      r += a.length + 1
  }
  return n.byteLength !== r + 1 ? n.slice(0, r + 1) : n
}
async function iT(e, {blockNumber: t, blockTag: n, coinType: r, name: i, universalResolverAddress: s}) {
  let a = s;
  if (!a) {
      if (!e.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
      a = Ps({
          blockNumber: t,
          chain: e.chain,
          contract: "ensUniversalResolver"
      })
  }
  try {
      const o = Br({
          abi: D0,
          functionName: "addr",
          ...r != null ? {
              args: [ju(i), BigInt(r)]
          } : {
              args: [ju(i)]
          }
      })
        , u = await ne(e, Mr, "readContract")({
          address: a,
          abi: px,
          functionName: "resolve",
          args: [Zn(Dc(i)), o],
          blockNumber: t,
          blockTag: n
      });
      if (u[0] === "0x")
          return null;
      const l = _s({
          abi: D0,
          args: r != null ? [ju(i), BigInt(r)] : void 0,
          functionName: "addr",
          data: u[0]
      });
      return l === "0x" || oi(l) === "0x00" ? null : l
  } catch (o) {
      if (ey(o, "resolve"))
          return null;
      throw o
  }
}
class sT extends V {
  constructor({data: t}) {
      super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
          metaMessages: ["- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.", "", `Provided data: ${JSON.stringify(t)}`]
      }),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "EnsAvatarInvalidMetadataError"
      })
  }
}
class Hs extends V {
  constructor({reason: t}) {
      super(`ENS NFT avatar URI is invalid. ${t}`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "EnsAvatarInvalidNftUriError"
      })
  }
}
class ty extends V {
  constructor({uri: t}) {
      super(`Unable to resolve ENS avatar URI "${t}". The URI may be malformed, invalid, or does not respond with a valid image.`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "EnsAvatarUriResolutionError"
      })
  }
}
class aT extends V {
  constructor({namespace: t}) {
      super(`ENS NFT avatar namespace "${t}" is not supported. Must be "erc721" or "erc1155".`),
      Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "EnsAvatarUnsupportedNamespaceError"
      })
  }
}
const oT = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/
, uT = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/
, lT = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/
, cT = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function fT(e) {
  try {
      const t = await fetch(e, {
          method: "HEAD"
      });
      if (t.status === 200) {
          const n = t.headers.get("content-type");
          return n == null ? void 0 : n.startsWith("image/")
      }
      return !1
  } catch (t) {
      return typeof t == "object" && typeof t.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise(n => {
          const r = new Image;
          r.onload = () => {
              n(!0)
          }
          ,
          r.onerror = () => {
              n(!1)
          }
          ,
          r.src = e
      }
      )
  }
}
function R0(e, t) {
  return e ? e.endsWith("/") ? e.slice(0, -1) : e : t
}
function xx({uri: e, gatewayUrls: t}) {
  const n = lT.test(e);
  if (n)
      return {
          uri: e,
          isOnChain: !0,
          isEncoded: n
      };
  const r = R0(t == null ? void 0 : t.ipfs, "https://ipfs.io")
    , i = R0(t == null ? void 0 : t.arweave, "https://arweave.net")
    , s = e.match(oT)
    , {protocol: a, subpath: o, target: u, subtarget: l=""} = (s == null ? void 0 : s.groups) || {}
    , c = a === "ipns:/" || o === "ipns/"
    , f = a === "ipfs:/" || o === "ipfs/" || uT.test(e);
  if (e.startsWith("http") && !c && !f) {
      let y = e;
      return t != null && t.arweave && (y = e.replace(/https:\/\/arweave.net/g, t == null ? void 0 : t.arweave)),
      {
          uri: y,
          isOnChain: !1,
          isEncoded: !1
      }
  }
  if ((c || f) && u)
      return {
          uri: `${r}/${c ? "ipns" : "ipfs"}/${u}${l}`,
          isOnChain: !1,
          isEncoded: !1
      };
  if (a === "ar:/" && u)
      return {
          uri: `${i}/${u}${l || ""}`,
          isOnChain: !1,
          isEncoded: !1
      };
  let d = e.replace(cT, "");
  if (d.startsWith("<svg") && (d = `data:image/svg+xml;base64,${btoa(d)}`),
  d.startsWith("data:") || d.startsWith("{"))
      return {
          uri: d,
          isOnChain: !0,
          isEncoded: !1
      };
  throw new ty({
      uri: e
  })
}
function Ex(e) {
  if (typeof e != "object" || !("image"in e) && !("image_url"in e) && !("image_data"in e))
      throw new sT({
          data: e
      });
  return e.image || e.image_url || e.image_data
}
async function dT({gatewayUrls: e, uri: t}) {
  try {
      const n = await fetch(t).then(i => i.json());
      return await ny({
          gatewayUrls: e,
          uri: Ex(n)
      })
  } catch {
      throw new ty({
          uri: t
      })
  }
}
async function ny({gatewayUrls: e, uri: t}) {
  const {uri: n, isOnChain: r} = xx({
      uri: t,
      gatewayUrls: e
  });
  if (r || await fT(n))
      return n;
  throw new ty({
      uri: t
  })
}
function pT(e) {
  let t = e;
  t.startsWith("did:nft:") && (t = t.replace("did:nft:", "").replace(/_/g, "/"));
  const [n,r,i] = t.split("/")
    , [s,a] = n.split(":")
    , [o,u] = r.split(":");
  if (!s || s.toLowerCase() !== "eip155")
      throw new Hs({
          reason: "Only EIP-155 supported"
      });
  if (!a)
      throw new Hs({
          reason: "Chain ID not found"
      });
  if (!u)
      throw new Hs({
          reason: "Contract address not found"
      });
  if (!i)
      throw new Hs({
          reason: "Token ID not found"
      });
  if (!o)
      throw new Hs({
          reason: "ERC namespace not found"
      });
  return {
      chainID: parseInt(a),
      namespace: o.toLowerCase(),
      contractAddress: u,
      tokenID: i
  }
}
async function hT(e, {nft: t}) {
  if (t.namespace === "erc721")
      return Mr(e, {
          address: t.contractAddress,
          abi: [{
              name: "tokenURI",
              type: "function",
              stateMutability: "view",
              inputs: [{
                  name: "tokenId",
                  type: "uint256"
              }],
              outputs: [{
                  name: "",
                  type: "string"
              }]
          }],
          functionName: "tokenURI",
          args: [BigInt(t.tokenID)]
      });
  if (t.namespace === "erc1155")
      return Mr(e, {
          address: t.contractAddress,
          abi: [{
              name: "uri",
              type: "function",
              stateMutability: "view",
              inputs: [{
                  name: "_id",
                  type: "uint256"
              }],
              outputs: [{
                  name: "",
                  type: "string"
              }]
          }],
          functionName: "uri",
          args: [BigInt(t.tokenID)]
      });
  throw new aT({
      namespace: t.namespace
  })
}
async function mT(e, {gatewayUrls: t, record: n}) {
  return /eip155:/i.test(n) ? yT(e, {
      gatewayUrls: t,
      record: n
  }) : ny({
      uri: n,
      gatewayUrls: t
  })
}
async function yT(e, {gatewayUrls: t, record: n}) {
  const r = pT(n)
    , i = await hT(e, {
      nft: r
  })
    , {uri: s, isOnChain: a, isEncoded: o} = xx({
      uri: i,
      gatewayUrls: t
  });
  if (a && (s.includes("data:application/json;base64,") || s.startsWith("{"))) {
      const l = o ? atob(s.replace("data:application/json;base64,", "")) : s
        , c = JSON.parse(l);
      return ny({
          uri: Ex(c),
          gatewayUrls: t
      })
  }
  let u = r.tokenID;
  return r.namespace === "erc1155" && (u = u.replace("0x", "").padStart(64, "0")),
  dT({
      gatewayUrls: t,
      uri: s.replace(/(?:0x)?{id}/, u)
  })
}
async function Sx(e, {blockNumber: t, blockTag: n, name: r, key: i, universalResolverAddress: s}) {
  let a = s;
  if (!a) {
      if (!e.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
      a = Ps({
          blockNumber: t,
          chain: e.chain,
          contract: "ensUniversalResolver"
      })
  }
  try {
      const o = await ne(e, Mr, "readContract")({
          address: a,
          abi: px,
          functionName: "resolve",
          args: [Zn(Dc(r)), Br({
              abi: k0,
              functionName: "text",
              args: [ju(r), i]
          })],
          blockNumber: t,
          blockTag: n
      });
      if (o[0] === "0x")
          return null;
      const u = _s({
          abi: k0,
          functionName: "text",
          data: o[0]
      });
      return u === "" ? null : u
  } catch (o) {
      if (ey(o, "resolve"))
          return null;
      throw o
  }
}
async function gT(e, {blockNumber: t, blockTag: n, gatewayUrls: r, name: i, universalResolverAddress: s}) {
  const a = await ne(e, Sx, "getEnsText")({
      blockNumber: t,
      blockTag: n,
      key: "avatar",
      name: i,
      universalResolverAddress: s
  });
  if (!a)
      return null;
  try {
      return await mT(e, {
          record: a,
          gatewayUrls: r
      })
  } catch {
      return null
  }
}
async function vT(e, {address: t, blockNumber: n, blockTag: r, universalResolverAddress: i}) {
  let s = i;
  if (!s) {
      if (!e.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
      s = Ps({
          blockNumber: n,
          chain: e.chain,
          contract: "ensUniversalResolver"
      })
  }
  const a = `${t.toLowerCase().substring(2)}.addr.reverse`;
  try {
      const [o,u] = await ne(e, Mr, "readContract")({
          address: s,
          abi: D3,
          functionName: "reverse",
          args: [Zn(Dc(a))],
          blockNumber: n,
          blockTag: r
      });
      return t.toLowerCase() !== u.toLowerCase() ? null : o
  } catch (o) {
      if (ey(o, "reverse"))
          return null;
      throw o
  }
}
async function wT(e, {blockNumber: t, blockTag: n, name: r, universalResolverAddress: i}) {
  let s = i;
  if (!s) {
      if (!e.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
      s = Ps({
          blockNumber: t,
          chain: e.chain,
          contract: "ensUniversalResolver"
      })
  }
  const [a] = await ne(e, Mr, "readContract")({
      address: s,
      abi: [{
          inputs: [{
              type: "bytes"
          }],
          name: "findResolver",
          outputs: [{
              type: "address"
          }, {
              type: "bytes32"
          }],
          stateMutability: "view",
          type: "function"
      }],
      functionName: "findResolver",
      args: [Zn(Dc(r))],
      blockNumber: t,
      blockTag: n
  });
  return a
}
async function bT(e) {
  const t = Sc(e, {
      method: "eth_newBlockFilter"
  })
    , n = await e.request({
      method: "eth_newBlockFilter"
  });
  return {
      id: n,
      request: t(n),
      type: "block"
  }
}
async function Cx(e, {address: t, args: n, event: r, events: i, fromBlock: s, strict: a, toBlock: o}={}) {
  const u = i ?? (r ? [r] : void 0)
    , l = Sc(e, {
      method: "eth_newFilter"
  });
  let c = [];
  u && (c = [u.flatMap(d => yo({
      abi: [d],
      eventName: d.name,
      args: n
  }))],
  r && (c = c[0]));
  const f = await e.request({
      method: "eth_newFilter",
      params: [{
          address: t,
          fromBlock: typeof s == "bigint" ? ie(s) : s,
          toBlock: typeof o == "bigint" ? ie(o) : o,
          ...c.length ? {
              topics: c
          } : {}
      }]
  });
  return {
      abi: u,
      args: n,
      eventName: r ? r.name : void 0,
      fromBlock: s,
      id: f,
      request: l(f),
      strict: a,
      toBlock: o,
      type: "event"
  }
}
async function _x(e) {
  const t = Sc(e, {
      method: "eth_newPendingTransactionFilter"
  })
    , n = await e.request({
      method: "eth_newPendingTransactionFilter"
  });
  return {
      id: n,
      request: t(n),
      type: "transaction"
  }
}
async function xT(e, {address: t, blockNumber: n, blockTag: r="latest"}) {
  const i = n ? ie(n) : void 0
    , s = await e.request({
      method: "eth_getBalance",
      params: [t, i || r]
  });
  return BigInt(s)
}
async function ET(e, {blockHash: t, blockNumber: n, blockTag: r="latest"}={}) {
  const i = n !== void 0 ? ie(n) : void 0;
  let s;
  return t ? s = await e.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [t]
  }) : s = await e.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [i || r]
  }),
  yt(s)
}
async function ST(e, {address: t, blockNumber: n, blockTag: r="latest"}) {
  const i = n !== void 0 ? ie(n) : void 0
    , s = await e.request({
      method: "eth_getCode",
      params: [t, i || r]
  });
  if (s !== "0x")
      return s
}
function CT(e) {
  var t;
  return {
      baseFeePerGas: e.baseFeePerGas.map(n => BigInt(n)),
      gasUsedRatio: e.gasUsedRatio,
      oldestBlock: BigInt(e.oldestBlock),
      reward: (t = e.reward) == null ? void 0 : t.map(n => n.map(r => BigInt(r)))
  }
}
async function _T(e, {blockCount: t, blockNumber: n, blockTag: r="latest", rewardPercentiles: i}) {
  const s = n ? ie(n) : void 0
    , a = await e.request({
      method: "eth_feeHistory",
      params: [ie(t), s || r, i]
  });
  return CT(a)
}
async function PT(e, {filter: t}) {
  const n = t.strict ?? !1;
  return (await t.request({
      method: "eth_getFilterLogs",
      params: [t.id]
  })).map(i => {
      var s;
      try {
          const {eventName: a, args: o} = "abi"in t && t.abi ? wo({
              abi: t.abi,
              data: i.data,
              topics: i.topics,
              strict: n
          }) : {
              eventName: void 0,
              args: void 0
          };
          return mn(i, {
              args: o,
              eventName: a
          })
      } catch (a) {
          let o, u;
          if (a instanceof mi || a instanceof Es) {
              if ("strict"in t && t.strict)
                  return;
              o = a.abiItem.name,
              u = (s = a.abiItem.inputs) == null ? void 0 : s.some(l => !("name"in l && l.name))
          }
          return mn(i, {
              args: u ? [] : {},
              eventName: o
          })
      }
  }
  ).filter(Boolean)
}
const TT = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/
, OT = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function kT({domain: e, message: t, primaryType: n, types: r}) {
  const i = typeof e > "u" ? {} : e
    , s = {
      EIP712Domain: Ix({
          domain: i
      }),
      ...r
  };
  Dx({
      domain: i,
      message: t,
      primaryType: n,
      types: s
  });
  const a = ["0x1901"];
  return i && a.push(DT({
      domain: i,
      types: s
  })),
  n !== "EIP712Domain" && a.push(Px({
      data: t,
      primaryType: n,
      types: s
  })),
  bt(Gn(a))
}
function DT({domain: e, types: t}) {
  return Px({
      data: e,
      primaryType: "EIP712Domain",
      types: t
  })
}
function Px({data: e, primaryType: t, types: n}) {
  const r = Tx({
      data: e,
      primaryType: t,
      types: n
  });
  return bt(r)
}
function Tx({data: e, primaryType: t, types: n}) {
  const r = [{
      type: "bytes32"
  }]
    , i = [IT({
      primaryType: t,
      types: n
  })];
  for (const s of n[t]) {
      const [a,o] = kx({
          types: n,
          name: s.name,
          type: s.type,
          value: e[s.name]
      });
      r.push(a),
      i.push(o)
  }
  return ho(r, i)
}
function IT({primaryType: e, types: t}) {
  const n = Zn(AT({
      primaryType: e,
      types: t
  }));
  return bt(n)
}
function AT({primaryType: e, types: t}) {
  let n = "";
  const r = Ox({
      primaryType: e,
      types: t
  });
  r.delete(e);
  const i = [e, ...Array.from(r).sort()];
  for (const s of i)
      n += `${s}(${t[s].map( ({name: a, type: o}) => `${o} ${a}`).join(",")})`;
  return n
}
function Ox({primaryType: e, types: t}, n=new Set) {
  const r = e.match(/^\w*/u)
    , i = r == null ? void 0 : r[0];
  if (n.has(i) || t[i] === void 0)
      return n;
  n.add(i);
  for (const s of t[i])
      Ox({
          primaryType: s.type,
          types: t
      }, n);
  return n
}
function kx({types: e, name: t, type: n, value: r}) {
  if (e[n] !== void 0)
      return [{
          type: "bytes32"
      }, bt(Tx({
          data: r,
          primaryType: n,
          types: e
      }))];
  if (n === "bytes")
      return r = `0x${(r.length % 2 ? "0" : "") + r.slice(2)}`,
      [{
          type: "bytes32"
      }, bt(r)];
  if (n === "string")
      return [{
          type: "bytes32"
      }, bt(Zn(r))];
  if (n.lastIndexOf("]") === n.length - 1) {
      const i = n.slice(0, n.lastIndexOf("["))
        , s = r.map(a => kx({
          name: t,
          type: i,
          types: e,
          value: a
      }));
      return [{
          type: "bytes32"
      }, bt(ho(s.map( ([a]) => a), s.map( ([,a]) => a)))]
  }
  return [{
      type: n
  }, r]
}
function Dx({domain: e, message: t, primaryType: n, types: r}) {
  const i = r
    , s = (a, o) => {
      for (const u of a) {
          const {name: l, type: c} = u
            , f = c
            , d = o[l]
            , y = f.match(OT);
          if (y && (typeof d == "number" || typeof d == "bigint")) {
              const [b,w,h] = y;
              ie(d, {
                  signed: w === "int",
                  size: parseInt(h) / 8
              })
          }
          if (f === "address" && typeof d == "string" && !Rr(d))
              throw new Ra({
                  address: d
              });
          const m = f.match(TT);
          if (m) {
              const [b,w] = m;
              if (w && Ke(d) !== parseInt(w))
                  throw new cP({
                      expectedSize: parseInt(w),
                      givenSize: Ke(d)
                  })
          }
          const v = i[f];
          v && s(v, d)
      }
  }
  ;
  if (i.EIP712Domain && e && s(i.EIP712Domain, e),
  n !== "EIP712Domain") {
      const a = i[n];
      s(a, t)
  }
}
function Ix({domain: e}) {
  return [typeof (e == null ? void 0 : e.name) == "string" && {
      name: "name",
      type: "string"
  }, (e == null ? void 0 : e.version) && {
      name: "version",
      type: "string"
  }, typeof (e == null ? void 0 : e.chainId) == "number" && {
      name: "chainId",
      type: "uint256"
  }, (e == null ? void 0 : e.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
  }, (e == null ? void 0 : e.salt) && {
      name: "salt",
      type: "bytes32"
  }].filter(Boolean)
}
const Xf = "/docs/contract/encodeDeployData";
function Ax({abi: e, args: t, bytecode: n}) {
  if (!t || t.length === 0)
      return n;
  const r = e.find(s => "type"in s && s.type === "constructor");
  if (!r)
      throw new nP({
          docsPath: Xf
      });
  if (!("inputs"in r))
      throw new w0({
          docsPath: Xf
      });
  if (!r.inputs || r.inputs.length === 0)
      throw new w0({
          docsPath: Xf
      });
  const i = ho(r.inputs, t);
  return $m([n, i])
}
const $T = `Ethereum Signed Message:
`;
function RT(e, t) {
  const n = typeof e == "string" ? Bn(e) : e.raw instanceof Uint8Array ? e.raw : $r(e.raw)
    , r = Bn(`${$T}${n.length}`);
  return bt(Gn([r, n]), t)
}
function NT(e) {
  return e.map(t => ({
      ...t,
      value: BigInt(t.value)
  }))
}
function jT(e) {
  return {
      ...e,
      balance: e.balance ? BigInt(e.balance) : void 0,
      nonce: e.nonce ? yt(e.nonce) : void 0,
      storageProof: e.storageProof ? NT(e.storageProof) : void 0
  }
}
async function MT(e, {address: t, blockNumber: n, blockTag: r, storageKeys: i}) {
  const s = r ?? "latest"
    , a = n !== void 0 ? ie(n) : void 0
    , o = await e.request({
      method: "eth_getProof",
      params: [t, i, a || s]
  });
  return jT(o)
}
async function LT(e, {address: t, blockNumber: n, blockTag: r="latest", slot: i}) {
  const s = n !== void 0 ? ie(n) : void 0;
  return await e.request({
      method: "eth_getStorageAt",
      params: [t, i, s || r]
  })
}
async function ry(e, {blockHash: t, blockNumber: n, blockTag: r, hash: i, index: s}) {
  var c, f, d;
  const a = r || "latest"
    , o = n !== void 0 ? ie(n) : void 0;
  let u = null;
  if (i ? u = await e.request({
      method: "eth_getTransactionByHash",
      params: [i]
  }) : t ? u = await e.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [t, ie(s)]
  }) : (o || a) && (u = await e.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [o || a, ie(s)]
  })),
  !u)
      throw new sx({
          blockHash: t,
          blockNumber: n,
          blockTag: a,
          hash: i,
          index: s
      });
  return (((d = (f = (c = e.chain) == null ? void 0 : c.formatters) == null ? void 0 : f.transaction) == null ? void 0 : d.format) || W2)(u)
}
async function FT(e, {hash: t, transactionReceipt: n}) {
  const [r,i] = await Promise.all([ne(e, xo, "getBlockNumber")({}), t ? ne(e, ry, "getBlockNumber")({
      hash: t
  }) : void 0])
    , s = (n == null ? void 0 : n.blockNumber) || (i == null ? void 0 : i.blockNumber);
  return s ? r - s + 1n : 0n
}
async function Fp(e, {hash: t}) {
  var i, s, a;
  const n = await e.request({
      method: "eth_getTransactionReceipt",
      params: [t]
  });
  if (!n)
      throw new ax({
          hash: t
      });
  return (((a = (s = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionReceipt) == null ? void 0 : a.format) || H_)(n)
}
async function UT(e, t) {
  var v;
  const {allowFailure: n=!0, batchSize: r, blockNumber: i, blockTag: s, contracts: a, multicallAddress: o} = t
    , u = r ?? (typeof ((v = e.batch) == null ? void 0 : v.multicall) == "object" && e.batch.multicall.batchSize || 1024);
  let l = o;
  if (!l) {
      if (!e.chain)
          throw new Error("client chain not configured. multicallAddress is required.");
      l = Ps({
          blockNumber: i,
          chain: e.chain,
          contract: "multicall3"
      })
  }
  const c = [[]];
  let f = 0
    , d = 0;
  for (let b = 0; b < a.length; b++) {
      const {abi: w, address: h, args: g, functionName: x} = a[b];
      try {
          const S = Br({
              abi: w,
              args: g,
              functionName: x
          });
          d += (S.length - 2) / 2,
          u > 0 && d > u && c[f].length > 0 && (f++,
          d = (S.length - 2) / 2,
          c[f] = []),
          c[f] = [...c[f], {
              allowFailure: !0,
              callData: S,
              target: h
          }]
      } catch (S) {
          const E = Ga(S, {
              abi: w,
              address: h,
              args: g,
              docsPath: "/docs/contract/multicall",
              functionName: x
          });
          if (!n)
              throw E;
          c[f] = [...c[f], {
              allowFailure: !0,
              callData: "0x",
              target: h
          }]
      }
  }
  const y = await Promise.allSettled(c.map(b => ne(e, Mr, "readContract")({
      abi: Np,
      address: l,
      args: [b],
      blockNumber: i,
      blockTag: s,
      functionName: "aggregate3"
  })))
    , m = [];
  for (let b = 0; b < y.length; b++) {
      const w = y[b];
      if (w.status === "rejected") {
          if (!n)
              throw w.reason;
          for (let g = 0; g < c[b].length; g++)
              m.push({
                  status: "failure",
                  error: w.reason,
                  result: void 0
              });
          continue
      }
      const h = w.value;
      for (let g = 0; g < h.length; g++) {
          const {returnData: x, success: S} = h[g]
            , {callData: E} = c[b][g]
            , {abi: p, address: C, functionName: T, args: O} = a[m.length];
          try {
              if (E === "0x")
                  throw new xc;
              if (!S)
                  throw new Wm({
                      data: x
                  });
              const R = _s({
                  abi: p,
                  args: O,
                  data: x,
                  functionName: T
              });
              m.push(n ? {
                  result: R,
                  status: "success"
              } : R)
          } catch (R) {
              const j = Ga(R, {
                  abi: p,
                  address: C,
                  args: O,
                  docsPath: "/docs/contract/multicall",
                  functionName: T
              });
              if (!n)
                  throw j;
              m.push({
                  error: j,
                  result: void 0,
                  status: "failure"
              })
          }
      }
  }
  if (m.length !== a.length)
      throw new V("multicall results mismatch");
  return m
}
const zT = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
BigInt(0);
BigInt(1);
BigInt(2);
function BT(e, t) {
  if (e.length !== t.length)
      return !1;
  for (let n = 0; n < e.length; n++)
      if (e[n] !== t[n])
          return !1;
  return !0
}
function WT(e, t) {
  const n = kn(e) ? $r(e) : e
    , r = kn(t) ? $r(t) : t;
  return BT(n, r)
}
async function $x(e, {address: t, hash: n, signature: r, ...i}) {
  const s = kn(r) ? r : Zn(r);
  try {
      const {data: a} = await ne(e, Pc, "call")({
          data: Ax({
              abi: I3,
              args: [t, n, s],
              bytecode: zT
          }),
          ...i
      });
      return WT(a ?? "0x0", "0x1")
  } catch (a) {
      if (a instanceof ox)
          return !1;
      throw a
  }
}
async function HT(e, {address: t, message: n, signature: r, ...i}) {
  const s = RT(n);
  return $x(e, {
      address: t,
      hash: s,
      signature: r,
      ...i
  })
}
async function qT(e, {address: t, signature: n, message: r, primaryType: i, types: s, domain: a, ...o}) {
  const u = kT({
      message: r,
      primaryType: i,
      types: s,
      domain: a
  });
  return $x(e, {
      address: t,
      hash: u,
      signature: n,
      ...o
  })
}
function Rx(e, {emitOnBegin: t=!1, emitMissed: n=!1, onBlockNumber: r, onError: i, poll: s, pollingInterval: a=e.pollingInterval}) {
  const o = typeof s < "u" ? s : e.transport.type !== "webSocket";
  let u;
  return o ? ( () => {
      const f = Et(["watchBlockNumber", e.uid, t, n, a]);
      return Ts(f, {
          onBlockNumber: r,
          onError: i
      }, d => bo(async () => {
          var y;
          try {
              const m = await ne(e, xo, "getBlockNumber")({
                  cacheTime: 0
              });
              if (u) {
                  if (m === u)
                      return;
                  if (m - u > 1 && n)
                      for (let v = u + 1n; v < m; v++)
                          d.onBlockNumber(v, u),
                          u = v
              }
              (!u || m > u) && (d.onBlockNumber(m, u),
              u = m)
          } catch (m) {
              (y = d.onError) == null || y.call(d, m)
          }
      }
      , {
          emitOnBegin: t,
          interval: a
      }))
  }
  )() : ( () => {
      let f = !0
        , d = () => f = !1;
      return (async () => {
          try {
              const {unsubscribe: y} = await e.transport.subscribe({
                  params: ["newHeads"],
                  onData(m) {
                      var b;
                      if (!f)
                          return;
                      const v = gc((b = m.result) == null ? void 0 : b.number);
                      r(v, u),
                      u = v
                  },
                  onError(m) {
                      i == null || i(m)
                  }
              });
              d = y,
              f || d()
          } catch (y) {
              i == null || i(y)
          }
      }
      )(),
      d
  }
  )()
}
async function VT(e, {confirmations: t=1, hash: n, onReplaced: r, pollingInterval: i=e.pollingInterval, timeout: s}) {
  const a = Et(["waitForTransactionReceipt", e.uid, n]);
  let o, u, l, c = !1;
  return new Promise( (f, d) => {
      s && setTimeout( () => d(new p3({
          hash: n
      })), s);
      const y = Ts(a, {
          onReplaced: r,
          resolve: f,
          reject: d
      }, m => {
          const v = ne(e, Rx, "watchBlockNumber")({
              emitMissed: !0,
              emitOnBegin: !0,
              poll: !0,
              pollingInterval: i,
              async onBlockNumber(b) {
                  if (c)
                      return;
                  let w = b;
                  const h = g => {
                      v(),
                      g(),
                      y()
                  }
                  ;
                  try {
                      if (l) {
                          if (t > 1 && (!l.blockNumber || w - l.blockNumber + 1n < t))
                              return;
                          h( () => m.resolve(l));
                          return
                      }
                      if (o || (c = !0,
                      await Mp(async () => {
                          o = await ne(e, ry, "getTransaction")({
                              hash: n
                          }),
                          o.blockNumber && (w = o.blockNumber)
                      }
                      , {
                          delay: ({count: g}) => ~~(1 << g) * 200,
                          retryCount: 6
                      }),
                      c = !1),
                      l = await ne(e, Fp, "getTransactionReceipt")({
                          hash: n
                      }),
                      t > 1 && (!l.blockNumber || w - l.blockNumber + 1n < t))
                          return;
                      h( () => m.resolve(l))
                  } catch (g) {
                      if (o && (g instanceof sx || g instanceof ax))
                          try {
                              u = o,
                              c = !0;
                              const x = await Mp( () => ne(e, jr, "getBlock")({
                                  blockNumber: w,
                                  includeTransactions: !0
                              }), {
                                  delay: ({count: p}) => ~~(1 << p) * 200,
                                  retryCount: 6,
                                  shouldRetry: ({error: p}) => p instanceof ux
                              });
                              c = !1;
                              const S = x.transactions.find( ({from: p, nonce: C}) => p === u.from && C === u.nonce);
                              if (!S || (l = await ne(e, Fp, "getTransactionReceipt")({
                                  hash: S.hash
                              }),
                              t > 1 && (!l.blockNumber || w - l.blockNumber + 1n < t)))
                                  return;
                              let E = "replaced";
                              S.to === u.to && S.value === u.value ? E = "repriced" : S.from === S.to && S.value === 0n && (E = "cancelled"),
                              h( () => {
                                  var p;
                                  (p = m.onReplaced) == null || p.call(m, {
                                      reason: E,
                                      replacedTransaction: u,
                                      transaction: S,
                                      transactionReceipt: l
                                  }),
                                  m.resolve(l)
                              }
                              )
                          } catch (x) {
                              h( () => m.reject(x))
                          }
                      else
                          h( () => m.reject(g))
                  }
              }
          })
      }
      )
  }
  )
}
function KT(e, {blockTag: t="latest", emitMissed: n=!1, emitOnBegin: r=!1, onBlock: i, onError: s, includeTransactions: a, poll: o, pollingInterval: u=e.pollingInterval}) {
  const l = typeof o < "u" ? o : e.transport.type !== "webSocket"
    , c = a ?? !1;
  let f;
  return l ? ( () => {
      const m = Et(["watchBlocks", e.uid, n, r, c, u]);
      return Ts(m, {
          onBlock: i,
          onError: s
      }, v => bo(async () => {
          var b;
          try {
              const w = await ne(e, jr, "getBlock")({
                  blockTag: t,
                  includeTransactions: c
              });
              if (w.number && (f != null && f.number)) {
                  if (w.number === f.number)
                      return;
                  if (w.number - f.number > 1 && n)
                      for (let h = (f == null ? void 0 : f.number) + 1n; h < w.number; h++) {
                          const g = await ne(e, jr, "getBlock")({
                              blockNumber: h,
                              includeTransactions: c
                          });
                          v.onBlock(g, f),
                          f = g
                      }
              }
              (!(f != null && f.number) || t === "pending" && !(w != null && w.number) || w.number && w.number > f.number) && (v.onBlock(w, f),
              f = w)
          } catch (w) {
              (b = v.onError) == null || b.call(v, w)
          }
      }
      , {
          emitOnBegin: r,
          interval: u
      }))
  }
  )() : ( () => {
      let m = !0
        , v = () => m = !1;
      return (async () => {
          try {
              const {unsubscribe: b} = await e.transport.subscribe({
                  params: ["newHeads"],
                  onData(w) {
                      var x, S, E;
                      if (!m)
                          return;
                      const g = (((E = (S = (x = e.chain) == null ? void 0 : x.formatters) == null ? void 0 : S.block) == null ? void 0 : E.format) || H2)(w.result);
                      i(g, f),
                      f = g
                  },
                  onError(w) {
                      s == null || s(w)
                  }
              });
              v = b,
              m || v()
          } catch (b) {
              s == null || s(b)
          }
      }
      )(),
      v
  }
  )()
}
function GT(e, {address: t, args: n, batch: r=!0, event: i, events: s, onError: a, onLogs: o, poll: u, pollingInterval: l=e.pollingInterval, strict: c}) {
  const f = typeof u < "u" ? u : e.transport.type !== "webSocket"
    , d = c ?? !1;
  return f ? ( () => {
      const v = Et(["watchEvent", t, n, r, e.uid, i, l]);
      return Ts(v, {
          onLogs: o,
          onError: a
      }, b => {
          let w, h, g = !1;
          const x = bo(async () => {
              var S;
              if (!g) {
                  try {
                      h = await ne(e, Cx, "createEventFilter")({
                          address: t,
                          args: n,
                          event: i,
                          events: s,
                          strict: d
                      })
                  } catch {}
                  g = !0;
                  return
              }
              try {
                  let E;
                  if (h)
                      E = await ne(e, Tc, "getFilterChanges")({
                          filter: h
                      });
                  else {
                      const p = await ne(e, xo, "getBlockNumber")({});
                      w && w !== p ? E = await ne(e, Ym, "getLogs")({
                          address: t,
                          args: n,
                          event: i,
                          events: s,
                          fromBlock: w + 1n,
                          toBlock: p
                      }) : E = [],
                      w = p
                  }
                  if (E.length === 0)
                      return;
                  if (r)
                      b.onLogs(E);
                  else
                      for (const p of E)
                          b.onLogs([p])
              } catch (E) {
                  h && E instanceof yi && (g = !1),
                  (S = b.onError) == null || S.call(b, E)
              }
          }
          , {
              emitOnBegin: !0,
              interval: l
          });
          return async () => {
              h && await ne(e, Oc, "uninstallFilter")({
                  filter: h
              }),
              x()
          }
      }
      )
  }
  )() : ( () => {
      let v = !0
        , b = () => v = !1;
      return (async () => {
          try {
              const w = s ?? (i ? [i] : void 0);
              let h = [];
              w && (h = [w.flatMap(x => yo({
                  abi: [x],
                  eventName: x.name,
                  args: n
              }))],
              i && (h = h[0]));
              const {unsubscribe: g} = await e.transport.subscribe({
                  params: ["logs", {
                      address: t,
                      topics: h
                  }],
                  onData(x) {
                      var E;
                      if (!v)
                          return;
                      const S = x.result;
                      try {
                          const {eventName: p, args: C} = wo({
                              abi: w,
                              data: S.data,
                              topics: S.topics,
                              strict: d
                          })
                            , T = mn(S, {
                              args: C,
                              eventName: p
                          });
                          o([T])
                      } catch (p) {
                          let C, T;
                          if (p instanceof mi || p instanceof Es) {
                              if (c)
                                  return;
                              C = p.abiItem.name,
                              T = (E = p.abiItem.inputs) == null ? void 0 : E.some(R => !("name"in R && R.name))
                          }
                          const O = mn(S, {
                              args: T ? [] : {},
                              eventName: C
                          });
                          o([O])
                      }
                  },
                  onError(x) {
                      a == null || a(x)
                  }
              });
              b = g,
              v || b()
          } catch (w) {
              a == null || a(w)
          }
      }
      )(),
      b
  }
  )()
}
function QT(e, {batch: t=!0, onError: n, onTransactions: r, poll: i, pollingInterval: s=e.pollingInterval}) {
  return (typeof i < "u" ? i : e.transport.type !== "webSocket") ? ( () => {
      const l = Et(["watchPendingTransactions", e.uid, t, s]);
      return Ts(l, {
          onTransactions: r,
          onError: n
      }, c => {
          let f;
          const d = bo(async () => {
              var y;
              try {
                  if (!f)
                      try {
                          f = await ne(e, _x, "createPendingTransactionFilter")({});
                          return
                      } catch (v) {
                          throw d(),
                          v
                      }
                  const m = await ne(e, Tc, "getFilterChanges")({
                      filter: f
                  });
                  if (m.length === 0)
                      return;
                  if (t)
                      c.onTransactions(m);
                  else
                      for (const v of m)
                          c.onTransactions([v])
              } catch (m) {
                  (y = c.onError) == null || y.call(c, m)
              }
          }
          , {
              emitOnBegin: !0,
              interval: s
          });
          return async () => {
              f && await ne(e, Oc, "uninstallFilter")({
                  filter: f
              }),
              d()
          }
      }
      )
  }
  )() : ( () => {
      let l = !0
        , c = () => l = !1;
      return (async () => {
          try {
              const {unsubscribe: f} = await e.transport.subscribe({
                  params: ["newPendingTransactions"],
                  onData(d) {
                      if (!l)
                          return;
                      const y = d.result;
                      r([y])
                  },
                  onError(d) {
                      n == null || n(d)
                  }
              });
              c = f,
              l || c()
          } catch (f) {
              n == null || n(f)
          }
      }
      )(),
      c
  }
  )()
}
function YT(e) {
  return {
      call: t => Pc(e, t),
      createBlockFilter: () => bT(e),
      createContractEventFilter: t => nx(e, t),
      createEventFilter: t => Cx(e, t),
      createPendingTransactionFilter: () => _x(e),
      estimateContractGas: t => P3(e, t),
      estimateGas: t => Qm(e, t),
      getBalance: t => xT(e, t),
      getBlock: t => jr(e, t),
      getBlockNumber: t => xo(e, t),
      getBlockTransactionCount: t => ET(e, t),
      getBytecode: t => ST(e, t),
      getChainId: () => Qa(e),
      getContractEvents: t => fx(e, t),
      getEnsAddress: t => iT(e, t),
      getEnsAvatar: t => gT(e, t),
      getEnsName: t => vT(e, t),
      getEnsResolver: t => wT(e, t),
      getEnsText: t => Sx(e, t),
      getFeeHistory: t => _T(e, t),
      estimateFeesPerGas: t => C3(e, t),
      getFilterChanges: t => Tc(e, t),
      getFilterLogs: t => PT(e, t),
      getGasPrice: () => Gm(e),
      getLogs: t => Ym(e, t),
      getProof: t => MT(e, t),
      estimateMaxPriorityFeePerGas: t => S3(e, t),
      getStorageAt: t => LT(e, t),
      getTransaction: t => ry(e, t),
      getTransactionConfirmations: t => FT(e, t),
      getTransactionCount: t => cx(e, t),
      getTransactionReceipt: t => Fp(e, t),
      multicall: t => UT(e, t),
      prepareTransactionRequest: t => _c(e, t),
      readContract: t => Mr(e, t),
      sendRawTransaction: t => Jm(e, t),
      simulateContract: t => M3(e, t),
      verifyMessage: t => HT(e, t),
      verifyTypedData: t => qT(e, t),
      uninstallFilter: t => Oc(e, t),
      waitForTransactionReceipt: t => VT(e, t),
      watchBlocks: t => KT(e, t),
      watchBlockNumber: t => Rx(e, t),
      watchContractEvent: t => H3(e, t),
      watchEvent: t => GT(e, t),
      watchPendingTransactions: t => QT(e, t)
  }
}
function N0(e) {
  const {key: t="public", name: n="Public Client"} = e;
  return mx({
      ...e,
      key: t,
      name: n,
      type: "publicClient"
  }).extend(YT)
}
function XT(e, {abi: t, args: n, bytecode: r, ...i}) {
  const s = Ax({
      abi: t,
      args: n,
      bytecode: r
  });
  return Zm(e, {
      ...i,
      data: s
  })
}
async function JT(e) {
  var n;
  return ((n = e.account) == null ? void 0 : n.type) === "local" ? [e.account.address] : (await e.request({
      method: "eth_accounts"
  })).map(r => Um(r))
}
async function ZT(e) {
  return await e.request({
      method: "wallet_getPermissions"
  })
}
async function eO(e) {
  return (await e.request({
      method: "eth_requestAccounts"
  })).map(n => Tr(n))
}
async function tO(e, t) {
  return e.request({
      method: "wallet_requestPermissions",
      params: [t]
  })
}
async function nO(e, {account: t=e.account, message: n}) {
  if (!t)
      throw new Cs({
          docsPath: "/docs/actions/wallet/signMessage"
      });
  const r = rn(t);
  if (r.type === "local")
      return r.signMessage({
          message: n
      });
  const i = typeof n == "string" ? Dm(n) : n.raw instanceof Uint8Array ? Zn(n.raw) : n.raw;
  return e.request({
      method: "personal_sign",
      params: [i, r.address]
  })
}
async function rO(e, t) {
  var l, c, f, d;
  const {account: n=e.account, chain: r=e.chain, ...i} = t;
  if (!n)
      throw new Cs({
          docsPath: "/docs/actions/wallet/signTransaction"
      });
  const s = rn(n);
  vo({
      account: s,
      ...t
  });
  const a = await ne(e, Qa, "getChainId")({});
  r !== null && hx({
      currentChainId: a,
      chain: r
  });
  const o = (r == null ? void 0 : r.formatters) || ((l = e.chain) == null ? void 0 : l.formatters)
    , u = ((c = o == null ? void 0 : o.transactionRequest) == null ? void 0 : c.format) || vc;
  return s.type === "local" ? s.signTransaction({
      ...i,
      chainId: a
  }, {
      serializer: (d = (f = e.chain) == null ? void 0 : f.serializers) == null ? void 0 : d.transaction
  }) : await e.request({
      method: "eth_signTransaction",
      params: [{
          ...u(i),
          chainId: ie(a),
          from: s.address
      }]
  })
}
async function iO(e, {account: t=e.account, domain: n, message: r, primaryType: i, types: s}) {
  if (!t)
      throw new Cs({
          docsPath: "/docs/actions/wallet/signTypedData"
      });
  const a = rn(t)
    , o = {
      EIP712Domain: Ix({
          domain: n
      }),
      ...s
  };
  if (Dx({
      domain: n,
      message: r,
      primaryType: i,
      types: o
  }),
  a.type === "local")
      return a.signTypedData({
          domain: n,
          primaryType: i,
          types: o,
          message: r
      });
  const u = Et({
      domain: n ?? {},
      primaryType: i,
      types: o,
      message: r
  }, (l, c) => kn(c) ? c.toLowerCase() : c);
  return e.request({
      method: "eth_signTypedData_v4",
      params: [a.address, u]
  })
}
async function sO(e, {id: t}) {
  await e.request({
      method: "wallet_switchEthereumChain",
      params: [{
          chainId: ie(t)
      }]
  })
}
async function aO(e, t) {
  return await e.request({
      method: "wallet_watchAsset",
      params: t
  })
}
function oO(e) {
  return {
      addChain: t => K3(e, t),
      deployContract: t => XT(e, t),
      getAddresses: () => JT(e),
      getChainId: () => Qa(e),
      getPermissions: () => ZT(e),
      prepareTransactionRequest: t => _c(e, t),
      requestAddresses: () => eO(e),
      requestPermissions: t => tO(e, t),
      sendRawTransaction: t => Jm(e, t),
      sendTransaction: t => Zm(e, t),
      signMessage: t => nO(e, t),
      signTransaction: t => rO(e, t),
      signTypedData: t => iO(e, t),
      switchChain: t => sO(e, t),
      watchAsset: t => aO(e, t),
      writeContract: t => V3(e, t)
  }
}
function Nx(e) {
  const {key: t="wallet", name: n="Wallet Client", transport: r} = e;
  return mx({
      ...e,
      key: t,
      name: n,
      transport: s => r({
          ...s,
          retryCount: 0
      }),
      type: "walletClient"
  }).extend(oO)
}
function uO(e, t={}) {
  const {key: n="webSocket", name: r="WebSocket JSON-RPC", retryDelay: i} = t;
  return ({chain: s, retryCount: a, timeout: o}) => {
      var f;
      const u = t.retryCount ?? a
        , l = o ?? t.timeout ?? 1e4
        , c = e || ((f = s == null ? void 0 : s.rpcUrls.default.webSocket) == null ? void 0 : f[0]);
      if (!c)
          throw new vx;
      return kc({
          key: n,
          name: r,
          async request({method: d, params: y}) {
              const m = {
                  method: d,
                  params: y
              }
                , v = await Yf(c)
                , {error: b, result: w} = await rs.webSocketAsync(v, {
                  body: m,
                  timeout: l
              });
              if (b)
                  throw new Hm({
                      body: m,
                      error: b,
                      url: c
                  });
              return w
          },
          retryCount: u,
          retryDelay: i,
          timeout: l,
          type: "webSocket"
      }, {
          getSocket() {
              return Yf(c)
          },
          async subscribe({params: d, onData: y, onError: m}) {
              const v = await Yf(c)
                , {result: b} = await new Promise( (w, h) => rs.webSocket(v, {
                  body: {
                      method: "eth_subscribe",
                      params: d
                  },
                  onResponse(g) {
                      if (g.error) {
                          h(g.error),
                          m == null || m(g.error);
                          return
                      }
                      if (typeof g.id == "number") {
                          w(g);
                          return
                      }
                      g.method === "eth_subscription" && y(g.params)
                  }
              }));
              return {
                  subscriptionId: b,
                  async unsubscribe() {
                      return new Promise(w => rs.webSocket(v, {
                          body: {
                              method: "eth_unsubscribe",
                              params: [b]
                          },
                          onResponse: w
                      }))
                  }
              }
          }
      })
  }
}
const lO = M2({
  id: 5,
  network: "goerli",
  name: "Goerli",
  nativeCurrency: {
      name: "Goerli Ether",
      symbol: "ETH",
      decimals: 18
  },
  rpcUrls: {
      alchemy: {
          http: ["https://eth-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
      },
      infura: {
          http: ["https://goerli.infura.io/v3"],
          webSocket: ["wss://goerli.infura.io/ws/v3"]
      },
      default: {
          http: ["https://rpc.ankr.com/eth_goerli"]
      },
      public: {
          http: ["https://rpc.ankr.com/eth_goerli"]
      }
  },
  blockExplorers: {
      etherscan: {
          name: "Etherscan",
          url: "https://goerli.etherscan.io"
      },
      default: {
          name: "Etherscan",
          url: "https://goerli.etherscan.io"
      }
  },
  contracts: {
      ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      ensUniversalResolver: {
          address: "0x56522D00C410a43BFfDF00a9A569489297385790",
          blockCreated: 8765204
      },
      multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 6507670
      }
  },
  testnet: !0
})
, jx = M2({
  id: 1,
  network: "homestead",
  name: "Ethereum",
  nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
  },
  rpcUrls: {
      alchemy: {
          http: ["https://eth-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
      },
      infura: {
          http: ["https://mainnet.infura.io/v3"],
          webSocket: ["wss://mainnet.infura.io/ws/v3"]
      },
      default: {
          http: ["https://cloudflare-eth.com"]
      },
      public: {
          http: ["https://cloudflare-eth.com"]
      }
  },
  blockExplorers: {
      etherscan: {
          name: "Etherscan",
          url: "https://etherscan.io"
      },
      default: {
          name: "Etherscan",
          url: "https://etherscan.io"
      }
  },
  contracts: {
      ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      ensUniversalResolver: {
          address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
          blockCreated: 16966585
      },
      multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 14353601
      }
  }
});
var cO = class extends Error {
  constructor({chainId: e, connectorId: t}) {
      super(`Chain "${e}" not configured for connector "${t}".`),
      this.name = "ChainNotConfiguredForConnectorError"
  }
}
, jn = class extends Error {
  constructor() {
      super(...arguments),
      this.name = "ConnectorNotFoundError",
      this.message = "Connector not found"
  }
}
;
function j0(e) {
  return typeof e == "string" ? Number.parseInt(e, e.trim().substring(0, 2) === "0x" ? 16 : 10) : typeof e == "bigint" ? Number(e) : e
}
var Mx = {
  exports: {}
};
(function(e) {
  var t = Object.prototype.hasOwnProperty
    , n = "~";
  function r() {}
  Object.create && (r.prototype = Object.create(null),
  new r().__proto__ || (n = !1));
  function i(u, l, c) {
      this.fn = u,
      this.context = l,
      this.once = c || !1
  }
  function s(u, l, c, f, d) {
      if (typeof c != "function")
          throw new TypeError("The listener must be a function");
      var y = new i(c,f || u,d)
        , m = n ? n + l : l;
      return u._events[m] ? u._events[m].fn ? u._events[m] = [u._events[m], y] : u._events[m].push(y) : (u._events[m] = y,
      u._eventsCount++),
      u
  }
  function a(u, l) {
      --u._eventsCount === 0 ? u._events = new r : delete u._events[l]
  }
  function o() {
      this._events = new r,
      this._eventsCount = 0
  }
  o.prototype.eventNames = function() {
      var l = [], c, f;
      if (this._eventsCount === 0)
          return l;
      for (f in c = this._events)
          t.call(c, f) && l.push(n ? f.slice(1) : f);
      return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(c)) : l
  }
  ,
  o.prototype.listeners = function(l) {
      var c = n ? n + l : l
        , f = this._events[c];
      if (!f)
          return [];
      if (f.fn)
          return [f.fn];
      for (var d = 0, y = f.length, m = new Array(y); d < y; d++)
          m[d] = f[d].fn;
      return m
  }
  ,
  o.prototype.listenerCount = function(l) {
      var c = n ? n + l : l
        , f = this._events[c];
      return f ? f.fn ? 1 : f.length : 0
  }
  ,
  o.prototype.emit = function(l, c, f, d, y, m) {
      var v = n ? n + l : l;
      if (!this._events[v])
          return !1;
      var b = this._events[v], w = arguments.length, h, g;
      if (b.fn) {
          switch (b.once && this.removeListener(l, b.fn, void 0, !0),
          w) {
          case 1:
              return b.fn.call(b.context),
              !0;
          case 2:
              return b.fn.call(b.context, c),
              !0;
          case 3:
              return b.fn.call(b.context, c, f),
              !0;
          case 4:
              return b.fn.call(b.context, c, f, d),
              !0;
          case 5:
              return b.fn.call(b.context, c, f, d, y),
              !0;
          case 6:
              return b.fn.call(b.context, c, f, d, y, m),
              !0
          }
          for (g = 1,
          h = new Array(w - 1); g < w; g++)
              h[g - 1] = arguments[g];
          b.fn.apply(b.context, h)
      } else {
          var x = b.length, S;
          for (g = 0; g < x; g++)
              switch (b[g].once && this.removeListener(l, b[g].fn, void 0, !0),
              w) {
              case 1:
                  b[g].fn.call(b[g].context);
                  break;
              case 2:
                  b[g].fn.call(b[g].context, c);
                  break;
              case 3:
                  b[g].fn.call(b[g].context, c, f);
                  break;
              case 4:
                  b[g].fn.call(b[g].context, c, f, d);
                  break;
              default:
                  if (!h)
                      for (S = 1,
                      h = new Array(w - 1); S < w; S++)
                          h[S - 1] = arguments[S];
                  b[g].fn.apply(b[g].context, h)
              }
      }
      return !0
  }
  ,
  o.prototype.on = function(l, c, f) {
      return s(this, l, c, f, !1)
  }
  ,
  o.prototype.once = function(l, c, f) {
      return s(this, l, c, f, !0)
  }
  ,
  o.prototype.removeListener = function(l, c, f, d) {
      var y = n ? n + l : l;
      if (!this._events[y])
          return this;
      if (!c)
          return a(this, y),
          this;
      var m = this._events[y];
      if (m.fn)
          m.fn === c && (!d || m.once) && (!f || m.context === f) && a(this, y);
      else {
          for (var v = 0, b = [], w = m.length; v < w; v++)
              (m[v].fn !== c || d && !m[v].once || f && m[v].context !== f) && b.push(m[v]);
          b.length ? this._events[y] = b.length === 1 ? b[0] : b : a(this, y)
      }
      return this
  }
  ,
  o.prototype.removeAllListeners = function(l) {
      var c;
      return l ? (c = n ? n + l : l,
      this._events[c] && a(this, c)) : (this._events = new r,
      this._eventsCount = 0),
      this
  }
  ,
  o.prototype.off = o.prototype.removeListener,
  o.prototype.addListener = o.prototype.on,
  o.prefixed = n,
  o.EventEmitter = o,
  e.exports = o
}
)(Mx);
var fO = Mx.exports;
const dO = gi(fO);
var iy = (e, t, n) => {
  if (!t.has(e))
      throw TypeError("Cannot " + n)
}
, Pe = (e, t, n) => (iy(e, t, "read from private field"),
n ? n.call(e) : t.get(e))
, Vt = (e, t, n) => {
  if (t.has(e))
      throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n)
}
, sy = (e, t, n, r) => (iy(e, t, "write to private field"),
r ? r.call(e, n) : t.set(e, n),
n)
, Qe = (e, t, n) => (iy(e, t, "access private method"),
n)
, Lx = class extends dO {
  constructor({chains: t=[jx, lO], options: n}) {
      super(),
      this.chains = t,
      this.options = n
  }
  getBlockExplorerUrls(t) {
      const {default: n, ...r} = t.blockExplorers ?? {};
      if (n)
          return [n.url, ...Object.values(r).map(i => i.url)]
  }
  isChainUnsupported(t) {
      return !this.chains.some(n => n.id === t)
  }
  setStorage(t) {
      this.storage = t
  }
}
;
function pO(e) {
  var n;
  if (!e)
      return "Injected";
  const t = r => {
      if (r.isApexWallet)
          return "Apex Wallet";
      if (r.isAvalanche)
          return "Core Wallet";
      if (r.isBackpack)
          return "Backpack";
      if (r.isBifrost)
          return "Bifrost Wallet";
      if (r.isBitKeep)
          return "BitKeep";
      if (r.isBitski)
          return "Bitski";
      if (r.isBlockWallet)
          return "BlockWallet";
      if (r.isBraveWallet)
          return "Brave Wallet";
      if (r.isCoin98)
          return "Coin98 Wallet";
      if (r.isCoinbaseWallet)
          return "Coinbase Wallet";
      if (r.isDawn)
          return "Dawn Wallet";
      if (r.isDefiant)
          return "Defiant";
      if (r.isDesig)
          return "Desig Wallet";
      if (r.isEnkrypt)
          return "Enkrypt";
      if (r.isExodus)
          return "Exodus";
      if (r.isFordefi)
          return "Fordefi";
      if (r.isFrame)
          return "Frame";
      if (r.isFrontier)
          return "Frontier Wallet";
      if (r.isGamestop)
          return "GameStop Wallet";
      if (r.isHaqqWallet)
          return "HAQQ Wallet";
      if (r.isHyperPay)
          return "HyperPay Wallet";
      if (r.isImToken)
          return "ImToken";
      if (r.isHaloWallet)
          return "Halo Wallet";
      if (r.isKuCoinWallet)
          return "KuCoin Wallet";
      if (r.isMathWallet)
          return "MathWallet";
      if (r.isNovaWallet)
          return "Nova Wallet";
      if (r.isOkxWallet || r.isOKExWallet)
          return "OKX Wallet";
      if (r.isOktoWallet)
          return "Okto Wallet";
      if (r.isOneInchIOSWallet || r.isOneInchAndroidWallet)
          return "1inch Wallet";
      if (r.isOneKey)
          return "OneKey Wallet";
      if (r.isOpera)
          return "Opera";
      if (r.isPhantom)
          return "Phantom";
      if (r.isPortal)
          return "Ripio Portal";
      if (r.isRabby)
          return "Rabby Wallet";
      if (r.isRainbow)
          return "Rainbow";
      if (r.isSafePal)
          return "SafePal Wallet";
      if (r.isStatus)
          return "Status";
      if (r.isSubWallet)
          return "SubWallet";
      if (r.isTalisman)
          return "Talisman";
      if (r.isTally)
          return "Taho";
      if (r.isTokenPocket)
          return "TokenPocket";
      if (r.isTokenary)
          return "Tokenary";
      if (r.isTrust || r.isTrustWallet)
          return "Trust Wallet";
      if (r.isTTWallet)
          return "TTWallet";
      if (r.isXDEFI)
          return "XDEFI Wallet";
      if (r.isZeal)
          return "Zeal";
      if (r.isZerion)
          return "Zerion";
      if (r.isMetaMask)
          return "MetaMask"
  }
  ;
  if ((n = e.providers) != null && n.length) {
      const r = new Set;
      let i = 1;
      for (const a of e.providers) {
          let o = t(a);
          o || (o = `Unknown Wallet #${i}`,
          i += 1),
          r.add(o)
      }
      const s = [...r];
      return s.length ? s : s[0] ?? "Injected"
  }
  return t(e) ?? "Injected"
}
var Mu, Fx = class extends Lx {
  constructor({chains: e, options: t}={}) {
      const n = {
          shimDisconnect: !0,
          getProvider() {
              if (typeof window > "u")
                  return;
              const i = window.ethereum;
              return i != null && i.providers && i.providers.length > 0 ? i.providers[0] : i
          },
          ...t
      };
      super({
          chains: e,
          options: n
      }),
      this.id = "injected",
      Vt(this, Mu, void 0),
      this.shimDisconnectKey = `${this.id}.shimDisconnect`,
      this.onAccountsChanged = i => {
          i.length === 0 ? this.emit("disconnect") : this.emit("change", {
              account: Tr(i[0])
          })
      }
      ,
      this.onChainChanged = i => {
          const s = j0(i)
            , a = this.isChainUnsupported(s);
          this.emit("change", {
              chain: {
                  id: s,
                  unsupported: a
              }
          })
      }
      ,
      this.onDisconnect = async i => {
          var s;
          i.code === 1013 && await this.getProvider() && await this.getAccount() || (this.emit("disconnect"),
          this.options.shimDisconnect && ((s = this.storage) == null || s.removeItem(this.shimDisconnectKey)))
      }
      ;
      const r = n.getProvider();
      if (typeof n.name == "string")
          this.name = n.name;
      else if (r) {
          const i = pO(r);
          n.name ? this.name = n.name(i) : typeof i == "string" ? this.name = i : this.name = i[0]
      } else
          this.name = "Injected";
      this.ready = !!r
  }
  async connect({chainId: e}={}) {
      var t;
      try {
          const n = await this.getProvider();
          if (!n)
              throw new jn;
          n.on && (n.on("accountsChanged", this.onAccountsChanged),
          n.on("chainChanged", this.onChainChanged),
          n.on("disconnect", this.onDisconnect)),
          this.emit("message", {
              type: "connecting"
          });
          const r = await n.request({
              method: "eth_requestAccounts"
          })
            , i = Tr(r[0]);
          let s = await this.getChainId()
            , a = this.isChainUnsupported(s);
          return e && s !== e && (s = (await this.switchChain(e)).id,
          a = this.isChainUnsupported(s)),
          this.options.shimDisconnect && ((t = this.storage) == null || t.setItem(this.shimDisconnectKey, !0)),
          {
              account: i,
              chain: {
                  id: s,
                  unsupported: a
              }
          }
      } catch (n) {
          throw this.isUserRejectedRequestError(n) ? new Jt(n) : n.code === -32002 ? new ps(n) : n
      }
  }
  async disconnect() {
      var t;
      const e = await this.getProvider();
      e != null && e.removeListener && (e.removeListener("accountsChanged", this.onAccountsChanged),
      e.removeListener("chainChanged", this.onChainChanged),
      e.removeListener("disconnect", this.onDisconnect),
      this.options.shimDisconnect && ((t = this.storage) == null || t.removeItem(this.shimDisconnectKey)))
  }
  async getAccount() {
      const e = await this.getProvider();
      if (!e)
          throw new jn;
      const t = await e.request({
          method: "eth_accounts"
      });
      return Tr(t[0])
  }
  async getChainId() {
      const e = await this.getProvider();
      if (!e)
          throw new jn;
      return e.request({
          method: "eth_chainId"
      }).then(j0)
  }
  async getProvider() {
      const e = this.options.getProvider();
      return e && sy(this, Mu, e),
      Pe(this, Mu)
  }
  async getWalletClient({chainId: e}={}) {
      const [t,n] = await Promise.all([this.getProvider(), this.getAccount()])
        , r = this.chains.find(i => i.id === e);
      if (!t)
          throw new Error("provider is required.");
      return Nx({
          account: n,
          chain: r,
          transport: gx(t)
      })
  }
  async isAuthorized() {
      var e;
      try {
          if (this.options.shimDisconnect && !((e = this.storage) != null && e.getItem(this.shimDisconnectKey)))
              return !1;
          if (!await this.getProvider())
              throw new jn;
          return !!await this.getAccount()
      } catch {
          return !1
      }
  }
  async switchChain(e) {
      var r, i, s;
      const t = await this.getProvider();
      if (!t)
          throw new jn;
      const n = ie(e);
      try {
          return await Promise.all([t.request({
              method: "wallet_switchEthereumChain",
              params: [{
                  chainId: n
              }]
          }), new Promise(a => this.on("change", ({chain: o}) => {
              (o == null ? void 0 : o.id) === e && a()
          }
          ))]),
          this.chains.find(a => a.id === e) ?? {
              id: e,
              name: `Chain ${n}`,
              network: `${n}`,
              nativeCurrency: {
                  name: "Ether",
                  decimals: 18,
                  symbol: "ETH"
              },
              rpcUrls: {
                  default: {
                      http: [""]
                  },
                  public: {
                      http: [""]
                  }
              }
          }
      } catch (a) {
          const o = this.chains.find(u => u.id === e);
          if (!o)
              throw new cO({
                  chainId: e,
                  connectorId: this.id
              });
          if (a.code === 4902 || ((i = (r = a == null ? void 0 : a.data) == null ? void 0 : r.originalError) == null ? void 0 : i.code) === 4902)
              try {
                  if (await t.request({
                      method: "wallet_addEthereumChain",
                      params: [{
                          chainId: n,
                          chainName: o.name,
                          nativeCurrency: o.nativeCurrency,
                          rpcUrls: [((s = o.rpcUrls.public) == null ? void 0 : s.http[0]) ?? ""],
                          blockExplorerUrls: this.getBlockExplorerUrls(o)
                      }]
                  }),
                  await this.getChainId() !== e)
                      throw new Jt(new Error("User rejected switch after adding network."));
                  return o
              } catch (u) {
                  throw new Jt(u)
              }
          throw this.isUserRejectedRequestError(a) ? new Jt(a) : new Nr(a)
      }
  }
  async watchAsset({address: e, decimals: t=18, image: n, symbol: r}) {
      const i = await this.getProvider();
      if (!i)
          throw new jn;
      return i.request({
          method: "wallet_watchAsset",
          params: {
              type: "ERC20",
              options: {
                  address: e,
                  decimals: t,
                  image: n,
                  symbol: r
              }
          }
      })
  }
  isUserRejectedRequestError(e) {
      return e.code === 4001
  }
}
;
Mu = new WeakMap;
var ay = (e, t, n) => {
  if (!t.has(e))
      throw TypeError("Cannot " + n)
}
, Jf = (e, t, n) => (ay(e, t, "read from private field"),
n ? n.call(e) : t.get(e))
, Zf = (e, t, n) => {
  if (t.has(e))
      throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n)
}
, au = (e, t, n, r) => (ay(e, t, "write to private field"),
r ? r.call(e, n) : t.set(e, n),
n)
, hO = (e, t, n) => (ay(e, t, "access private method"),
n)
, mO = {
  VITE_PROJECT_ID: "f4686537b0b93c1046822fa05ee9cd6b",
  VITE_INFURA_KEY_TEST: "8060915499804bc1824877fa4a120d56",
  VITE_INFURA_KEY: "b6b73456fee04e7882dd2115e4116860",
  BASE_URL: "/",
  MODE: "production",
  DEV: !1,
  PROD: !0,
  SSR: !1
};
const yO = e => (t, n, r) => {
  const i = r.subscribe;
  return r.subscribe = (a, o, u) => {
      let l = a;
      if (o) {
          const c = (u == null ? void 0 : u.equalityFn) || Object.is;
          let f = a(r.getState());
          l = d => {
              const y = a(d);
              if (!c(f, y)) {
                  const m = f;
                  o(f = y, m)
              }
          }
          ,
          u != null && u.fireImmediately && o(f, f)
      }
      return i(l)
  }
  ,
  e(t, n, r)
}
, gO = yO;
function vO(e, t) {
  let n;
  try {
      n = e()
  } catch {
      return
  }
  return {
      getItem: i => {
          var s;
          const a = u => u === null ? null : JSON.parse(u, t == null ? void 0 : t.reviver)
            , o = (s = n.getItem(i)) != null ? s : null;
          return o instanceof Promise ? o.then(a) : a(o)
      }
      ,
      setItem: (i, s) => n.setItem(i, JSON.stringify(s, t == null ? void 0 : t.replacer)),
      removeItem: i => n.removeItem(i)
  }
}
const Ya = e => t => {
  try {
      const n = e(t);
      return n instanceof Promise ? n : {
          then(r) {
              return Ya(r)(n)
          },
          catch(r) {
              return this
          }
      }
  } catch (n) {
      return {
          then(r) {
              return this
          },
          catch(r) {
              return Ya(r)(n)
          }
      }
  }
}
, wO = (e, t) => (n, r, i) => {
  let s = {
      getStorage: () => localStorage,
      serialize: JSON.stringify,
      deserialize: JSON.parse,
      partialize: b => b,
      version: 0,
      merge: (b, w) => ({
          ...w,
          ...b
      }),
      ...t
  }
    , a = !1;
  const o = new Set
    , u = new Set;
  let l;
  try {
      l = s.getStorage()
  } catch {}
  if (!l)
      return e( (...b) => {
          console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),
          n(...b)
      }
      , r, i);
  const c = Ya(s.serialize)
    , f = () => {
      const b = s.partialize({
          ...r()
      });
      let w;
      const h = c({
          state: b,
          version: s.version
      }).then(g => l.setItem(s.name, g)).catch(g => {
          w = g
      }
      );
      if (w)
          throw w;
      return h
  }
    , d = i.setState;
  i.setState = (b, w) => {
      d(b, w),
      f()
  }
  ;
  const y = e( (...b) => {
      n(...b),
      f()
  }
  , r, i);
  let m;
  const v = () => {
      var b;
      if (!l)
          return;
      a = !1,
      o.forEach(h => h(r()));
      const w = ((b = s.onRehydrateStorage) == null ? void 0 : b.call(s, r())) || void 0;
      return Ya(l.getItem.bind(l))(s.name).then(h => {
          if (h)
              return s.deserialize(h)
      }
      ).then(h => {
          if (h)
              if (typeof h.version == "number" && h.version !== s.version) {
                  if (s.migrate)
                      return s.migrate(h.state, h.version);
                  console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
              } else
                  return h.state
      }
      ).then(h => {
          var g;
          return m = s.merge(h, (g = r()) != null ? g : y),
          n(m, !0),
          f()
      }
      ).then( () => {
          w == null || w(m, void 0),
          a = !0,
          u.forEach(h => h(m))
      }
      ).catch(h => {
          w == null || w(void 0, h)
      }
      )
  }
  ;
  return i.persist = {
      setOptions: b => {
          s = {
              ...s,
              ...b
          },
          b.getStorage && (l = b.getStorage())
      }
      ,
      clearStorage: () => {
          l == null || l.removeItem(s.name)
      }
      ,
      getOptions: () => s,
      rehydrate: () => v(),
      hasHydrated: () => a,
      onHydrate: b => (o.add(b),
      () => {
          o.delete(b)
      }
      ),
      onFinishHydration: b => (u.add(b),
      () => {
          u.delete(b)
      }
      )
  },
  v(),
  m || y
}
, bO = (e, t) => (n, r, i) => {
  let s = {
      storage: vO( () => localStorage),
      partialize: v => v,
      version: 0,
      merge: (v, b) => ({
          ...b,
          ...v
      }),
      ...t
  }
    , a = !1;
  const o = new Set
    , u = new Set;
  let l = s.storage;
  if (!l)
      return e( (...v) => {
          console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),
          n(...v)
      }
      , r, i);
  const c = () => {
      const v = s.partialize({
          ...r()
      });
      return l.setItem(s.name, {
          state: v,
          version: s.version
      })
  }
    , f = i.setState;
  i.setState = (v, b) => {
      f(v, b),
      c()
  }
  ;
  const d = e( (...v) => {
      n(...v),
      c()
  }
  , r, i);
  let y;
  const m = () => {
      var v, b;
      if (!l)
          return;
      a = !1,
      o.forEach(h => {
          var g;
          return h((g = r()) != null ? g : d)
      }
      );
      const w = ((b = s.onRehydrateStorage) == null ? void 0 : b.call(s, (v = r()) != null ? v : d)) || void 0;
      return Ya(l.getItem.bind(l))(s.name).then(h => {
          if (h)
              if (typeof h.version == "number" && h.version !== s.version) {
                  if (s.migrate)
                      return s.migrate(h.state, h.version);
                  console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
              } else
                  return h.state
      }
      ).then(h => {
          var g;
          return y = s.merge(h, (g = r()) != null ? g : d),
          n(y, !0),
          c()
      }
      ).then( () => {
          w == null || w(y, void 0),
          y = r(),
          a = !0,
          u.forEach(h => h(y))
      }
      ).catch(h => {
          w == null || w(void 0, h)
      }
      )
  }
  ;
  return i.persist = {
      setOptions: v => {
          s = {
              ...s,
              ...v
          },
          v.storage && (l = v.storage)
      }
      ,
      clearStorage: () => {
          l == null || l.removeItem(s.name)
      }
      ,
      getOptions: () => s,
      rehydrate: () => m(),
      hasHydrated: () => a,
      onHydrate: v => (o.add(v),
      () => {
          o.delete(v)
      }
      ),
      onFinishHydration: v => (u.add(v),
      () => {
          u.delete(v)
      }
      )
  },
  s.skipHydration || m(),
  y || d
}
, xO = (e, t) => "getStorage"in t || "serialize"in t || "deserialize"in t ? ((mO ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),
wO(e, t)) : bO(e, t)
, EO = xO;
var SO = {
  VITE_PROJECT_ID: "f4686537b0b93c1046822fa05ee9cd6b",
  VITE_INFURA_KEY_TEST: "8060915499804bc1824877fa4a120d56",
  VITE_INFURA_KEY: "b6b73456fee04e7882dd2115e4116860",
  BASE_URL: "/",
  MODE: "production",
  DEV: !1,
  PROD: !0,
  SSR: !1
};
const M0 = e => {
  let t;
  const n = new Set
    , r = (u, l) => {
      const c = typeof u == "function" ? u(t) : u;
      if (!Object.is(c, t)) {
          const f = t;
          t = l ?? (typeof c != "object" || c === null) ? c : Object.assign({}, t, c),
          n.forEach(d => d(t, f))
      }
  }
    , i = () => t
    , o = {
      setState: r,
      getState: i,
      subscribe: u => (n.add(u),
      () => n.delete(u)),
      destroy: () => {
          (SO ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),
          n.clear()
      }
  };
  return t = e(r, i, o),
  o
}
, CO = e => e ? M0(e) : M0;
function Ux(e, t) {
  if (Object.is(e, t))
      return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
      return !1;
  if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
          return !1;
      for (const [r,i] of e)
          if (!Object.is(i, t.get(r)))
              return !1;
      return !0
  }
  if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
          return !1;
      for (const r of e)
          if (!t.has(r))
              return !1;
      return !0
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
      return !1;
  for (let r = 0; r < n.length; r++)
      if (!Object.prototype.hasOwnProperty.call(t, n[r]) || !Object.is(e[n[r]], t[n[r]]))
          return !1;
  return !0
}
function _O(e, t, {batch: n={
  multicall: {
      wait: 32
  }
}, pollingInterval: r=4e3, rank: i, retryCount: s, retryDelay: a, stallTimeout: o}={}) {
  if (!e.length)
      throw new Error("must have at least one chain");
  let u = [];
  const l = {}
    , c = {};
  for (const f of e) {
      let d = !1;
      for (const y of t) {
          const m = y(f);
          m && (d = !0,
          u.some( ({id: v}) => v === f.id) || (u = [...u, m.chain]),
          l[f.id] = [...l[f.id] || [], ...m.rpcUrls.http],
          m.rpcUrls.webSocket && (c[f.id] = [...c[f.id] || [], ...m.rpcUrls.webSocket]))
      }
      if (!d)
          throw new Error([`Could not find valid provider configuration for chain "${f.name}".
`, "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.", "Read more: https://wagmi.sh/core/providers/jsonRpc"].join(`
`))
  }
  return {
      chains: u,
      publicClient: ({chainId: f}) => {
          const d = u.find(v => v.id === f) ?? e[0]
            , y = l[d.id];
          if (!y || !y[0])
              throw new Error(`No providers configured for chain "${d.id}"`);
          const m = N0({
              batch: n,
              chain: d,
              transport: A0(y.map(v => tT(v, {
                  timeout: o
              })), {
                  rank: i,
                  retryCount: s,
                  retryDelay: a
              }),
              pollingInterval: r
          });
          return Object.assign(m, {
              chains: u
          })
      }
      ,
      webSocketPublicClient: ({chainId: f}) => {
          const d = u.find(v => v.id === f) ?? e[0]
            , y = c[d.id];
          if (!y || !y[0])
              return;
          const m = N0({
              batch: n,
              chain: d,
              transport: A0(y.map(v => uO(v, {
                  timeout: o
              })), {
                  rank: i,
                  retryCount: s,
                  retryDelay: a
              }),
              pollingInterval: r
          });
          return Object.assign(m, {
              chains: u
          })
      }
  }
}
var PO = class extends Error {
  constructor({activeChain: e, targetChain: t}) {
      super(`Chain mismatch: Expected "${t}", received "${e}".`),
      this.name = "ChainMismatchError"
  }
}
, TO = class extends Error {
  constructor({chainId: e, connectorId: t}) {
      super(`Chain "${e}" not configured${t ? ` for connector "${t}"` : ""}.`),
      this.name = "ChainNotConfigured"
  }
}
, OO = class extends Error {
  constructor() {
      super(...arguments),
      this.name = "ConnectorAlreadyConnectedError",
      this.message = "Connector already connected"
  }
}
, kO = class extends Error {
  constructor() {
      super(...arguments),
      this.name = "ConfigChainsNotFound",
      this.message = "No chains were found on the wagmi config. Some functions that require a chain may not work."
  }
}
, DO = class extends Error {
  constructor({connector: e}) {
      super(`"${e.name}" does not support programmatic chain switching.`),
      this.name = "SwitchChainNotSupportedError"
  }
}
;
function Xa(e, t) {
  if (e === t)
      return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
      if (e.constructor !== t.constructor)
          return !1;
      let n, r;
      if (Array.isArray(e) && Array.isArray(t)) {
          if (n = e.length,
          n != t.length)
              return !1;
          for (r = n; r-- !== 0; )
              if (!Xa(e[r], t[r]))
                  return !1;
          return !0
      }
      if (e.valueOf !== Object.prototype.valueOf)
          return e.valueOf() === t.valueOf();
      if (e.toString !== Object.prototype.toString)
          return e.toString() === t.toString();
      const i = Object.keys(e);
      if (n = i.length,
      n !== Object.keys(t).length)
          return !1;
      for (r = n; r-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(t, i[r]))
              return !1;
      for (r = n; r-- !== 0; ) {
          const s = i[r];
          if (s && !Xa(e[s], t[s]))
              return !1
      }
      return !0
  }
  return e !== e && t !== t
}
var Up = (e, {find: t, replace: n}) => e && t(e) ? n(e) : typeof e != "object" ? e : Array.isArray(e) ? e.map(r => Up(r, {
  find: t,
  replace: n
})) : e instanceof Object ? Object.entries(e).reduce( (r, [i,s]) => ({
  ...r,
  [i]: Up(s, {
      find: t,
      replace: n
  })
}), {}) : e;
function IO(e) {
  const t = JSON.parse(e);
  return Up(t, {
      find: r => typeof r == "string" && r.startsWith("#bigint."),
      replace: r => BigInt(r.replace("#bigint.", ""))
  })
}
function AO(e) {
  return {
      accessList: e.accessList,
      account: e.account,
      blockNumber: e.blockNumber,
      blockTag: e.blockTag,
      data: e.data,
      gas: e.gas,
      gasPrice: e.gasPrice,
      maxFeePerGas: e.maxFeePerGas,
      maxPriorityFeePerGas: e.maxPriorityFeePerGas,
      nonce: e.nonce,
      to: e.to,
      value: e.value
  }
}
function $O(e) {
  return {
      accessList: e.accessList,
      account: e.account,
      data: e.data,
      gas: e.gas,
      gasPrice: e.gasPrice,
      maxFeePerGas: e.maxFeePerGas,
      maxPriorityFeePerGas: e.maxPriorityFeePerGas,
      nonce: e.nonce,
      to: e.to,
      value: e.value
  }
}
function L0(e) {
  return typeof e == "number" ? e : e === "wei" ? 0 : Math.abs(Y_[e])
}
function F0(e, t) {
  return e.slice(0, t).join(".") || "."
}
function U0(e, t) {
  const {length: n} = e;
  for (let r = 0; r < n; ++r)
      if (e[r] === t)
          return r + 1;
  return 0
}
function RO(e, t) {
  const n = typeof e == "function"
    , r = typeof t == "function"
    , i = []
    , s = [];
  return function(o, u) {
      if (typeof u == "object")
          if (i.length) {
              const l = U0(i, this);
              l === 0 ? i[i.length] = this : (i.splice(l),
              s.splice(l)),
              s[s.length] = o;
              const c = U0(i, u);
              if (c !== 0)
                  return r ? t.call(this, o, u, F0(s, c)) : `[ref=${F0(s, c)}]`
          } else
              i[0] = u,
              s[0] = o;
      return n ? e.call(this, o, u) : u
  }
}
function NO(e, t, n, r) {
  return JSON.stringify(e, RO( (i, s) => {
      const a = typeof s == "bigint" ? `#bigint.${s.toString()}` : s;
      return (t == null ? void 0 : t(i, a)) || a
  }
  , r), n ?? void 0)
}
var zx = {
  getItem: e => "",
  setItem: (e, t) => null,
  removeItem: e => null
};
function Bx({deserialize: e=IO, key: t="wagmi", serialize: n=NO, storage: r}) {
  return {
      ...r,
      getItem: (i, s=null) => {
          const a = r.getItem(`${t}.${i}`);
          try {
              return a ? e(a) : s
          } catch (o) {
              return console.warn(o),
              s
          }
      }
      ,
      setItem: (i, s) => {
          if (s === null)
              r.removeItem(`${t}.${i}`);
          else
              try {
                  r.setItem(`${t}.${i}`, n(s))
              } catch (a) {
                  console.error(a)
              }
      }
      ,
      removeItem: i => r.removeItem(`${t}.${i}`)
  }
}
var z0 = "store", Ai, ta, zp, Wx, jO = class {
  constructor({autoConnect: e=!1, connectors: t=[new Fx], publicClient: n, storage: r=Bx({
      storage: typeof window < "u" ? window.localStorage : zx
  }), logger: i={
      warn: console.warn
  }, webSocketPublicClient: s}) {
      var l, c;
      Zf(this, zp),
      this.publicClients = new Map,
      this.webSocketPublicClients = new Map,
      Zf(this, Ai, void 0),
      Zf(this, ta, void 0),
      this.args = {
          autoConnect: e,
          connectors: t,
          logger: i,
          publicClient: n,
          storage: r,
          webSocketPublicClient: s
      };
      let a = "disconnected", o;
      if (e)
          try {
              const f = r.getItem(z0)
                , d = (l = f == null ? void 0 : f.state) == null ? void 0 : l.data;
              a = d != null && d.account ? "reconnecting" : "connecting",
              o = (c = d == null ? void 0 : d.chain) == null ? void 0 : c.id
          } catch {}
      const u = typeof t == "function" ? t() : t;
      u.forEach(f => f.setStorage(r)),
      this.store = CO(gO(EO( () => ({
          connectors: u,
          publicClient: this.getPublicClient({
              chainId: o
          }),
          status: a,
          webSocketPublicClient: this.getWebSocketPublicClient({
              chainId: o
          })
      }), {
          name: z0,
          storage: r,
          partialize: f => {
              var d, y;
              return {
                  ...e && {
                      data: {
                          account: (d = f == null ? void 0 : f.data) == null ? void 0 : d.account,
                          chain: (y = f == null ? void 0 : f.data) == null ? void 0 : y.chain
                      }
                  },
                  chains: f == null ? void 0 : f.chains
              }
          }
          ,
          version: 2
      }))),
      this.storage = r,
      au(this, ta, r == null ? void 0 : r.getItem("wallet")),
      hO(this, zp, Wx).call(this),
      e && typeof window < "u" && setTimeout(async () => await this.autoConnect(), 0)
  }
  get chains() {
      return this.store.getState().chains
  }
  get connectors() {
      return this.store.getState().connectors
  }
  get connector() {
      return this.store.getState().connector
  }
  get data() {
      return this.store.getState().data
  }
  get error() {
      return this.store.getState().error
  }
  get lastUsedChainId() {
      var e, t;
      return (t = (e = this.data) == null ? void 0 : e.chain) == null ? void 0 : t.id
  }
  get publicClient() {
      return this.store.getState().publicClient
  }
  get status() {
      return this.store.getState().status
  }
  get subscribe() {
      return this.store.subscribe
  }
  get webSocketPublicClient() {
      return this.store.getState().webSocketPublicClient
  }
  setState(e) {
      const t = typeof e == "function" ? e(this.store.getState()) : e;
      this.store.setState(t, !0)
  }
  clearState() {
      this.setState(e => ({
          ...e,
          chains: void 0,
          connector: void 0,
          data: void 0,
          error: void 0,
          status: "disconnected"
      }))
  }
  async destroy() {
      var e, t;
      this.connector && await ((t = (e = this.connector).disconnect) == null ? void 0 : t.call(e)),
      au(this, Ai, !1),
      this.clearState(),
      this.store.destroy()
  }
  async autoConnect() {
      if (Jf(this, Ai))
          return;
      au(this, Ai, !0),
      this.setState(n => {
          var r;
          return {
              ...n,
              status: (r = n.data) != null && r.account ? "reconnecting" : "connecting"
          }
      }
      );
      const e = Jf(this, ta) ? [...this.connectors].sort(n => n.id === Jf(this, ta) ? -1 : 1) : this.connectors;
      let t = !1;
      for (const n of e) {
          if (!n.ready || !n.isAuthorized || !await n.isAuthorized())
              continue;
          const i = await n.connect();
          this.setState(s => ({
              ...s,
              connector: n,
              chains: n == null ? void 0 : n.chains,
              data: i,
              status: "connected"
          })),
          t = !0;
          break
      }
      return t || this.setState(n => ({
          ...n,
          data: void 0,
          status: "disconnected"
      })),
      au(this, Ai, !1),
      this.data
  }
  setConnectors(e) {
      this.args = {
          ...this.args,
          connectors: e
      };
      const t = typeof e == "function" ? e() : e;
      t.forEach(n => n.setStorage(this.args.storage)),
      this.setState(n => ({
          ...n,
          connectors: t
      }))
  }
  getPublicClient({chainId: e}={}) {
      let t = this.publicClients.get(-1);
      if (t && (t == null ? void 0 : t.chain.id) === e || (t = this.publicClients.get(e ?? -1),
      t))
          return t;
      const {publicClient: n} = this.args;
      return t = typeof n == "function" ? n({
          chainId: e
      }) : n,
      this.publicClients.set(e ?? -1, t),
      t
  }
  setPublicClient(e) {
      var n, r;
      const t = (r = (n = this.data) == null ? void 0 : n.chain) == null ? void 0 : r.id;
      this.args = {
          ...this.args,
          publicClient: e
      },
      this.publicClients.clear(),
      this.setState(i => ({
          ...i,
          publicClient: this.getPublicClient({
              chainId: t
          })
      }))
  }
  getWebSocketPublicClient({chainId: e}={}) {
      let t = this.webSocketPublicClients.get(-1);
      if (t && (t == null ? void 0 : t.chain.id) === e || (t = this.webSocketPublicClients.get(e ?? -1),
      t))
          return t;
      const {webSocketPublicClient: n} = this.args;
      return t = typeof n == "function" ? n({
          chainId: e
      }) : n,
      t && this.webSocketPublicClients.set(e ?? -1, t),
      t
  }
  setWebSocketPublicClient(e) {
      var n, r;
      const t = (r = (n = this.data) == null ? void 0 : n.chain) == null ? void 0 : r.id;
      this.args = {
          ...this.args,
          webSocketPublicClient: e
      },
      this.webSocketPublicClients.clear(),
      this.setState(i => ({
          ...i,
          webSocketPublicClient: this.getWebSocketPublicClient({
              chainId: t
          })
      }))
  }
  setLastUsedConnector(e=null) {
      var t;
      (t = this.storage) == null || t.setItem("wallet", e)
  }
}
;
Ai = new WeakMap;
ta = new WeakMap;
zp = new WeakSet;
Wx = function() {
  const e = o => {
      this.setState(u => ({
          ...u,
          data: {
              ...u.data,
              ...o
          }
      }))
  }
    , t = () => {
      this.clearState()
  }
    , n = o => {
      this.setState(u => ({
          ...u,
          error: o
      }))
  }
  ;
  this.store.subscribe( ({connector: o}) => o, (o, u) => {
      var l, c, f, d, y, m;
      (l = u == null ? void 0 : u.off) == null || l.call(u, "change", e),
      (c = u == null ? void 0 : u.off) == null || c.call(u, "disconnect", t),
      (f = u == null ? void 0 : u.off) == null || f.call(u, "error", n),
      o && ((d = o.on) == null || d.call(o, "change", e),
      (y = o.on) == null || y.call(o, "disconnect", t),
      (m = o.on) == null || m.call(o, "error", n))
  }
  );
  const {publicClient: r, webSocketPublicClient: i} = this.args;
  (typeof r == "function" || typeof i == "function") && this.store.subscribe( ({data: o}) => {
      var u;
      return (u = o == null ? void 0 : o.chain) == null ? void 0 : u.id
  }
  , o => {
      this.setState(u => ({
          ...u,
          publicClient: this.getPublicClient({
              chainId: o
          }),
          webSocketPublicClient: this.getWebSocketPublicClient({
              chainId: o
          })
      }))
  }
  )
}
;
var Bp;
function MO(e) {
  const t = new jO(e);
  return Bp = t,
  t
}
function Bt() {
  if (!Bp)
      throw new Error("No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config");
  return Bp
}
async function B0({chainId: e, connector: t}) {
  const n = Bt()
    , r = n.connector;
  if (r && t.id === r.id)
      throw new OO;
  try {
      n.setState(s => ({
          ...s,
          status: "connecting"
      }));
      const i = await t.connect({
          chainId: e
      });
      return n.setLastUsedConnector(t.id),
      n.setState(s => ({
          ...s,
          connector: t,
          chains: t == null ? void 0 : t.chains,
          data: i,
          status: "connected"
      })),
      n.storage.setItem("connected", !0),
      {
          ...i,
          connector: t
      }
  } catch (i) {
      throw n.setState(s => ({
          ...s,
          status: s.connector ? "connected" : "disconnected"
      })),
      i
  }
}
async function LO() {
  const e = Bt();
  e.connector && await e.connector.disconnect(),
  e.clearState(),
  e.storage.removeItem("connected")
}
var FO = [{
  type: "event",
  name: "Approval",
  inputs: [{
      indexed: !0,
      name: "owner",
      type: "address"
  }, {
      indexed: !0,
      name: "spender",
      type: "address"
  }, {
      indexed: !1,
      name: "value",
      type: "uint256"
  }]
}, {
  type: "event",
  name: "Transfer",
  inputs: [{
      indexed: !0,
      name: "from",
      type: "address"
  }, {
      indexed: !0,
      name: "to",
      type: "address"
  }, {
      indexed: !1,
      name: "value",
      type: "uint256"
  }]
}, {
  type: "function",
  name: "allowance",
  stateMutability: "view",
  inputs: [{
      name: "owner",
      type: "address"
  }, {
      name: "spender",
      type: "address"
  }],
  outputs: [{
      name: "",
      type: "uint256"
  }]
}, {
  type: "function",
  name: "approve",
  stateMutability: "nonpayable",
  inputs: [{
      name: "spender",
      type: "address"
  }, {
      name: "amount",
      type: "uint256"
  }],
  outputs: [{
      name: "",
      type: "bool"
  }]
}, {
  type: "function",
  name: "balanceOf",
  stateMutability: "view",
  inputs: [{
      name: "account",
      type: "address"
  }],
  outputs: [{
      name: "",
      type: "uint256"
  }]
}, {
  type: "function",
  name: "decimals",
  stateMutability: "view",
  inputs: [],
  outputs: [{
      name: "",
      type: "uint8"
  }]
}, {
  type: "function",
  name: "name",
  stateMutability: "view",
  inputs: [],
  outputs: [{
      name: "",
      type: "string"
  }]
}, {
  type: "function",
  name: "symbol",
  stateMutability: "view",
  inputs: [],
  outputs: [{
      name: "",
      type: "string"
  }]
}, {
  type: "function",
  name: "totalSupply",
  stateMutability: "view",
  inputs: [],
  outputs: [{
      name: "",
      type: "uint256"
  }]
}, {
  type: "function",
  name: "transfer",
  stateMutability: "nonpayable",
  inputs: [{
      name: "recipient",
      type: "address"
  }, {
      name: "amount",
      type: "uint256"
  }],
  outputs: [{
      name: "",
      type: "bool"
  }]
}, {
  type: "function",
  name: "transferFrom",
  stateMutability: "nonpayable",
  inputs: [{
      name: "sender",
      type: "address"
  }, {
      name: "recipient",
      type: "address"
  }, {
      name: "amount",
      type: "uint256"
  }],
  outputs: [{
      name: "",
      type: "bool"
  }]
}]
, UO = [{
  type: "event",
  name: "Approval",
  inputs: [{
      indexed: !0,
      name: "owner",
      type: "address"
  }, {
      indexed: !0,
      name: "spender",
      type: "address"
  }, {
      indexed: !1,
      name: "value",
      type: "uint256"
  }]
}, {
  type: "event",
  name: "Transfer",
  inputs: [{
      indexed: !0,
      name: "from",
      type: "address"
  }, {
      indexed: !0,
      name: "to",
      type: "address"
  }, {
      indexed: !1,
      name: "value",
      type: "uint256"
  }]
}, {
  type: "function",
  name: "allowance",
  stateMutability: "view",
  inputs: [{
      name: "owner",
      type: "address"
  }, {
      name: "spender",
      type: "address"
  }],
  outputs: [{
      name: "",
      type: "uint256"
  }]
}, {
  type: "function",
  name: "approve",
  stateMutability: "nonpayable",
  inputs: [{
      name: "spender",
      type: "address"
  }, {
      name: "amount",
      type: "uint256"
  }],
  outputs: [{
      name: "",
      type: "bool"
  }]
}, {
  type: "function",
  name: "balanceOf",
  stateMutability: "view",
  inputs: [{
      name: "account",
      type: "address"
  }],
  outputs: [{
      name: "",
      type: "uint256"
  }]
}, {
  type: "function",
  name: "decimals",
  stateMutability: "view",
  inputs: [],
  outputs: [{
      name: "",
      type: "uint8"
  }]
}, {
  type: "function",
  name: "name",
  stateMutability: "view",
  inputs: [],
  outputs: [{
      name: "",
      type: "bytes32"
  }]
}, {
  type: "function",
  name: "symbol",
  stateMutability: "view",
  inputs: [],
  outputs: [{
      name: "",
      type: "bytes32"
  }]
}, {
  type: "function",
  name: "totalSupply",
  stateMutability: "view",
  inputs: [],
  outputs: [{
      name: "",
      type: "uint256"
  }]
}, {
  type: "function",
  name: "transfer",
  stateMutability: "nonpayable",
  inputs: [{
      name: "recipient",
      type: "address"
  }, {
      name: "amount",
      type: "uint256"
  }],
  outputs: [{
      name: "",
      type: "bool"
  }]
}, {
  type: "function",
  name: "transferFrom",
  stateMutability: "nonpayable",
  inputs: [{
      name: "sender",
      type: "address"
  }, {
      name: "recipient",
      type: "address"
  }, {
      name: "amount",
      type: "uint256"
  }],
  outputs: [{
      name: "",
      type: "bool"
  }]
}];
function nn({chainId: e}={}) {
  const t = Bt();
  return e && t.getPublicClient({
      chainId: e
  }) || t.publicClient
}
async function Hx({chainId: e}={}) {
  var r, i;
  return await ((i = (r = Bt().connector) == null ? void 0 : r.getWalletClient) == null ? void 0 : i.call(r, {
      chainId: e
  })) || null
}
function Wp({chainId: e}={}) {
  const t = Bt();
  return e && t.getWebSocketPublicClient({
      chainId: e
  }) || t.webSocketPublicClient
}
function zO(e, t) {
  const n = Bt()
    , r = async () => t(nn(e));
  return n.subscribe( ({publicClient: s}) => s, r)
}
function BO(e, t) {
  const n = Bt()
    , r = async () => t(Wp(e));
  return n.subscribe( ({webSocketPublicClient: s}) => s, r)
}
async function WO({abi: e, address: t, args: n, chainId: r, dataSuffix: i, functionName: s, walletClient: a, ...o}) {
  const u = nn({
      chainId: r
  })
    , l = a ?? await Hx({
      chainId: r
  });
  if (!l)
      throw new jn;
  r && Yx({
      chainId: r
  });
  const {account: c, accessList: f, blockNumber: d, blockTag: y, gas: m, gasPrice: v, maxFeePerGas: b, maxPriorityFeePerGas: w, nonce: h, value: g} = AO(o)
    , {result: x, request: S} = await u.simulateContract({
      abi: e,
      address: t,
      functionName: s,
      args: n,
      account: c || l.account,
      accessList: f,
      blockNumber: d,
      blockTag: y,
      dataSuffix: i,
      gas: m,
      gasPrice: v,
      maxFeePerGas: b,
      maxPriorityFeePerGas: w,
      nonce: h,
      value: g
  })
    , E = e.filter(p => "name"in p && p.name === s);
  return {
      mode: "prepared",
      request: {
          ...S,
          abi: E,
          chainId: r
      },
      result: x
  }
}
async function HO({chainId: e, contracts: t, blockNumber: n, blockTag: r, ...i}) {
  const s = nn({
      chainId: e
  });
  if (!s.chains)
      throw new kO;
  if (e && s.chain.id !== e)
      throw new TO({
          chainId: e
      });
  return s.multicall({
      allowFailure: i.allowFailure ?? !0,
      blockNumber: n,
      blockTag: r,
      contracts: t
  })
}
async function qx({address: e, account: t, chainId: n, abi: r, args: i, functionName: s, blockNumber: a, blockTag: o}) {
  return nn({
      chainId: n
  }).readContract({
      abi: r,
      address: e,
      account: t,
      functionName: s,
      args: i,
      blockNumber: a,
      blockTag: o
  })
}
async function Vx({contracts: e, blockNumber: t, blockTag: n, ...r}) {
  const {allowFailure: i=!0} = r;
  try {
      const s = nn()
        , a = e.reduce( (c, f, d) => {
          const y = f.chainId ?? s.chain.id;
          return {
              ...c,
              [y]: [...c[y] || [], {
                  contract: f,
                  index: d
              }]
          }
      }
      , {})
        , o = () => Object.entries(a).map( ([c,f]) => HO({
          allowFailure: i,
          chainId: parseInt(c),
          contracts: f.map( ({contract: d}) => d),
          blockNumber: t,
          blockTag: n
      }))
        , u = (await Promise.all(o())).flat()
        , l = Object.values(a).flatMap(c => c.map( ({index: f}) => f));
      return u.reduce( (c, f, d) => (c && (c[l[d]] = f),
      c), [])
  } catch (s) {
      if (s instanceof Bm)
          throw s;
      const a = () => e.map(o => qx({
          ...o,
          blockNumber: t,
          blockTag: n
      }));
      return i ? (await Promise.allSettled(a())).map(o => o.status === "fulfilled" ? {
          result: o.value,
          status: "success"
      } : {
          error: o.reason,
          result: void 0,
          status: "failure"
      }) : await Promise.all(a())
  }
}
async function W0(e) {
  const t = await Hx({
      chainId: e.chainId
  });
  if (!t)
      throw new jn;
  e.chainId && Yx({
      chainId: e.chainId
  });
  let n;
  if (e.mode === "prepared")
      n = e.request;
  else {
      const {chainId: i, mode: s, ...a} = e;
      n = (await WO(a)).request
  }
  return {
      hash: await t.writeContract({
          ...n,
          chain: e.chainId ? {
              id: e.chainId
          } : null
      })
  }
}
async function qO({address: e, chainId: t, formatUnits: n, token: r}) {
  const i = Bt()
    , s = nn({
      chainId: t
  });
  if (r) {
      const l = async ({abi: c}) => {
          const f = {
              abi: c,
              address: r,
              chainId: t
          }
            , [d,y,m] = await Vx({
              allowFailure: !1,
              contracts: [{
                  ...f,
                  functionName: "balanceOf",
                  args: [e]
              }, {
                  ...f,
                  functionName: "decimals"
              }, {
                  ...f,
                  functionName: "symbol"
              }]
          });
          return {
              decimals: y,
              formatted: El(d ?? "0", L0(n ?? y)),
              symbol: m,
              value: d
          }
      }
      ;
      try {
          return await l({
              abi: FO
          })
      } catch (c) {
          if (c instanceof Bm) {
              const {symbol: f, ...d} = await l({
                  abi: UO
              });
              return {
                  symbol: Am(oi(f, {
                      dir: "right"
                  })),
                  ...d
              }
          }
          throw c
      }
  }
  const a = [...i.publicClient.chains || [], ...i.chains ?? []]
    , o = await s.getBalance({
      address: e
  })
    , u = a.find(l => l.id === s.chain.id);
  return {
      decimals: (u == null ? void 0 : u.nativeCurrency.decimals) ?? 18,
      formatted: El(o ?? "0", L0(n ?? 18)),
      symbol: (u == null ? void 0 : u.nativeCurrency.symbol) ?? "ETH",
      value: o
  }
}
function oy() {
  const {data: e, connector: t, status: n} = Bt();
  switch (n) {
  case "connected":
      return {
          address: e == null ? void 0 : e.account,
          connector: t,
          isConnected: !0,
          isConnecting: !1,
          isDisconnected: !1,
          isReconnecting: !1,
          status: n
      };
  case "reconnecting":
      return {
          address: e == null ? void 0 : e.account,
          connector: t,
          isConnected: !!(e != null && e.account),
          isConnecting: !1,
          isDisconnected: !1,
          isReconnecting: !0,
          status: n
      };
  case "connecting":
      return {
          address: e == null ? void 0 : e.account,
          connector: t,
          isConnected: !1,
          isConnecting: !0,
          isDisconnected: !1,
          isReconnecting: !1,
          status: n
      };
  case "disconnected":
      return {
          address: void 0,
          connector: void 0,
          isConnected: !1,
          isConnecting: !1,
          isDisconnected: !0,
          isReconnecting: !1,
          status: n
      }
  }
}
function Ic() {
  var i, s, a, o;
  const e = Bt()
    , t = (s = (i = e.data) == null ? void 0 : i.chain) == null ? void 0 : s.id
    , n = e.chains ?? []
    , r = [...((a = e.publicClient) == null ? void 0 : a.chains) || [], ...n].find(u => u.id === t) ?? {
      id: t,
      name: `Chain ${t}`,
      network: `${t}`,
      nativeCurrency: {
          name: "Ether",
          decimals: 18,
          symbol: "ETH"
      },
      rpcUrls: {
          default: {
              http: [""]
          },
          public: {
              http: [""]
          }
      }
  };
  return {
      chain: t ? {
          ...r,
          ...(o = e.data) == null ? void 0 : o.chain,
          id: t
      } : void 0,
      chains: n
  }
}
async function Kx({chainId: e}) {
  const {connector: t} = Bt();
  if (!t)
      throw new jn;
  if (!t.switchChain)
      throw new DO({
          connector: t
      });
  return t.switchChain(e)
}
function Gx(e, {selector: t=n => n}={}) {
  const n = Bt()
    , r = () => e(oy());
  return n.subscribe( ({data: s, connector: a, status: o}) => t({
      address: s == null ? void 0 : s.account,
      connector: a,
      status: o
  }), r, {
      equalityFn: Ux
  })
}
function Qx(e, {selector: t=n => n}={}) {
  const n = Bt()
    , r = () => e(Ic());
  return n.subscribe( ({data: s, chains: a}) => {
      var o;
      return t({
          chainId: (o = s == null ? void 0 : s.chain) == null ? void 0 : o.id,
          chains: a
      })
  }
  , r, {
      equalityFn: Ux
  })
}
async function VO({name: e, chainId: t}) {
  const {normalize: n} = await sn( () => import("./index-5yUoXU-p.js"), __vite__mapDeps([0, 1]));
  return await nn({
      chainId: t
  }).getEnsAvatar({
      name: n(e)
  })
}
async function KO({address: e, chainId: t}) {
  return nn({
      chainId: t
  }).getEnsName({
      address: Tr(e)
  })
}
async function GO({chainId: e}={}) {
  return await nn({
      chainId: e
  }).getBlockNumber()
}
async function QO({chainId: e, confirmations: t=1, hash: n, onReplaced: r, timeout: i=0}) {
  const s = nn({
      chainId: e
  })
    , a = await s.waitForTransactionReceipt({
      hash: n,
      confirmations: t,
      onReplaced: r,
      timeout: i
  });
  if (a.status === "reverted") {
      const o = await s.getTransaction({
          hash: a.transactionHash
      })
        , u = await s.call({
          ...o,
          gasPrice: o.type !== "eip1559" ? o.gasPrice : void 0,
          maxFeePerGas: o.type === "eip1559" ? o.maxFeePerGas : void 0,
          maxPriorityFeePerGas: o.type === "eip1559" ? o.maxPriorityFeePerGas : void 0
      })
        , l = Am(`0x${u.substring(138)}`);
      throw new Error(l)
  }
  return a
}
function Yx({chainId: e}) {
  var i, s;
  const {chain: t, chains: n} = Ic()
    , r = t == null ? void 0 : t.id;
  if (r && e !== r)
      throw new PO({
          activeChain: ((i = n.find(a => a.id === r)) == null ? void 0 : i.name) ?? `Chain ${r}`,
          targetChain: ((s = n.find(a => a.id === e)) == null ? void 0 : s.name) ?? `Chain ${e}`
      })
}
var Xx = {
  exports: {}
}
, Jx = {};
/**
* @license React
* use-sync-external-store-shim/with-selector.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var Ac = _
, YO = Om;
function XO(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var JO = typeof Object.is == "function" ? Object.is : XO
, ZO = YO.useSyncExternalStore
, ek = Ac.useRef
, tk = Ac.useEffect
, nk = Ac.useMemo
, rk = Ac.useDebugValue;
Jx.useSyncExternalStoreWithSelector = function(e, t, n, r, i) {
  var s = ek(null);
  if (s.current === null) {
      var a = {
          hasValue: !1,
          value: null
      };
      s.current = a
  } else
      a = s.current;
  s = nk(function() {
      function u(y) {
          if (!l) {
              if (l = !0,
              c = y,
              y = r(y),
              i !== void 0 && a.hasValue) {
                  var m = a.value;
                  if (i(m, y))
                      return f = m
              }
              return f = y
          }
          if (m = f,
          JO(c, y))
              return m;
          var v = r(y);
          return i !== void 0 && i(m, v) ? m : (c = y,
          f = v)
      }
      var l = !1, c, f, d = n === void 0 ? null : n;
      return [function() {
          return u(t())
      }
      , d === null ? void 0 : function() {
          return u(d())
      }
      ]
  }, [t, n, r, i]);
  var o = ZO(e, s[0], s[1]);
  return tk(function() {
      a.hasValue = !0,
      a.value = o
  }, [o]),
  rk(o),
  o
}
;
Xx.exports = Jx;
var uy = Xx.exports;
function ik({queryClient: e=new X5({
  defaultOptions: {
      queries: {
          cacheTime: 1e3 * 60 * 60 * 24,
          networkMode: "offlineFirst",
          refetchOnWindowFocus: !1,
          retry: 0
      },
      mutations: {
          networkMode: "offlineFirst"
      }
  }
}), storage: t=Bx({
  storage: typeof window < "u" && window.localStorage ? window.localStorage : zx
}), persister: n=typeof window < "u" ? j5({
  key: "cache",
  storage: t,
  serialize: i => i,
  deserialize: i => i
}) : void 0, ...r}) {
  const i = MO({
      ...r,
      storage: t
  });
  return n && k_({
      queryClient: e,
      persister: n,
      dehydrateOptions: {
          shouldDehydrateQuery: s => s.cacheTime !== 0 && s.queryKey[0].persist !== !1
      }
  }),
  Object.assign(i, {
      queryClient: e
  })
}
var Zx = _.createContext(void 0)
, $c = _.createContext(void 0);
function sk({children: e, config: t}) {
  return _.createElement(Zx.Provider, {
      children: _.createElement(v_, {
          children: e,
          client: t.queryClient,
          context: $c
      }),
      value: t
  })
}
function ly() {
  const e = _.useContext(Zx);
  if (!e)
      throw new Error(["`useConfig` must be used within `WagmiConfig`.\n", "Read more: https://wagmi.sh/react/WagmiConfig"].join(`
`));
  return e
}
var ak = Om.useSyncExternalStore;
function ok(e) {
  return Array.isArray(e)
}
function uk(e) {
  if (!H0(e))
      return !1;
  const t = e.constructor;
  if (typeof t > "u")
      return !0;
  const n = t.prototype;
  return !(!H0(n) || !n.hasOwnProperty("isPrototypeOf"))
}
function H0(e) {
  return Object.prototype.toString.call(e) === "[object Object]"
}
function lk(e, t, n) {
  return ok(e) ? typeof t == "function" ? {
      ...n,
      queryKey: e,
      queryFn: t
  } : {
      ...t,
      queryKey: e
  } : e
}
function ck(e) {
  return JSON.stringify(e, (t, n) => uk(n) ? Object.keys(n).sort().reduce( (r, i) => (r[i] = n[i],
  r), {}) : typeof n == "bigint" ? n.toString() : n)
}
function fk(e, t) {
  return typeof e == "function" ? e(...t) : !!e
}
function dk(e, t) {
  const n = {};
  return Object.keys(e).forEach(r => {
      Object.defineProperty(n, r, {
          configurable: !1,
          enumerable: !0,
          get: () => (t.trackedProps.add(r),
          e[r])
      })
  }
  ),
  n
}
function pk(e, t) {
  const n = km({
      context: e.context
  })
    , r = w_()
    , i = E_()
    , s = n.defaultQueryOptions({
      ...e,
      queryKeyHashFn: ck
  });
  s._optimisticResults = r ? "isRestoring" : "optimistic",
  s.onError && (s.onError = Ne.batchCalls(s.onError)),
  s.onSuccess && (s.onSuccess = Ne.batchCalls(s.onSuccess)),
  s.onSettled && (s.onSettled = Ne.batchCalls(s.onSettled)),
  s.suspense && typeof s.staleTime != "number" && (s.staleTime = 1e3),
  (s.suspense || s.useErrorBoundary) && (i.isReset() || (s.retryOnMount = !1));
  const [a] = _.useState( () => new t(n,s))
    , o = a.getOptimisticResult(s);
  if (ak(_.useCallback(f => r ? () => {}
  : a.subscribe(Ne.batchCalls(f)), [a, r]), () => a.getCurrentResult(), () => a.getCurrentResult()),
  _.useEffect( () => {
      i.clearReset()
  }
  , [i]),
  _.useEffect( () => {
      a.setOptions(s, {
          listeners: !1
      })
  }
  , [s, a]),
  s.suspense && o.isLoading && o.isFetching && !r)
      throw a.fetchOptimistic(s).then( ({data: f}) => {
          var d, y;
          (d = s.onSuccess) == null || d.call(s, f),
          (y = s.onSettled) == null || y.call(s, f, null)
      }
      ).catch(f => {
          var d, y;
          i.clearReset(),
          (d = s.onError) == null || d.call(s, f),
          (y = s.onSettled) == null || y.call(s, void 0, f)
      }
      );
  if (o.isError && !i.isReset() && !o.isFetching && fk(s.useErrorBoundary, [o.error, a.getCurrentQuery()]))
      throw o.error;
  const u = o.status === "loading" && o.fetchStatus === "idle" ? "idle" : o.status
    , l = u === "idle"
    , c = u === "loading" && o.fetchStatus === "fetching";
  return {
      ...o,
      defaultedOptions: s,
      isIdle: l,
      isLoading: c,
      observer: a,
      status: u
  }
}
function eE(e, t, n) {
  const r = _2(e, t, n);
  return C_({
      context: $c,
      ...r
  })
}
function Rc(e, t, n) {
  const r = lk(e, t, n)
    , i = pk({
      context: $c,
      ...r
  }, J5)
    , s = {
      data: i.data,
      error: i.error,
      fetchStatus: i.fetchStatus,
      isError: i.isError,
      isFetched: i.isFetched,
      isFetchedAfterMount: i.isFetchedAfterMount,
      isFetching: i.isFetching,
      isIdle: i.isIdle,
      isLoading: i.isLoading,
      isRefetching: i.isRefetching,
      isSuccess: i.isSuccess,
      refetch: i.refetch,
      status: i.status,
      internal: {
          dataUpdatedAt: i.dataUpdatedAt,
          errorUpdatedAt: i.errorUpdatedAt,
          failureCount: i.failureCount,
          isFetchedAfterMount: i.isFetchedAfterMount,
          isLoadingError: i.isLoadingError,
          isPaused: i.isPaused,
          isPlaceholderData: i.isPlaceholderData,
          isPreviousData: i.isPreviousData,
          isRefetchError: i.isRefetchError,
          isStale: i.isStale,
          remove: i.remove
      }
  };
  return i.defaultedOptions.notifyOnChangeProps ? s : dk(s, i.observer)
}
var tE = () => km({
  context: $c
});
function nE({chainId: e}={}) {
  return uy.useSyncExternalStoreWithSelector(t => zO({
      chainId: e
  }, t), () => nn({
      chainId: e
  }), () => nn({
      chainId: e
  }), t => t, (t, n) => t.uid === n.uid)
}
function hk({chainId: e}={}) {
  return uy.useSyncExternalStoreWithSelector(t => BO({
      chainId: e
  }, t), () => Wp({
      chainId: e
  }), () => Wp({
      chainId: e
  }), t => t, (t, n) => (t == null ? void 0 : t.uid) === (n == null ? void 0 : n.uid))
}
function Nc({chainId: e}={}) {
  return nE({
      chainId: e
  }).chain.id
}
function mk() {
  const [,e] = _.useReducer(t => t + 1, 0);
  return e
}
function q0({chainId: e, scopeKey: t}) {
  return [{
      entity: "blockNumber",
      chainId: e,
      scopeKey: t
  }]
}
function yk({queryKey: [{chainId: e}]}) {
  return GO({
      chainId: e
  })
}
function cy({cacheTime: e=0, chainId: t, enabled: n=!0, scopeKey: r, staleTime: i, suspense: s, watch: a=!1, onBlock: o, onError: u, onSettled: l, onSuccess: c}={}) {
  const f = Nc({
      chainId: t
  })
    , d = nE({
      chainId: f
  })
    , y = hk({
      chainId: f
  })
    , m = tE();
  return _.useEffect( () => !n || !a && !o ? void 0 : (y ?? d).watchBlockNumber({
      onBlockNumber: w => {
          a && m.setQueryData(q0({
              chainId: f,
              scopeKey: r
          }), w),
          o && o(w)
      }
      ,
      emitOnBegin: !0
  }), [f, r, o, d, m, a, y, n]),
  Rc(q0({
      scopeKey: r,
      chainId: f
  }), yk, {
      cacheTime: e,
      enabled: n,
      staleTime: i,
      suspense: s,
      onError: u,
      onSettled: l,
      onSuccess: c
  })
}
function rE({chainId: e, enabled: t, queryKey: n}) {
  const r = tE()
    , i = _.useCallback( () => r.invalidateQueries({
      queryKey: n
  }, {
      cancelRefetch: !1
  }), [r, n]);
  cy({
      chainId: e,
      enabled: t,
      onBlock: t ? i : void 0,
      scopeKey: t ? void 0 : "idle"
  })
}
var ed = e => typeof e == "object" && !Array.isArray(e);
function iE(e, t, n=t, r=Xa) {
  const i = _.useRef([])
    , s = uy.useSyncExternalStoreWithSelector(e, t, n, a => a, (a, o) => {
      if (ed(a) && ed(o) && i.current.length) {
          for (const u of i.current)
              if (!r(a[u], o[u]))
                  return !1;
          return !0
      }
      return r(a, o)
  }
  );
  if (ed(s)) {
      const a = {
          ...s
      };
      return Object.defineProperties(a, Object.entries(a).reduce( (o, [u,l]) => ({
          ...o,
          [u]: {
              configurable: !1,
              enumerable: !0,
              get: () => (i.current.includes(u) || i.current.push(u),
              l)
          }
      }), {})),
      a
  }
  return s
}
function jc({onConnect: e, onDisconnect: t}={}) {
  const n = ly()
    , r = _.useCallback(o => Gx(o), [n])
    , i = iE(r, oy)
    , s = _.useRef()
    , a = s.current;
  return _.useEffect( () => {
      (a == null ? void 0 : a.status) !== "connected" && i.status === "connected" && (e == null || e({
          address: i.address,
          connector: i.connector,
          isReconnected: (a == null ? void 0 : a.status) === "reconnecting" || (a == null ? void 0 : a.status) === void 0
      })),
      (a == null ? void 0 : a.status) === "connected" && i.status === "disconnected" && (t == null || t()),
      s.current = i
  }
  , [e, t, a, i]),
  i
}
function GU() {
  const e = ly()
    , t = _.useCallback(n => Qx(n), [e]);
  return iE(t, Ic)
}
var gk = e => [{
  entity: "switchNetwork",
  ...e
}]
, vk = e => {
  const {chainId: t} = e;
  if (!t)
      throw new Error("chainId is required");
  return Kx({
      chainId: t
  })
}
;
function QU({chainId: e, throwForSwitchChainNotSupported: t, onError: n, onMutate: r, onSettled: i, onSuccess: s}={}) {
  var C;
  const a = ly()
    , o = mk()
    , {data: u, error: l, isError: c, isIdle: f, isLoading: d, isSuccess: y, mutate: m, mutateAsync: v, reset: b, status: w, variables: h} = eE(gk({
      chainId: e
  }), vk, {
      onError: n,
      onMutate: r,
      onSettled: i,
      onSuccess: s
  })
    , g = _.useCallback(T => m({
      chainId: T ?? e
  }), [e, m])
    , x = _.useCallback(T => v({
      chainId: T ?? e
  }), [e, v]);
  _.useEffect( () => a.subscribe( ({chains: O, connector: R}) => ({
      chains: O,
      connector: R
  }), o), [a, o]);
  let S, E;
  const p = !!((C = a.connector) != null && C.switchChain);
  return (t || p) && (S = g,
  E = x),
  {
      chains: a.chains ?? [],
      data: u,
      error: l,
      isError: c,
      isIdle: f,
      isLoading: d,
      isSuccess: y,
      pendingChainId: h == null ? void 0 : h.chainId,
      reset: b,
      status: w,
      switchNetwork: S,
      switchNetworkAsync: E,
      variables: h
  }
}
function wk({account: e, address: t, args: n, blockNumber: r, blockTag: i, chainId: s, functionName: a, scopeKey: o}) {
  return [{
      entity: "readContract",
      account: e,
      address: t,
      args: n,
      blockNumber: r,
      blockTag: i,
      chainId: s,
      functionName: a,
      scopeKey: o
  }]
}
function bk({abi: e}) {
  return async ({queryKey: [{account: t, address: n, args: r, blockNumber: i, blockTag: s, chainId: a, functionName: o}]}) => {
      if (!e)
          throw new Error("abi is required");
      if (!n)
          throw new Error("address is required");
      return await qx({
          account: t,
          address: n,
          args: r,
          blockNumber: i,
          blockTag: s,
          chainId: a,
          abi: e,
          functionName: o
      }) ?? null
  }
}
function YU({abi: e, address: t, account: n, args: r, blockNumber: i, blockTag: s, cacheOnBlock: a=!1, cacheTime: o, chainId: u, enabled: l=!0, functionName: c, isDataEqual: f, keepPreviousData: d, onError: y, onSettled: m, onSuccess: v, scopeKey: b, select: w, staleTime: h, structuralSharing: g= (E, p) => Xa(E, p) ? E : hc(E, p), suspense: x, watch: S}={}) {
  const E = Nc({
      chainId: u
  })
    , {data: p} = cy({
      chainId: E,
      enabled: S || a,
      scopeKey: S || a ? void 0 : "idle",
      watch: S
  })
    , C = i ?? p
    , T = _.useMemo( () => wk({
      account: n,
      address: t,
      args: r,
      blockNumber: a ? C : void 0,
      blockTag: s,
      chainId: E,
      functionName: c,
      scopeKey: b
  }), [n, t, r, C, s, a, E, c, b])
    , O = _.useMemo( () => {
      let R = !!(l && e && t && c);
      return a && (R = !!(R && C)),
      R
  }
  , [e, t, C, a, l, c]);
  return rE({
      chainId: E,
      enabled: !!(O && S && !a),
      queryKey: T
  }),
  Rc(T, bk({
      abi: e
  }), {
      cacheTime: o,
      enabled: O,
      isDataEqual: f,
      keepPreviousData: d,
      select: w,
      staleTime: h,
      structuralSharing: g,
      suspense: x,
      onError: y,
      onSettled: m,
      onSuccess: v
  })
}
function xk({allowFailure: e, blockNumber: t, blockTag: n, chainId: r, contracts: i, scopeKey: s}) {
  return [{
      entity: "readContracts",
      allowFailure: e,
      blockNumber: t,
      blockTag: n,
      chainId: r,
      scopeKey: s,
      contracts: (i ?? []).map( ({address: a, args: o, chainId: u, functionName: l}) => ({
          address: a,
          args: o,
          chainId: u,
          functionName: l
      }))
  }]
}
function Ek({abis: e}) {
  return ({queryKey: [{allowFailure: t, blockNumber: n, blockTag: r, contracts: i}]}) => {
      const s = i.map( (a, o) => ({
          ...a,
          abi: e[o]
      }));
      return Vx({
          allowFailure: t,
          contracts: s,
          blockNumber: n,
          blockTag: r
      })
  }
}
function XU({allowFailure: e, blockNumber: t, blockTag: n, cacheOnBlock: r=!1, cacheTime: i, contracts: s, enabled: a=!0, isDataEqual: o, keepPreviousData: u, onError: l, onSettled: c, onSuccess: f, scopeKey: d, select: y, staleTime: m, structuralSharing: v= (h, g) => Xa(h, g) ? h : hc(h, g), suspense: b, watch: w}={}) {
  const h = e ?? !0
    , {data: g} = cy({
      enabled: w || r,
      watch: w
  })
    , x = Nc()
    , S = t ?? g
    , E = _.useMemo( () => xk({
      allowFailure: h,
      blockNumber: r ? S : void 0,
      blockTag: n,
      chainId: x,
      contracts: s,
      scopeKey: d
  }), [h, S, n, r, x, d, s])
    , p = _.useMemo( () => {
      let T = !!(a && (s != null && s.every(O => O.abi && O.address && O.functionName)));
      return r && (T = !!(T && S)),
      T
  }
  , [S, r, s, a]);
  rE({
      enabled: !!(p && w && !r),
      queryKey: E
  });
  const C = (s ?? []).map( ({abi: T}) => T);
  return Rc(E, Ek({
      abis: C
  }), {
      cacheTime: i,
      enabled: p,
      isDataEqual: o,
      keepPreviousData: u,
      staleTime: m,
      select: y,
      structuralSharing: v,
      suspense: b,
      onError: l,
      onSettled: c,
      onSuccess: f
  })
}
function Sk({address: e, abi: t, functionName: n, ...r}) {
  const {args: i, accessList: s, account: a, dataSuffix: o, gas: u, gasPrice: l, maxFeePerGas: c, maxPriorityFeePerGas: f, nonce: d, request: y, value: m} = r;
  return [{
      entity: "writeContract",
      address: e,
      args: i,
      abi: t,
      accessList: s,
      account: a,
      dataSuffix: o,
      functionName: n,
      gas: u,
      gasPrice: l,
      maxFeePerGas: c,
      maxPriorityFeePerGas: f,
      nonce: d,
      request: y,
      value: m
  }]
}
function Ck(e) {
  if (e.mode === "prepared") {
      if (!e.request)
          throw new Error("request is required");
      return W0({
          mode: "prepared",
          request: e.request
      })
  }
  if (!e.address)
      throw new Error("address is required");
  if (!e.abi)
      throw new Error("abi is required");
  if (!e.functionName)
      throw new Error("functionName is required");
  return W0({
      address: e.address,
      args: e.args,
      chainId: e.chainId,
      abi: e.abi,
      functionName: e.functionName,
      accessList: e.accessList,
      account: e.account,
      dataSuffix: e.dataSuffix,
      gas: e.gas,
      gasPrice: e.gasPrice,
      maxFeePerGas: e.maxFeePerGas,
      maxPriorityFeePerGas: e.maxPriorityFeePerGas,
      nonce: e.nonce,
      value: e.value
  })
}
function JU(e) {
  const {address: t, abi: n, args: r, chainId: i, functionName: s, mode: a, request: o, dataSuffix: u} = e
    , {accessList: l, account: c, gas: f, gasPrice: d, maxFeePerGas: y, maxPriorityFeePerGas: m, nonce: v, value: b} = $O(e)
    , {data: w, error: h, isError: g, isIdle: x, isLoading: S, isSuccess: E, mutate: p, mutateAsync: C, reset: T, status: O, variables: R} = eE(Sk({
      address: t,
      abi: n,
      functionName: s,
      chainId: i,
      mode: a,
      args: r,
      accessList: l,
      account: c,
      dataSuffix: u,
      gas: f,
      gasPrice: d,
      maxFeePerGas: y,
      maxPriorityFeePerGas: m,
      nonce: v,
      request: o,
      value: b
  }), Ck, {
      onError: e.onError,
      onMutate: e.onMutate,
      onSettled: e.onSettled,
      onSuccess: e.onSuccess
  })
    , j = _.useMemo( () => e.mode === "prepared" ? o ? () => p({
      mode: "prepared",
      request: e.request,
      chainId: e.chainId
  }) : void 0 : M => p({
      address: t,
      args: r,
      abi: n,
      functionName: s,
      chainId: i,
      accessList: l,
      account: c,
      dataSuffix: u,
      gas: f,
      gasPrice: d,
      maxFeePerGas: y,
      maxPriorityFeePerGas: m,
      nonce: v,
      value: b,
      ...M
  }), [l, c, n, t, r, i, e.chainId, e.mode, e.request, u, s, f, d, y, m, p, v, o, b])
    , L = _.useMemo( () => e.mode === "prepared" ? o ? () => C({
      mode: "prepared",
      request: e.request
  }) : void 0 : M => C({
      address: t,
      args: r,
      abi: n,
      chainId: i,
      functionName: s,
      accessList: l,
      account: c,
      dataSuffix: u,
      gas: f,
      gasPrice: d,
      maxFeePerGas: y,
      maxPriorityFeePerGas: m,
      nonce: v,
      value: b,
      ...M
  }), [l, c, n, t, r, i, e.mode, e.request, u, s, f, d, y, m, C, v, o, b]);
  return {
      data: w,
      error: h,
      isError: g,
      isIdle: x,
      isLoading: S,
      isSuccess: E,
      reset: T,
      status: O,
      variables: R,
      write: j,
      writeAsync: L
  }
}
function _k({confirmations: e, chainId: t, hash: n, scopeKey: r, timeout: i}) {
  return [{
      entity: "waitForTransaction",
      confirmations: e,
      chainId: t,
      hash: n,
      scopeKey: r,
      timeout: i
  }]
}
function Pk({onReplaced: e}) {
  return ({queryKey: [{chainId: t, confirmations: n, hash: r, timeout: i}]}) => {
      if (!r)
          throw new Error("hash is required");
      return QO({
          chainId: t,
          confirmations: n,
          hash: r,
          onReplaced: e,
          timeout: i
      })
  }
}
function ZU({chainId: e, confirmations: t, hash: n, timeout: r, cacheTime: i, enabled: s=!0, scopeKey: a, staleTime: o, suspense: u, onError: l, onReplaced: c, onSettled: f, onSuccess: d}={}) {
  const y = Nc({
      chainId: e
  });
  return Rc(_k({
      chainId: y,
      confirmations: t,
      hash: n,
      scopeKey: a,
      timeout: r
  }), Pk({
      onReplaced: c
  }), {
      cacheTime: i,
      enabled: !!(s && n),
      staleTime: o,
      suspense: u,
      onError: l,
      onSettled: f,
      onSuccess: d
  })
}
function Tk({apiKey: e}) {
  return function(t) {
      var i, s, a;
      const n = (i = t.rpcUrls.infura) == null ? void 0 : i.http[0]
        , r = (a = (s = t.rpcUrls.infura) == null ? void 0 : s.webSocket) == null ? void 0 : a[0];
      return n ? {
          chain: {
              ...t,
              rpcUrls: {
                  ...t.rpcUrls,
                  default: {
                      http: [`${n}/${e}`]
                  }
              }
          },
          rpcUrls: {
              http: [`${n}/${e}`],
              webSocket: [`${r}/${e}`]
          }
      } : null
  }
}
function Ok() {
  return function(e) {
      return e.rpcUrls.public.http[0] ? {
          chain: e,
          rpcUrls: e.rpcUrls.public
      } : null
  }
}
const kk = Symbol()
, V0 = Object.getPrototypeOf
, Hp = new WeakMap
, Dk = e => e && (Hp.has(e) ? Hp.get(e) : V0(e) === Object.prototype || V0(e) === Array.prototype)
, Ik = e => Dk(e) && e[kk] || null
, K0 = (e, t=!0) => {
  Hp.set(e, t)
}
;
var Ol = {
  VITE_PROJECT_ID: "f4686537b0b93c1046822fa05ee9cd6b",
  VITE_INFURA_KEY_TEST: "8060915499804bc1824877fa4a120d56",
  VITE_INFURA_KEY: "b6b73456fee04e7882dd2115e4116860",
  BASE_URL: "/",
  MODE: "production",
  DEV: !1,
  PROD: !0,
  SSR: !1
};
const td = e => typeof e == "object" && e !== null
, lr = new WeakMap
, ou = new WeakSet
, Ak = (e=Object.is, t= (c, f) => new Proxy(c,f), n=c => td(c) && !ou.has(c) && (Array.isArray(c) || !(Symbol.iterator in c)) && !(c instanceof WeakMap) && !(c instanceof WeakSet) && !(c instanceof Error) && !(c instanceof Number) && !(c instanceof Date) && !(c instanceof String) && !(c instanceof RegExp) && !(c instanceof ArrayBuffer), r=c => c.configurable && c.enumerable && c.writable, i=c => {
  switch (c.status) {
  case "fulfilled":
      return c.value;
  case "rejected":
      throw c.reason;
  default:
      throw c
  }
}
, s=new WeakMap, a= (c, f, d=i) => {
  const y = s.get(c);
  if ((y == null ? void 0 : y[0]) === f)
      return y[1];
  const m = Array.isArray(c) ? [] : Object.create(Object.getPrototypeOf(c));
  return K0(m, !0),
  s.set(c, [f, m]),
  Reflect.ownKeys(c).forEach(v => {
      if (Object.getOwnPropertyDescriptor(m, v))
          return;
      const b = Reflect.get(c, v)
        , w = {
          value: b,
          enumerable: !0,
          configurable: !0
      };
      if (ou.has(b))
          K0(b, !1);
      else if (b instanceof Promise)
          delete w.value,
          w.get = () => d(b);
      else if (lr.has(b)) {
          const [h,g] = lr.get(b);
          w.value = a(h, g(), d)
      }
      Object.defineProperty(m, v, w)
  }
  ),
  Object.preventExtensions(m)
}
, o=new WeakMap, u=[1, 1], l=c => {
  if (!td(c))
      throw new Error("object required");
  const f = o.get(c);
  if (f)
      return f;
  let d = u[0];
  const y = new Set
    , m = (R, j=++u[0]) => {
      d !== j && (d = j,
      y.forEach(L => L(R, j)))
  }
  ;
  let v = u[1];
  const b = (R=++u[1]) => (v !== R && !y.size && (v = R,
  h.forEach( ([j]) => {
      const L = j[1](R);
      L > d && (d = L)
  }
  )),
  d)
    , w = R => (j, L) => {
      const M = [...j];
      M[1] = [R, ...M[1]],
      m(M, L)
  }
    , h = new Map
    , g = (R, j) => {
      if ((Ol ? "production" : void 0) !== "production" && h.has(R))
          throw new Error("prop listener already exists");
      if (y.size) {
          const L = j[3](w(R));
          h.set(R, [j, L])
      } else
          h.set(R, [j])
  }
    , x = R => {
      var j;
      const L = h.get(R);
      L && (h.delete(R),
      (j = L[1]) == null || j.call(L))
  }
    , S = R => (y.add(R),
  y.size === 1 && h.forEach( ([L,M], P) => {
      if ((Ol ? "production" : void 0) !== "production" && M)
          throw new Error("remove already exists");
      const A = L[3](w(P));
      h.set(P, [L, A])
  }
  ),
  () => {
      y.delete(R),
      y.size === 0 && h.forEach( ([L,M], P) => {
          M && (M(),
          h.set(P, [L]))
      }
      )
  }
  )
    , E = Array.isArray(c) ? [] : Object.create(Object.getPrototypeOf(c))
    , p = (R, j, L, M, P) => {
      if (R && (e(j, M) || o.has(M) && e(j, o.get(M))))
          return;
      x(L),
      td(M) && (M = Ik(M) || M);
      let A = M;
      if (M instanceof Promise)
          M.then($ => {
              M.status = "fulfilled",
              M.value = $,
              m(["resolve", [L], $])
          }
          ).catch($ => {
              M.status = "rejected",
              M.reason = $,
              m(["reject", [L], $])
          }
          );
      else {
          !lr.has(M) && n(M) && (A = l(M));
          const $ = !ou.has(A) && lr.get(A);
          $ && g(L, $)
      }
      P(A),
      m(["set", [L], M, j])
  }
    , T = t(E, {
      deleteProperty(R, j) {
          const L = Reflect.get(R, j);
          x(j);
          const M = Reflect.deleteProperty(R, j);
          return M && m(["delete", [j], L]),
          M
      },
      set(R, j, L, M) {
          const P = Reflect.has(R, j)
            , A = Reflect.get(R, j, M);
          return p(P, A, j, L, $ => {
              Reflect.set(R, j, $, M)
          }
          ),
          !0
      },
      defineProperty(R, j, L) {
          if (r(L)) {
              const M = Reflect.getOwnPropertyDescriptor(R, j);
              if (!M || r(M))
                  return p(!!M && "value"in M, M == null ? void 0 : M.value, j, L.value, P => {
                      Reflect.defineProperty(R, j, {
                          ...L,
                          value: P
                      })
                  }
                  ),
                  !0
          }
          return Reflect.defineProperty(R, j, L)
      }
  });
  o.set(c, T);
  const O = [E, b, a, S];
  return lr.set(T, O),
  Reflect.ownKeys(c).forEach(R => {
      const j = Object.getOwnPropertyDescriptor(c, R);
      "value"in j && (T[R] = c[R],
      delete j.value,
      delete j.writable),
      Object.defineProperty(E, R, j)
  }
  ),
  T
}
) => [l, lr, ou, e, t, n, r, i, s, a, o, u]
, [$k] = Ak();
function Dn(e={}) {
  return $k(e)
}
function er(e, t, n) {
  const r = lr.get(e);
  (Ol ? "production" : void 0) !== "production" && !r && console.warn("Please use proxy object");
  let i;
  const s = []
    , a = r[3];
  let o = !1;
  const l = a(c => {
      if (s.push(c),
      n) {
          t(s.splice(0));
          return
      }
      i || (i = Promise.resolve().then( () => {
          i = void 0,
          o && t(s.splice(0))
      }
      ))
  }
  );
  return o = !0,
  () => {
      o = !1,
      l()
  }
}
function Rk(e, t) {
  const n = lr.get(e);
  (Ol ? "production" : void 0) !== "production" && !n && console.warn("Please use proxy object");
  const [r,i,s] = n;
  return s(r, i(), t)
}
const Ge = Dn({
  history: ["ConnectWallet"],
  view: "ConnectWallet",
  data: void 0
})
, Ki = {
  state: Ge,
  subscribe(e) {
      return er(Ge, () => e(Ge))
  },
  push(e, t) {
      e !== Ge.view && (Ge.view = e,
      t && (Ge.data = t),
      Ge.history.push(e))
  },
  reset(e) {
      Ge.view = e,
      Ge.history = [e]
  },
  replace(e) {
      Ge.history.length > 1 && (Ge.history[Ge.history.length - 1] = e,
      Ge.view = e)
  },
  goBack() {
      if (Ge.history.length > 1) {
          Ge.history.pop();
          const [e] = Ge.history.slice(-1);
          Ge.view = e
      }
  },
  setData(e) {
      Ge.data = e
  }
}
, Ye = {
  WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
  W3M_VERSION: "W3M_VERSION",
  W3M_PREFER_INJECTED_URL_FLAG: "w3mPreferInjected",
  RECOMMENDED_WALLET_AMOUNT: 9,
  isMobile() {
      return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1
  },
  isAndroid() {
      return Ye.isMobile() && navigator.userAgent.toLowerCase().includes("android")
  },
  isIos() {
      const e = navigator.userAgent.toLowerCase();
      return Ye.isMobile() && (e.includes("iphone") || e.includes("ipad"))
  },
  isHttpUrl(e) {
      return e.startsWith("http://") || e.startsWith("https://")
  },
  isArray(e) {
      return Array.isArray(e) && e.length > 0
  },
  formatNativeUrl(e, t, n) {
      if (Ye.isHttpUrl(e))
          return this.formatUniversalUrl(e, t, n);
      let r = e;
      r.includes("://") || (r = e.replaceAll("/", "").replaceAll(":", ""),
      r = `${r}://`),
      r.endsWith("/") || (r = `${r}/`),
      this.setWalletConnectDeepLink(r, n);
      const i = encodeURIComponent(t);
      return `${r}wc?uri=${i}`
  },
  formatUniversalUrl(e, t, n) {
      if (!Ye.isHttpUrl(e))
          return this.formatNativeUrl(e, t, n);
      let r = e;
      r.endsWith("/") || (r = `${r}/`),
      this.setWalletConnectDeepLink(r, n);
      const i = encodeURIComponent(t);
      return `${r}wc?uri=${i}`
  },
  async wait(e) {
      return new Promise(t => {
          setTimeout(t, e)
      }
      )
  },
  openHref(e, t) {
      window.open(e, t, "noreferrer noopener")
  },
  setWalletConnectDeepLink(e, t) {
      try {
          localStorage.setItem(Ye.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({
              href: e,
              name: t
          }))
      } catch {
          console.info("Unable to set WalletConnect deep link")
      }
  },
  setWalletConnectAndroidDeepLink(e) {
      try {
          const [t] = e.split("?");
          localStorage.setItem(Ye.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({
              href: t,
              name: "Android"
          }))
      } catch {
          console.info("Unable to set WalletConnect android deep link")
      }
  },
  removeWalletConnectDeepLink() {
      try {
          localStorage.removeItem(Ye.WALLETCONNECT_DEEPLINK_CHOICE)
      } catch {
          console.info("Unable to remove WalletConnect deep link")
      }
  },
  setWeb3ModalVersionInStorage() {
      try {
          typeof localStorage < "u" && localStorage.setItem(Ye.W3M_VERSION, "2.7.1")
      } catch {
          console.info("Unable to set Web3Modal version in storage")
      }
  },
  getWalletRouterData() {
      var e;
      const t = (e = Ki.state.data) == null ? void 0 : e.Wallet;
      if (!t)
          throw new Error('Missing "Wallet" view data');
      return t
  },
  getSwitchNetworkRouterData() {
      var e;
      const t = (e = Ki.state.data) == null ? void 0 : e.SwitchNetwork;
      if (!t)
          throw new Error('Missing "SwitchNetwork" view data');
      return t
  },
  isPreferInjectedFlag() {
      return typeof location < "u" ? new URLSearchParams(location.search).has(Ye.W3M_PREFER_INJECTED_URL_FLAG) : !1
  }
};
let nd;
const Cn = {
  ethereumClient: void 0,
  setEthereumClient(e) {
      nd = e
  },
  client() {
      if (nd)
          return nd;
      throw new Error("ClientCtrl has no client set")
  }
}
, Nk = typeof location < "u" && (location.hostname.includes("localhost") || location.protocol.includes("https"))
, pt = Dn({
  enabled: Nk,
  userSessionId: "",
  events: [],
  connectedWalletId: void 0
})
, jk = {
  state: pt,
  subscribe(e) {
      return er(pt.events, () => e(Rk(pt.events[pt.events.length - 1])))
  },
  initialize() {
      pt.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" && (pt.userSessionId = crypto.randomUUID())
  },
  setConnectedWalletId(e) {
      pt.connectedWalletId = e
  },
  click(e) {
      if (pt.enabled) {
          const t = {
              type: "CLICK",
              name: e.name,
              userSessionId: pt.userSessionId,
              timestamp: Date.now(),
              data: e
          };
          pt.events.push(t)
      }
  },
  track(e) {
      if (pt.enabled) {
          const t = {
              type: "TRACK",
              name: e.name,
              userSessionId: pt.userSessionId,
              timestamp: Date.now(),
              data: e
          };
          pt.events.push(t)
      }
  },
  view(e) {
      if (pt.enabled) {
          const t = {
              type: "VIEW",
              name: e.name,
              userSessionId: pt.userSessionId,
              timestamp: Date.now(),
              data: e
          };
          pt.events.push(t)
      }
  }
}
, Ht = Dn({
  selectedChain: void 0,
  chains: void 0,
  isCustomDesktop: !1,
  isCustomMobile: !1,
  isDataLoaded: !1,
  isUiLoaded: !1,
  isPreferInjected: !1
})
, _n = {
  state: Ht,
  subscribe(e) {
      return er(Ht, () => e(Ht))
  },
  setChains(e) {
      Ht.chains = e
  },
  getSelectedChain() {
      const e = Cn.client().getNetwork().chain;
      return e && (Ht.selectedChain = e),
      Ht.selectedChain
  },
  setSelectedChain(e) {
      Ht.selectedChain = e
  },
  setIsCustomDesktop(e) {
      Ht.isCustomDesktop = e
  },
  setIsCustomMobile(e) {
      Ht.isCustomMobile = e
  },
  setIsDataLoaded(e) {
      Ht.isDataLoaded = e
  },
  setIsUiLoaded(e) {
      Ht.isUiLoaded = e
  },
  setIsPreferInjected(e) {
      Ht.isPreferInjected = e
  }
}
, uu = Dn({
  projectId: "",
  mobileWallets: void 0,
  desktopWallets: void 0,
  walletImages: void 0,
  chainImages: void 0,
  tokenImages: void 0,
  tokenContracts: void 0,
  enableNetworkView: !1,
  enableAccountView: !0,
  enableExplorer: !0,
  defaultChain: void 0,
  explorerExcludedWalletIds: void 0,
  explorerRecommendedWalletIds: void 0,
  termsOfServiceUrl: void 0,
  privacyPolicyUrl: void 0
})
, Yn = {
  state: uu,
  subscribe(e) {
      return er(uu, () => e(uu))
  },
  setConfig(e) {
      var t, n;
      jk.initialize(),
      _n.setIsCustomMobile(!!((t = e.mobileWallets) != null && t.length)),
      _n.setIsCustomDesktop(!!((n = e.desktopWallets) != null && n.length)),
      _n.setChains(Cn.client().chains),
      _n.setIsPreferInjected(Cn.client().isInjectedProviderInstalled() && Ye.isPreferInjectedFlag()),
      e.defaultChain && _n.setSelectedChain(e.defaultChain),
      Ye.setWeb3ModalVersionInStorage(),
      Object.assign(uu, e)
  }
}
, Mk = "eip155"
, Lk = "https://rpc.walletconnect.com"
, Fk = {
  async getIdentity(e, t) {
      const {projectId: n} = Yn.state
        , r = `${Mk}:${t}`
        , i = `${Lk}/v1/identity/${e}?chainId=${r}&projectId=${n}`;
      return (await fetch(i)).json()
  }
}
, me = Dn({
  address: void 0,
  profileName: void 0,
  profileAvatar: void 0,
  profileLoading: !1,
  balanceLoading: !1,
  balance: void 0,
  isConnected: !1
})
, Uk = {
  state: me,
  subscribe(e) {
      return er(me, () => e(me))
  },
  getAccount() {
      const e = Cn.client().getAccount();
      me.address = e.address,
      me.isConnected = e.isConnected
  },
  async fetchProfile(e, t) {
      var n;
      try {
          me.profileLoading = !0,
          me.profileName = null,
          me.profileAvatar = null;
          const r = t ?? me.address
            , i = 1
            , s = (n = _n.state.chains) == null ? void 0 : n.find(a => a.id === i);
          if (r && s) {
              try {
                  const a = await Fk.getIdentity(r, i);
                  me.profileName = a.name,
                  me.profileAvatar = a.avatar
              } catch {
                  const a = await Cn.client().fetchEnsName({
                      address: r,
                      chainId: i
                  });
                  if (me.profileName = a,
                  a) {
                      const o = await Cn.client().fetchEnsAvatar({
                          name: a,
                          chainId: i
                      });
                      me.profileAvatar = o
                  }
              }
              me.profileAvatar && await e(me.profileAvatar)
          }
      } finally {
          me.profileLoading = !1
      }
  },
  async fetchBalance(e) {
      try {
          const {chain: t} = Cn.client().getNetwork()
            , {tokenContracts: n} = Yn.state;
          let r;
          t && n && (r = n[t.id]),
          me.balanceLoading = !0;
          const i = e ?? me.address;
          if (i) {
              const s = await Cn.client().fetchBalance({
                  address: i,
                  token: r
              });
              me.balance = {
                  amount: s.formatted,
                  symbol: s.symbol
              }
          }
      } finally {
          me.balanceLoading = !1
      }
  },
  setAddress(e) {
      me.address = e
  },
  setIsConnected(e) {
      me.isConnected = e
  },
  resetBalance() {
      me.balance = void 0
  },
  resetAccount() {
      me.address = void 0,
      me.isConnected = !1,
      me.profileName = void 0,
      me.profileAvatar = void 0,
      me.balance = void 0
  }
};
var zk = Object.defineProperty
, G0 = Object.getOwnPropertySymbols
, Bk = Object.prototype.hasOwnProperty
, Wk = Object.prototype.propertyIsEnumerable
, Q0 = (e, t, n) => t in e ? zk(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n
, Hk = (e, t) => {
  for (var n in t || (t = {}))
      Bk.call(t, n) && Q0(e, n, t[n]);
  if (G0)
      for (var n of G0(t))
          Wk.call(t, n) && Q0(e, n, t[n]);
  return e
}
;
const qp = "https://explorer-api.walletconnect.com"
, Vp = "w3m"
, Kp = "js-2.7.1";
async function lu(e, t) {
  const n = Hk({
      sdkType: Vp,
      sdkVersion: Kp
  }, t)
    , r = new URL(e,qp);
  return r.searchParams.append("projectId", Yn.state.projectId),
  Object.entries(n).forEach( ([i,s]) => {
      s && r.searchParams.append(i, String(s))
  }
  ),
  (await fetch(r)).json()
}
const rr = {
  async getDesktopListings(e) {
      return lu("/w3m/v1/getDesktopListings", e)
  },
  async getMobileListings(e) {
      return lu("/w3m/v1/getMobileListings", e)
  },
  async getInjectedListings(e) {
      return lu("/w3m/v1/getInjectedListings", e)
  },
  async getAllListings(e) {
      return lu("/w3m/v1/getAllListings", e)
  },
  getWalletImageUrl(e) {
      return `${qp}/w3m/v1/getWalletImage/${e}?projectId=${Yn.state.projectId}&sdkType=${Vp}&sdkVersion=${Kp}`
  },
  getAssetImageUrl(e) {
      return `${qp}/w3m/v1/getAssetImage/${e}?projectId=${Yn.state.projectId}&sdkType=${Vp}&sdkVersion=${Kp}`
  }
};
var qk = Object.defineProperty
, Y0 = Object.getOwnPropertySymbols
, Vk = Object.prototype.hasOwnProperty
, Kk = Object.prototype.propertyIsEnumerable
, X0 = (e, t, n) => t in e ? qk(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n
, Gk = (e, t) => {
  for (var n in t || (t = {}))
      Vk.call(t, n) && X0(e, n, t[n]);
  if (Y0)
      for (var n of Y0(t))
          Kk.call(t, n) && X0(e, n, t[n]);
  return e
}
;
const J0 = Ye.isMobile()
, qt = Dn({
  wallets: {
      listings: [],
      total: 0,
      page: 1
  },
  injectedWallets: [],
  search: {
      listings: [],
      total: 0,
      page: 1
  },
  recomendedWallets: []
})
, e9 = {
  state: qt,
  async getRecomendedWallets() {
      const {explorerRecommendedWalletIds: e, explorerExcludedWalletIds: t} = Yn.state;
      if (e === "NONE" || t === "ALL" && !e)
          return qt.recomendedWallets;
      if (Ye.isArray(e)) {
          const n = {
              recommendedIds: e.join(",")
          }
            , {listings: r} = await rr.getAllListings(n)
            , i = Object.values(r);
          i.sort( (s, a) => {
              const o = e.indexOf(s.id)
                , u = e.indexOf(a.id);
              return o - u
          }
          ),
          qt.recomendedWallets = i
      } else {
          const n = Ye.isArray(t)
            , r = {
              page: 1,
              entries: Ye.RECOMMENDED_WALLET_AMOUNT,
              version: 2,
              excludedIds: n ? t.join(",") : void 0
          }
            , {listings: i} = J0 ? await rr.getMobileListings(r) : await rr.getDesktopListings(r);
          qt.recomendedWallets = Object.values(i)
      }
      return qt.recomendedWallets
  },
  async getWallets(e) {
      const t = Gk({}, e)
        , {explorerRecommendedWalletIds: n, explorerExcludedWalletIds: r} = Yn.state
        , {recomendedWallets: i} = qt;
      if (r === "ALL")
          return qt.wallets;
      i.length ? t.excludedIds = i.map(f => f.id).join(",") : Ye.isArray(n) && (t.excludedIds = n.join(",")),
      Ye.isArray(r) && (t.excludedIds = [t.excludedIds, r].filter(Boolean).join(","));
      const {page: s, search: a} = e
        , {listings: o, total: u} = J0 ? await rr.getMobileListings(t) : await rr.getDesktopListings(t)
        , l = Object.values(o)
        , c = a ? "search" : "wallets";
      return qt[c] = {
          listings: [...qt[c].listings, ...l],
          total: u,
          page: s ?? 1
      },
      {
          listings: l,
          total: u
      }
  },
  async getInjectedWallets() {
      const {listings: e} = await rr.getInjectedListings({})
        , t = Object.values(e);
      return qt.injectedWallets = t,
      qt.injectedWallets
  },
  getWalletImageUrl(e) {
      return rr.getWalletImageUrl(e)
  },
  getAssetImageUrl(e) {
      return rr.getAssetImageUrl(e)
  },
  resetSearch() {
      qt.search = {
          listings: [],
          total: 0,
          page: 1
      }
  }
}
, Ti = Dn({
  pairingEnabled: !1,
  pairingUri: "",
  pairingError: !1
})
, rd = {
  state: Ti,
  subscribe(e) {
      return er(Ti, () => e(Ti))
  },
  setPairingUri(e) {
      Ti.pairingUri = e
  },
  setPairingError(e) {
      Ti.pairingError = e
  },
  setPairingEnabled(e) {
      Ti.pairingEnabled = e
  }
}
, Oi = Dn({
  open: !1
})
, cu = {
  state: Oi,
  subscribe(e) {
      return er(Oi, () => e(Oi))
  },
  async open(e) {
      return new Promise(t => {
          const {isUiLoaded: n, isDataLoaded: r, isPreferInjected: i, selectedChain: s} = _n.state
            , {isConnected: a} = Uk.state
            , {enableNetworkView: o} = Yn.state;
          if (rd.setPairingEnabled(!0),
          a || Ye.removeWalletConnectDeepLink(),
          e != null && e.route)
              Ki.reset(e.route);
          else if (a)
              Ki.reset("Account");
          else if (o)
              Ki.reset("SelectNetwork");
          else if (i) {
              Cn.client().connectConnector("injected", s == null ? void 0 : s.id).catch(l => console.error(l)),
              t();
              return
          } else
              Ki.reset("ConnectWallet");
          const {pairingUri: u} = rd.state;
          if (n && r && (u || a))
              Oi.open = !0,
              t();
          else {
              const l = setInterval( () => {
                  const c = _n.state
                    , f = rd.state;
                  c.isUiLoaded && c.isDataLoaded && (f.pairingUri || a) && (clearInterval(l),
                  Oi.open = !0,
                  t())
              }
              , 200)
          }
      }
      )
  },
  close() {
      Oi.open = !1
  }
};
var Qk = Object.defineProperty
, Z0 = Object.getOwnPropertySymbols
, Yk = Object.prototype.hasOwnProperty
, Xk = Object.prototype.propertyIsEnumerable
, ev = (e, t, n) => t in e ? Qk(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n
, Jk = (e, t) => {
  for (var n in t || (t = {}))
      Yk.call(t, n) && ev(e, n, t[n]);
  if (Z0)
      for (var n of Z0(t))
          Xk.call(t, n) && ev(e, n, t[n]);
  return e
}
;
function Zk() {
  return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches
}
const qs = Dn({
  themeMode: Zk() ? "dark" : "light"
})
, e8 = {
  state: qs,
  subscribe(e) {
      return er(qs, () => e(qs))
  },
  setThemeConfig(e) {
      const {themeMode: t, themeVariables: n} = e;
      t && (qs.themeMode = t),
      n && (qs.themeVariables = Jk({}, n))
  }
}
, Vr = Dn({
  open: !1,
  message: "",
  variant: "success"
})
, t9 = {
  state: Vr,
  subscribe(e) {
      return er(Vr, () => e(Vr))
  },
  openToast(e, t) {
      Vr.open = !0,
      Vr.message = e,
      Vr.variant = t
  },
  closeToast() {
      Vr.open = !1
  }
};
var t8 = Object.defineProperty
, tv = Object.getOwnPropertySymbols
, n8 = Object.prototype.hasOwnProperty
, r8 = Object.prototype.propertyIsEnumerable
, nv = (e, t, n) => t in e ? t8(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n
, i8 = (e, t) => {
  for (var n in t || (t = {}))
      n8.call(t, n) && nv(e, n, t[n]);
  if (tv)
      for (var n of tv(t))
          r8.call(t, n) && nv(e, n, t[n]);
  return e
}
;
function s8(e) {
  return We.createElement("w3m-modal", i8({}, e))
}
var rv = Object.getOwnPropertySymbols
, a8 = Object.prototype.hasOwnProperty
, o8 = Object.prototype.propertyIsEnumerable
, u8 = (e, t) => {
  var n = {};
  for (var r in e)
      a8.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && rv)
      for (var r of rv(e))
          t.indexOf(r) < 0 && o8.call(e, r) && (n[r] = e[r]);
  return n
}
;
function l8(e) {
  var t = e
    , {ethereumClient: n} = t
    , r = u8(t, ["ethereumClient"]);
  const i = _.useCallback(async () => {
      e8.setThemeConfig(r),
      n && Cn.setEthereumClient(n),
      Yn.setConfig(r),
      await sn( () => import("./index-fxJ6RGiT.js"), __vite__mapDeps([2, 3])),
      _n.setIsUiLoaded(!0)
  }
  , [n, r]);
  return _.useEffect( () => {
      i()
  }
  , [i]),
  We.createElement(s8, null)
}
const c8 = _.memo(l8);
var f8 = Object.defineProperty
, iv = Object.getOwnPropertySymbols
, d8 = Object.prototype.hasOwnProperty
, p8 = Object.prototype.propertyIsEnumerable
, sv = (e, t, n) => t in e ? f8(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n
, h8 = (e, t) => {
  for (var n in t || (t = {}))
      d8.call(t, n) && sv(e, n, t[n]);
  if (iv)
      for (var n of iv(t))
          p8.call(t, n) && sv(e, n, t[n]);
  return e
}
;
function Mc() {
  const [e,t] = _.useState(cu.state);
  return _.useEffect( () => {
      const n = cu.subscribe(r => t(h8({}, r)));
      return () => {
          n()
      }
  }
  , []),
  {
      isOpen: e.open,
      open: cu.open,
      close: cu.close,
      setDefaultChain: _n.setSelectedChain
  }
}
var fy = {}
, Lc = {}
, se = {}
, sE = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
  });
  function t(o, u) {
      var l = o >>> 16 & 65535
        , c = o & 65535
        , f = u >>> 16 & 65535
        , d = u & 65535;
      return c * d + (l * d + c * f << 16 >>> 0) | 0
  }
  e.mul = Math.imul || t;
  function n(o, u) {
      return o + u | 0
  }
  e.add = n;
  function r(o, u) {
      return o - u | 0
  }
  e.sub = r;
  function i(o, u) {
      return o << u | o >>> 32 - u
  }
  e.rotl = i;
  function s(o, u) {
      return o << 32 - u | o >>> u
  }
  e.rotr = s;
  function a(o) {
      return typeof o == "number" && isFinite(o) && Math.floor(o) === o
  }
  e.isInteger = Number.isInteger || a,
  e.MAX_SAFE_INTEGER = 9007199254740991,
  e.isSafeInteger = function(o) {
      return e.isInteger(o) && o >= -e.MAX_SAFE_INTEGER && o <= e.MAX_SAFE_INTEGER
  }
}
)(sE);
Object.defineProperty(se, "__esModule", {
  value: !0
});
var aE = sE;
function m8(e, t) {
  return t === void 0 && (t = 0),
  (e[t + 0] << 8 | e[t + 1]) << 16 >> 16
}
se.readInt16BE = m8;
function y8(e, t) {
  return t === void 0 && (t = 0),
  (e[t + 0] << 8 | e[t + 1]) >>> 0
}
se.readUint16BE = y8;
function g8(e, t) {
  return t === void 0 && (t = 0),
  (e[t + 1] << 8 | e[t]) << 16 >> 16
}
se.readInt16LE = g8;
function v8(e, t) {
  return t === void 0 && (t = 0),
  (e[t + 1] << 8 | e[t]) >>> 0
}
se.readUint16LE = v8;
function oE(e, t, n) {
  return t === void 0 && (t = new Uint8Array(2)),
  n === void 0 && (n = 0),
  t[n + 0] = e >>> 8,
  t[n + 1] = e >>> 0,
  t
}
se.writeUint16BE = oE;
se.writeInt16BE = oE;
function uE(e, t, n) {
  return t === void 0 && (t = new Uint8Array(2)),
  n === void 0 && (n = 0),
  t[n + 0] = e >>> 0,
  t[n + 1] = e >>> 8,
  t
}
se.writeUint16LE = uE;
se.writeInt16LE = uE;
function Gp(e, t) {
  return t === void 0 && (t = 0),
  e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
}
se.readInt32BE = Gp;
function Qp(e, t) {
  return t === void 0 && (t = 0),
  (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0
}
se.readUint32BE = Qp;
function Yp(e, t) {
  return t === void 0 && (t = 0),
  e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]
}
se.readInt32LE = Yp;
function Xp(e, t) {
  return t === void 0 && (t = 0),
  (e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]) >>> 0
}
se.readUint32LE = Xp;
function kl(e, t, n) {
  return t === void 0 && (t = new Uint8Array(4)),
  n === void 0 && (n = 0),
  t[n + 0] = e >>> 24,
  t[n + 1] = e >>> 16,
  t[n + 2] = e >>> 8,
  t[n + 3] = e >>> 0,
  t
}
se.writeUint32BE = kl;
se.writeInt32BE = kl;
function Dl(e, t, n) {
  return t === void 0 && (t = new Uint8Array(4)),
  n === void 0 && (n = 0),
  t[n + 0] = e >>> 0,
  t[n + 1] = e >>> 8,
  t[n + 2] = e >>> 16,
  t[n + 3] = e >>> 24,
  t
}
se.writeUint32LE = Dl;
se.writeInt32LE = Dl;
function w8(e, t) {
  t === void 0 && (t = 0);
  var n = Gp(e, t)
    , r = Gp(e, t + 4);
  return n * 4294967296 + r - (r >> 31) * 4294967296
}
se.readInt64BE = w8;
function b8(e, t) {
  t === void 0 && (t = 0);
  var n = Qp(e, t)
    , r = Qp(e, t + 4);
  return n * 4294967296 + r
}
se.readUint64BE = b8;
function x8(e, t) {
  t === void 0 && (t = 0);
  var n = Yp(e, t)
    , r = Yp(e, t + 4);
  return r * 4294967296 + n - (n >> 31) * 4294967296
}
se.readInt64LE = x8;
function E8(e, t) {
  t === void 0 && (t = 0);
  var n = Xp(e, t)
    , r = Xp(e, t + 4);
  return r * 4294967296 + n
}
se.readUint64LE = E8;
function lE(e, t, n) {
  return t === void 0 && (t = new Uint8Array(8)),
  n === void 0 && (n = 0),
  kl(e / 4294967296 >>> 0, t, n),
  kl(e >>> 0, t, n + 4),
  t
}
se.writeUint64BE = lE;
se.writeInt64BE = lE;
function cE(e, t, n) {
  return t === void 0 && (t = new Uint8Array(8)),
  n === void 0 && (n = 0),
  Dl(e >>> 0, t, n),
  Dl(e / 4294967296 >>> 0, t, n + 4),
  t
}
se.writeUint64LE = cE;
se.writeInt64LE = cE;
function S8(e, t, n) {
  if (n === void 0 && (n = 0),
  e % 8 !== 0)
      throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (e / 8 > t.length - n)
      throw new Error("readUintBE: array is too short for the given bitLength");
  for (var r = 0, i = 1, s = e / 8 + n - 1; s >= n; s--)
      r += t[s] * i,
      i *= 256;
  return r
}
se.readUintBE = S8;
function C8(e, t, n) {
  if (n === void 0 && (n = 0),
  e % 8 !== 0)
      throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (e / 8 > t.length - n)
      throw new Error("readUintLE: array is too short for the given bitLength");
  for (var r = 0, i = 1, s = n; s < n + e / 8; s++)
      r += t[s] * i,
      i *= 256;
  return r
}
se.readUintLE = C8;
function _8(e, t, n, r) {
  if (n === void 0 && (n = new Uint8Array(e / 8)),
  r === void 0 && (r = 0),
  e % 8 !== 0)
      throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!aE.isSafeInteger(t))
      throw new Error("writeUintBE value must be an integer");
  for (var i = 1, s = e / 8 + r - 1; s >= r; s--)
      n[s] = t / i & 255,
      i *= 256;
  return n
}
se.writeUintBE = _8;
function P8(e, t, n, r) {
  if (n === void 0 && (n = new Uint8Array(e / 8)),
  r === void 0 && (r = 0),
  e % 8 !== 0)
      throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!aE.isSafeInteger(t))
      throw new Error("writeUintLE value must be an integer");
  for (var i = 1, s = r; s < r + e / 8; s++)
      n[s] = t / i & 255,
      i *= 256;
  return n
}
se.writeUintLE = P8;
function T8(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer,e.byteOffset,e.byteLength);
  return n.getFloat32(t)
}
se.readFloat32BE = T8;
function O8(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer,e.byteOffset,e.byteLength);
  return n.getFloat32(t, !0)
}
se.readFloat32LE = O8;
function k8(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer,e.byteOffset,e.byteLength);
  return n.getFloat64(t)
}
se.readFloat64BE = k8;
function D8(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer,e.byteOffset,e.byteLength);
  return n.getFloat64(t, !0)
}
se.readFloat64LE = D8;
function I8(e, t, n) {
  t === void 0 && (t = new Uint8Array(4)),
  n === void 0 && (n = 0);
  var r = new DataView(t.buffer,t.byteOffset,t.byteLength);
  return r.setFloat32(n, e),
  t
}
se.writeFloat32BE = I8;
function A8(e, t, n) {
  t === void 0 && (t = new Uint8Array(4)),
  n === void 0 && (n = 0);
  var r = new DataView(t.buffer,t.byteOffset,t.byteLength);
  return r.setFloat32(n, e, !0),
  t
}
se.writeFloat32LE = A8;
function $8(e, t, n) {
  t === void 0 && (t = new Uint8Array(8)),
  n === void 0 && (n = 0);
  var r = new DataView(t.buffer,t.byteOffset,t.byteLength);
  return r.setFloat64(n, e),
  t
}
se.writeFloat64BE = $8;
function R8(e, t, n) {
  t === void 0 && (t = new Uint8Array(8)),
  n === void 0 && (n = 0);
  var r = new DataView(t.buffer,t.byteOffset,t.byteLength);
  return r.setFloat64(n, e, !0),
  t
}
se.writeFloat64LE = R8;
var gn = {};
Object.defineProperty(gn, "__esModule", {
  value: !0
});
function N8(e) {
  for (var t = 0; t < e.length; t++)
      e[t] = 0;
  return e
}
gn.wipe = N8;
Object.defineProperty(Lc, "__esModule", {
  value: !0
});
var ht = se
, Jp = gn
, j8 = 20;
function M8(e, t, n) {
  for (var r = 1634760805, i = 857760878, s = 2036477234, a = 1797285236, o = n[3] << 24 | n[2] << 16 | n[1] << 8 | n[0], u = n[7] << 24 | n[6] << 16 | n[5] << 8 | n[4], l = n[11] << 24 | n[10] << 16 | n[9] << 8 | n[8], c = n[15] << 24 | n[14] << 16 | n[13] << 8 | n[12], f = n[19] << 24 | n[18] << 16 | n[17] << 8 | n[16], d = n[23] << 24 | n[22] << 16 | n[21] << 8 | n[20], y = n[27] << 24 | n[26] << 16 | n[25] << 8 | n[24], m = n[31] << 24 | n[30] << 16 | n[29] << 8 | n[28], v = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], b = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], w = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], h = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], g = r, x = i, S = s, E = a, p = o, C = u, T = l, O = c, R = f, j = d, L = y, M = m, P = v, A = b, $ = w, I = h, W = 0; W < j8; W += 2)
      g = g + p | 0,
      P ^= g,
      P = P >>> 16 | P << 16,
      R = R + P | 0,
      p ^= R,
      p = p >>> 20 | p << 12,
      x = x + C | 0,
      A ^= x,
      A = A >>> 16 | A << 16,
      j = j + A | 0,
      C ^= j,
      C = C >>> 20 | C << 12,
      S = S + T | 0,
      $ ^= S,
      $ = $ >>> 16 | $ << 16,
      L = L + $ | 0,
      T ^= L,
      T = T >>> 20 | T << 12,
      E = E + O | 0,
      I ^= E,
      I = I >>> 16 | I << 16,
      M = M + I | 0,
      O ^= M,
      O = O >>> 20 | O << 12,
      S = S + T | 0,
      $ ^= S,
      $ = $ >>> 24 | $ << 8,
      L = L + $ | 0,
      T ^= L,
      T = T >>> 25 | T << 7,
      E = E + O | 0,
      I ^= E,
      I = I >>> 24 | I << 8,
      M = M + I | 0,
      O ^= M,
      O = O >>> 25 | O << 7,
      x = x + C | 0,
      A ^= x,
      A = A >>> 24 | A << 8,
      j = j + A | 0,
      C ^= j,
      C = C >>> 25 | C << 7,
      g = g + p | 0,
      P ^= g,
      P = P >>> 24 | P << 8,
      R = R + P | 0,
      p ^= R,
      p = p >>> 25 | p << 7,
      g = g + C | 0,
      I ^= g,
      I = I >>> 16 | I << 16,
      L = L + I | 0,
      C ^= L,
      C = C >>> 20 | C << 12,
      x = x + T | 0,
      P ^= x,
      P = P >>> 16 | P << 16,
      M = M + P | 0,
      T ^= M,
      T = T >>> 20 | T << 12,
      S = S + O | 0,
      A ^= S,
      A = A >>> 16 | A << 16,
      R = R + A | 0,
      O ^= R,
      O = O >>> 20 | O << 12,
      E = E + p | 0,
      $ ^= E,
      $ = $ >>> 16 | $ << 16,
      j = j + $ | 0,
      p ^= j,
      p = p >>> 20 | p << 12,
      S = S + O | 0,
      A ^= S,
      A = A >>> 24 | A << 8,
      R = R + A | 0,
      O ^= R,
      O = O >>> 25 | O << 7,
      E = E + p | 0,
      $ ^= E,
      $ = $ >>> 24 | $ << 8,
      j = j + $ | 0,
      p ^= j,
      p = p >>> 25 | p << 7,
      x = x + T | 0,
      P ^= x,
      P = P >>> 24 | P << 8,
      M = M + P | 0,
      T ^= M,
      T = T >>> 25 | T << 7,
      g = g + C | 0,
      I ^= g,
      I = I >>> 24 | I << 8,
      L = L + I | 0,
      C ^= L,
      C = C >>> 25 | C << 7;
  ht.writeUint32LE(g + r | 0, e, 0),
  ht.writeUint32LE(x + i | 0, e, 4),
  ht.writeUint32LE(S + s | 0, e, 8),
  ht.writeUint32LE(E + a | 0, e, 12),
  ht.writeUint32LE(p + o | 0, e, 16),
  ht.writeUint32LE(C + u | 0, e, 20),
  ht.writeUint32LE(T + l | 0, e, 24),
  ht.writeUint32LE(O + c | 0, e, 28),
  ht.writeUint32LE(R + f | 0, e, 32),
  ht.writeUint32LE(j + d | 0, e, 36),
  ht.writeUint32LE(L + y | 0, e, 40),
  ht.writeUint32LE(M + m | 0, e, 44),
  ht.writeUint32LE(P + v | 0, e, 48),
  ht.writeUint32LE(A + b | 0, e, 52),
  ht.writeUint32LE($ + w | 0, e, 56),
  ht.writeUint32LE(I + h | 0, e, 60)
}
function fE(e, t, n, r, i) {
  if (i === void 0 && (i = 0),
  e.length !== 32)
      throw new Error("ChaCha: key size must be 32 bytes");
  if (r.length < n.length)
      throw new Error("ChaCha: destination is shorter than source");
  var s, a;
  if (i === 0) {
      if (t.length !== 8 && t.length !== 12)
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
      s = new Uint8Array(16),
      a = s.length - t.length,
      s.set(t, a)
  } else {
      if (t.length !== 16)
          throw new Error("ChaCha nonce with counter must be 16 bytes");
      s = t,
      a = i
  }
  for (var o = new Uint8Array(64), u = 0; u < n.length; u += 64) {
      M8(o, s, e);
      for (var l = u; l < u + 64 && l < n.length; l++)
          r[l] = n[l] ^ o[l - u];
      F8(s, 0, a)
  }
  return Jp.wipe(o),
  i === 0 && Jp.wipe(s),
  r
}
Lc.streamXOR = fE;
function L8(e, t, n, r) {
  return r === void 0 && (r = 0),
  Jp.wipe(n),
  fE(e, t, n, n, r)
}
Lc.stream = L8;
function F8(e, t, n) {
  for (var r = 1; n--; )
      r = r + (e[t] & 255) | 0,
      e[t] = r & 255,
      r >>>= 8,
      t++;
  if (r > 0)
      throw new Error("ChaCha: counter overflow")
}
var dE = {}
, Wr = {};
Object.defineProperty(Wr, "__esModule", {
  value: !0
});
function U8(e, t, n) {
  return ~(e - 1) & t | e - 1 & n
}
Wr.select = U8;
function z8(e, t) {
  return (e | 0) - (t | 0) - 1 >>> 31 & 1
}
Wr.lessOrEqual = z8;
function pE(e, t) {
  if (e.length !== t.length)
      return 0;
  for (var n = 0, r = 0; r < e.length; r++)
      n |= e[r] ^ t[r];
  return 1 & n - 1 >>> 8
}
Wr.compare = pE;
function B8(e, t) {
  return e.length === 0 || t.length === 0 ? !1 : pE(e, t) !== 0
}
Wr.equal = B8;
(function(e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
  });
  var t = Wr
    , n = gn;
  e.DIGEST_LENGTH = 16;
  var r = function() {
      function a(o) {
          this.digestLength = e.DIGEST_LENGTH,
          this._buffer = new Uint8Array(16),
          this._r = new Uint16Array(10),
          this._h = new Uint16Array(10),
          this._pad = new Uint16Array(8),
          this._leftover = 0,
          this._fin = 0,
          this._finished = !1;
          var u = o[0] | o[1] << 8;
          this._r[0] = u & 8191;
          var l = o[2] | o[3] << 8;
          this._r[1] = (u >>> 13 | l << 3) & 8191;
          var c = o[4] | o[5] << 8;
          this._r[2] = (l >>> 10 | c << 6) & 7939;
          var f = o[6] | o[7] << 8;
          this._r[3] = (c >>> 7 | f << 9) & 8191;
          var d = o[8] | o[9] << 8;
          this._r[4] = (f >>> 4 | d << 12) & 255,
          this._r[5] = d >>> 1 & 8190;
          var y = o[10] | o[11] << 8;
          this._r[6] = (d >>> 14 | y << 2) & 8191;
          var m = o[12] | o[13] << 8;
          this._r[7] = (y >>> 11 | m << 5) & 8065;
          var v = o[14] | o[15] << 8;
          this._r[8] = (m >>> 8 | v << 8) & 8191,
          this._r[9] = v >>> 5 & 127,
          this._pad[0] = o[16] | o[17] << 8,
          this._pad[1] = o[18] | o[19] << 8,
          this._pad[2] = o[20] | o[21] << 8,
          this._pad[3] = o[22] | o[23] << 8,
          this._pad[4] = o[24] | o[25] << 8,
          this._pad[5] = o[26] | o[27] << 8,
          this._pad[6] = o[28] | o[29] << 8,
          this._pad[7] = o[30] | o[31] << 8
      }
      return a.prototype._blocks = function(o, u, l) {
          for (var c = this._fin ? 0 : 2048, f = this._h[0], d = this._h[1], y = this._h[2], m = this._h[3], v = this._h[4], b = this._h[5], w = this._h[6], h = this._h[7], g = this._h[8], x = this._h[9], S = this._r[0], E = this._r[1], p = this._r[2], C = this._r[3], T = this._r[4], O = this._r[5], R = this._r[6], j = this._r[7], L = this._r[8], M = this._r[9]; l >= 16; ) {
              var P = o[u + 0] | o[u + 1] << 8;
              f += P & 8191;
              var A = o[u + 2] | o[u + 3] << 8;
              d += (P >>> 13 | A << 3) & 8191;
              var $ = o[u + 4] | o[u + 5] << 8;
              y += (A >>> 10 | $ << 6) & 8191;
              var I = o[u + 6] | o[u + 7] << 8;
              m += ($ >>> 7 | I << 9) & 8191;
              var W = o[u + 8] | o[u + 9] << 8;
              v += (I >>> 4 | W << 12) & 8191,
              b += W >>> 1 & 8191;
              var B = o[u + 10] | o[u + 11] << 8;
              w += (W >>> 14 | B << 2) & 8191;
              var ee = o[u + 12] | o[u + 13] << 8;
              h += (B >>> 11 | ee << 5) & 8191;
              var z = o[u + 14] | o[u + 15] << 8;
              g += (ee >>> 8 | z << 8) & 8191,
              x += z >>> 5 | c;
              var N = 0
                , F = N;
              F += f * S,
              F += d * (5 * M),
              F += y * (5 * L),
              F += m * (5 * j),
              F += v * (5 * R),
              N = F >>> 13,
              F &= 8191,
              F += b * (5 * O),
              F += w * (5 * T),
              F += h * (5 * C),
              F += g * (5 * p),
              F += x * (5 * E),
              N += F >>> 13,
              F &= 8191;
              var K = N;
              K += f * E,
              K += d * S,
              K += y * (5 * M),
              K += m * (5 * L),
              K += v * (5 * j),
              N = K >>> 13,
              K &= 8191,
              K += b * (5 * R),
              K += w * (5 * O),
              K += h * (5 * T),
              K += g * (5 * C),
              K += x * (5 * p),
              N += K >>> 13,
              K &= 8191;
              var k = N;
              k += f * p,
              k += d * E,
              k += y * S,
              k += m * (5 * M),
              k += v * (5 * L),
              N = k >>> 13,
              k &= 8191,
              k += b * (5 * j),
              k += w * (5 * R),
              k += h * (5 * O),
              k += g * (5 * T),
              k += x * (5 * C),
              N += k >>> 13,
              k &= 8191;
              var Q = N;
              Q += f * C,
              Q += d * p,
              Q += y * E,
              Q += m * S,
              Q += v * (5 * M),
              N = Q >>> 13,
              Q &= 8191,
              Q += b * (5 * L),
              Q += w * (5 * j),
              Q += h * (5 * R),
              Q += g * (5 * O),
              Q += x * (5 * T),
              N += Q >>> 13,
              Q &= 8191;
              var U = N;
              U += f * T,
              U += d * C,
              U += y * p,
              U += m * E,
              U += v * S,
              N = U >>> 13,
              U &= 8191,
              U += b * (5 * M),
              U += w * (5 * L),
              U += h * (5 * j),
              U += g * (5 * R),
              U += x * (5 * O),
              N += U >>> 13,
              U &= 8191;
              var te = N;
              te += f * O,
              te += d * T,
              te += y * C,
              te += m * p,
              te += v * E,
              N = te >>> 13,
              te &= 8191,
              te += b * S,
              te += w * (5 * M),
              te += h * (5 * L),
              te += g * (5 * j),
              te += x * (5 * R),
              N += te >>> 13,
              te &= 8191;
              var J = N;
              J += f * R,
              J += d * O,
              J += y * T,
              J += m * C,
              J += v * p,
              N = J >>> 13,
              J &= 8191,
              J += b * E,
              J += w * S,
              J += h * (5 * M),
              J += g * (5 * L),
              J += x * (5 * j),
              N += J >>> 13,
              J &= 8191;
              var Z = N;
              Z += f * j,
              Z += d * R,
              Z += y * O,
              Z += m * T,
              Z += v * C,
              N = Z >>> 13,
              Z &= 8191,
              Z += b * p,
              Z += w * E,
              Z += h * S,
              Z += g * (5 * M),
              Z += x * (5 * L),
              N += Z >>> 13,
              Z &= 8191;
              var G = N;
              G += f * L,
              G += d * j,
              G += y * R,
              G += m * O,
              G += v * T,
              N = G >>> 13,
              G &= 8191,
              G += b * C,
              G += w * p,
              G += h * E,
              G += g * S,
              G += x * (5 * M),
              N += G >>> 13,
              G &= 8191;
              var re = N;
              re += f * M,
              re += d * L,
              re += y * j,
              re += m * R,
              re += v * O,
              N = re >>> 13,
              re &= 8191,
              re += b * T,
              re += w * C,
              re += h * p,
              re += g * E,
              re += x * S,
              N += re >>> 13,
              re &= 8191,
              N = (N << 2) + N | 0,
              N = N + F | 0,
              F = N & 8191,
              N = N >>> 13,
              K += N,
              f = F,
              d = K,
              y = k,
              m = Q,
              v = U,
              b = te,
              w = J,
              h = Z,
              g = G,
              x = re,
              u += 16,
              l -= 16
          }
          this._h[0] = f,
          this._h[1] = d,
          this._h[2] = y,
          this._h[3] = m,
          this._h[4] = v,
          this._h[5] = b,
          this._h[6] = w,
          this._h[7] = h,
          this._h[8] = g,
          this._h[9] = x
      }
      ,
      a.prototype.finish = function(o, u) {
          u === void 0 && (u = 0);
          var l = new Uint16Array(10), c, f, d, y;
          if (this._leftover) {
              for (y = this._leftover,
              this._buffer[y++] = 1; y < 16; y++)
                  this._buffer[y] = 0;
              this._fin = 1,
              this._blocks(this._buffer, 0, 16)
          }
          for (c = this._h[1] >>> 13,
          this._h[1] &= 8191,
          y = 2; y < 10; y++)
              this._h[y] += c,
              c = this._h[y] >>> 13,
              this._h[y] &= 8191;
          for (this._h[0] += c * 5,
          c = this._h[0] >>> 13,
          this._h[0] &= 8191,
          this._h[1] += c,
          c = this._h[1] >>> 13,
          this._h[1] &= 8191,
          this._h[2] += c,
          l[0] = this._h[0] + 5,
          c = l[0] >>> 13,
          l[0] &= 8191,
          y = 1; y < 10; y++)
              l[y] = this._h[y] + c,
              c = l[y] >>> 13,
              l[y] &= 8191;
          for (l[9] -= 8192,
          f = (c ^ 1) - 1,
          y = 0; y < 10; y++)
              l[y] &= f;
          for (f = ~f,
          y = 0; y < 10; y++)
              this._h[y] = this._h[y] & f | l[y];
          for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535,
          this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535,
          this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535,
          this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535,
          this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535,
          this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535,
          this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535,
          this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535,
          d = this._h[0] + this._pad[0],
          this._h[0] = d & 65535,
          y = 1; y < 8; y++)
              d = (this._h[y] + this._pad[y] | 0) + (d >>> 16) | 0,
              this._h[y] = d & 65535;
          return o[u + 0] = this._h[0] >>> 0,
          o[u + 1] = this._h[0] >>> 8,
          o[u + 2] = this._h[1] >>> 0,
          o[u + 3] = this._h[1] >>> 8,
          o[u + 4] = this._h[2] >>> 0,
          o[u + 5] = this._h[2] >>> 8,
          o[u + 6] = this._h[3] >>> 0,
          o[u + 7] = this._h[3] >>> 8,
          o[u + 8] = this._h[4] >>> 0,
          o[u + 9] = this._h[4] >>> 8,
          o[u + 10] = this._h[5] >>> 0,
          o[u + 11] = this._h[5] >>> 8,
          o[u + 12] = this._h[6] >>> 0,
          o[u + 13] = this._h[6] >>> 8,
          o[u + 14] = this._h[7] >>> 0,
          o[u + 15] = this._h[7] >>> 8,
          this._finished = !0,
          this
      }
      ,
      a.prototype.update = function(o) {
          var u = 0, l = o.length, c;
          if (this._leftover) {
              c = 16 - this._leftover,
              c > l && (c = l);
              for (var f = 0; f < c; f++)
                  this._buffer[this._leftover + f] = o[u + f];
              if (l -= c,
              u += c,
              this._leftover += c,
              this._leftover < 16)
                  return this;
              this._blocks(this._buffer, 0, 16),
              this._leftover = 0
          }
          if (l >= 16 && (c = l - l % 16,
          this._blocks(o, u, c),
          u += c,
          l -= c),
          l) {
              for (var f = 0; f < l; f++)
                  this._buffer[this._leftover + f] = o[u + f];
              this._leftover += l
          }
          return this
      }
      ,
      a.prototype.digest = function() {
          if (this._finished)
              throw new Error("Poly1305 was finished");
          var o = new Uint8Array(16);
          return this.finish(o),
          o
      }
      ,
      a.prototype.clean = function() {
          return n.wipe(this._buffer),
          n.wipe(this._r),
          n.wipe(this._h),
          n.wipe(this._pad),
          this._leftover = 0,
          this._fin = 0,
          this._finished = !0,
          this
      }
      ,
      a
  }();
  e.Poly1305 = r;
  function i(a, o) {
      var u = new r(a);
      u.update(o);
      var l = u.digest();
      return u.clean(),
      l
  }
  e.oneTimeAuth = i;
  function s(a, o) {
      return a.length !== e.DIGEST_LENGTH || o.length !== e.DIGEST_LENGTH ? !1 : t.equal(a, o)
  }
  e.equal = s
}
)(dE);
(function(e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
  });
  var t = Lc
    , n = dE
    , r = gn
    , i = se
    , s = Wr;
  e.KEY_LENGTH = 32,
  e.NONCE_LENGTH = 12,
  e.TAG_LENGTH = 16;
  var a = new Uint8Array(16)
    , o = function() {
      function u(l) {
          if (this.nonceLength = e.NONCE_LENGTH,
          this.tagLength = e.TAG_LENGTH,
          l.length !== e.KEY_LENGTH)
              throw new Error("ChaCha20Poly1305 needs 32-byte key");
          this._key = new Uint8Array(l)
      }
      return u.prototype.seal = function(l, c, f, d) {
          if (l.length > 16)
              throw new Error("ChaCha20Poly1305: incorrect nonce length");
          var y = new Uint8Array(16);
          y.set(l, y.length - l.length);
          var m = new Uint8Array(32);
          t.stream(this._key, y, m, 4);
          var v = c.length + this.tagLength, b;
          if (d) {
              if (d.length !== v)
                  throw new Error("ChaCha20Poly1305: incorrect destination length");
              b = d
          } else
              b = new Uint8Array(v);
          return t.streamXOR(this._key, y, c, b, 4),
          this._authenticate(b.subarray(b.length - this.tagLength, b.length), m, b.subarray(0, b.length - this.tagLength), f),
          r.wipe(y),
          b
      }
      ,
      u.prototype.open = function(l, c, f, d) {
          if (l.length > 16)
              throw new Error("ChaCha20Poly1305: incorrect nonce length");
          if (c.length < this.tagLength)
              return null;
          var y = new Uint8Array(16);
          y.set(l, y.length - l.length);
          var m = new Uint8Array(32);
          t.stream(this._key, y, m, 4);
          var v = new Uint8Array(this.tagLength);
          if (this._authenticate(v, m, c.subarray(0, c.length - this.tagLength), f),
          !s.equal(v, c.subarray(c.length - this.tagLength, c.length)))
              return null;
          var b = c.length - this.tagLength, w;
          if (d) {
              if (d.length !== b)
                  throw new Error("ChaCha20Poly1305: incorrect destination length");
              w = d
          } else
              w = new Uint8Array(b);
          return t.streamXOR(this._key, y, c.subarray(0, c.length - this.tagLength), w, 4),
          r.wipe(y),
          w
      }
      ,
      u.prototype.clean = function() {
          return r.wipe(this._key),
          this
      }
      ,
      u.prototype._authenticate = function(l, c, f, d) {
          var y = new n.Poly1305(c);
          d && (y.update(d),
          d.length % 16 > 0 && y.update(a.subarray(d.length % 16))),
          y.update(f),
          f.length % 16 > 0 && y.update(a.subarray(f.length % 16));
          var m = new Uint8Array(8);
          d && i.writeUint64LE(d.length, m),
          y.update(m),
          i.writeUint64LE(f.length, m),
          y.update(m);
          for (var v = y.digest(), b = 0; b < v.length; b++)
              l[b] = v[b];
          y.clean(),
          r.wipe(v),
          r.wipe(m)
      }
      ,
      u
  }();
  e.ChaCha20Poly1305 = o
}
)(fy);
var hE = {}
, Eo = {}
, dy = {};
Object.defineProperty(dy, "__esModule", {
  value: !0
});
function W8(e) {
  return typeof e.saveState < "u" && typeof e.restoreState < "u" && typeof e.cleanSavedState < "u"
}
dy.isSerializableHash = W8;
Object.defineProperty(Eo, "__esModule", {
  value: !0
});
var bn = dy
, H8 = Wr
, q8 = gn
, mE = function() {
  function e(t, n) {
      this._finished = !1,
      this._inner = new t,
      this._outer = new t,
      this.blockSize = this._outer.blockSize,
      this.digestLength = this._outer.digestLength;
      var r = new Uint8Array(this.blockSize);
      n.length > this.blockSize ? this._inner.update(n).finish(r).clean() : r.set(n);
      for (var i = 0; i < r.length; i++)
          r[i] ^= 54;
      this._inner.update(r);
      for (var i = 0; i < r.length; i++)
          r[i] ^= 106;
      this._outer.update(r),
      bn.isSerializableHash(this._inner) && bn.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(),
      this._outerKeyedState = this._outer.saveState()),
      q8.wipe(r)
  }
  return e.prototype.reset = function() {
      if (!bn.isSerializableHash(this._inner) || !bn.isSerializableHash(this._outer))
          throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState),
      this._outer.restoreState(this._outerKeyedState),
      this._finished = !1,
      this
  }
  ,
  e.prototype.clean = function() {
      bn.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState),
      bn.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState),
      this._inner.clean(),
      this._outer.clean()
  }
  ,
  e.prototype.update = function(t) {
      return this._inner.update(t),
      this
  }
  ,
  e.prototype.finish = function(t) {
      return this._finished ? (this._outer.finish(t),
      this) : (this._inner.finish(t),
      this._outer.update(t.subarray(0, this.digestLength)).finish(t),
      this._finished = !0,
      this)
  }
  ,
  e.prototype.digest = function() {
      var t = new Uint8Array(this.digestLength);
      return this.finish(t),
      t
  }
  ,
  e.prototype.saveState = function() {
      if (!bn.isSerializableHash(this._inner))
          throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState()
  }
  ,
  e.prototype.restoreState = function(t) {
      if (!bn.isSerializableHash(this._inner) || !bn.isSerializableHash(this._outer))
          throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(t),
      this._outer.restoreState(this._outerKeyedState),
      this._finished = !1,
      this
  }
  ,
  e.prototype.cleanSavedState = function(t) {
      if (!bn.isSerializableHash(this._inner))
          throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(t)
  }
  ,
  e
}();
Eo.HMAC = mE;
function V8(e, t, n) {
  var r = new mE(e,t);
  r.update(n);
  var i = r.digest();
  return r.clean(),
  i
}
Eo.hmac = V8;
Eo.equal = H8.equal;
Object.defineProperty(hE, "__esModule", {
  value: !0
});
var av = Eo
, ov = gn
, K8 = function() {
  function e(t, n, r, i) {
      r === void 0 && (r = new Uint8Array(0)),
      this._counter = new Uint8Array(1),
      this._hash = t,
      this._info = i;
      var s = av.hmac(this._hash, r, n);
      this._hmac = new av.HMAC(t,s),
      this._buffer = new Uint8Array(this._hmac.digestLength),
      this._bufpos = this._buffer.length
  }
  return e.prototype._fillBuffer = function() {
      this._counter[0]++;
      var t = this._counter[0];
      if (t === 0)
          throw new Error("hkdf: cannot expand more");
      this._hmac.reset(),
      t > 1 && this._hmac.update(this._buffer),
      this._info && this._hmac.update(this._info),
      this._hmac.update(this._counter),
      this._hmac.finish(this._buffer),
      this._bufpos = 0
  }
  ,
  e.prototype.expand = function(t) {
      for (var n = new Uint8Array(t), r = 0; r < n.length; r++)
          this._bufpos === this._buffer.length && this._fillBuffer(),
          n[r] = this._buffer[this._bufpos++];
      return n
  }
  ,
  e.prototype.clean = function() {
      this._hmac.clean(),
      ov.wipe(this._buffer),
      ov.wipe(this._counter),
      this._bufpos = 0
  }
  ,
  e
}()
, G8 = hE.HKDF = K8
, Fc = {}
, Uc = {}
, zc = {};
Object.defineProperty(zc, "__esModule", {
  value: !0
});
zc.BrowserRandomSource = void 0;
const uv = 65536;
class Q8 {
  constructor() {
      this.isAvailable = !1,
      this.isInstantiated = !1;
      const t = typeof self < "u" ? self.crypto || self.msCrypto : null;
      t && t.getRandomValues !== void 0 && (this._crypto = t,
      this.isAvailable = !0,
      this.isInstantiated = !0)
  }
  randomBytes(t) {
      if (!this.isAvailable || !this._crypto)
          throw new Error("Browser random byte generator is not available.");
      const n = new Uint8Array(t);
      for (let r = 0; r < n.length; r += uv)
          this._crypto.getRandomValues(n.subarray(r, r + Math.min(n.length - r, uv)));
      return n
  }
}
zc.BrowserRandomSource = Q8;
function yE(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var Bc = {};
const Y8 = {}
, X8 = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Y8
}, Symbol.toStringTag, {
  value: "Module"
}))
, J8 = cw(X8);
Object.defineProperty(Bc, "__esModule", {
  value: !0
});
Bc.NodeRandomSource = void 0;
const Z8 = gn;
class eD {
  constructor() {
      if (this.isAvailable = !1,
      this.isInstantiated = !1,
      typeof yE < "u") {
          const t = J8;
          t && t.randomBytes && (this._crypto = t,
          this.isAvailable = !0,
          this.isInstantiated = !0)
      }
  }
  randomBytes(t) {
      if (!this.isAvailable || !this._crypto)
          throw new Error("Node.js random byte generator is not available.");
      let n = this._crypto.randomBytes(t);
      if (n.length !== t)
          throw new Error("NodeRandomSource: got fewer bytes than requested");
      const r = new Uint8Array(t);
      for (let i = 0; i < r.length; i++)
          r[i] = n[i];
      return (0,
      Z8.wipe)(n),
      r
  }
}
Bc.NodeRandomSource = eD;
Object.defineProperty(Uc, "__esModule", {
  value: !0
});
Uc.SystemRandomSource = void 0;
const tD = zc
, nD = Bc;
class rD {
  constructor() {
      if (this.isAvailable = !1,
      this.name = "",
      this._source = new tD.BrowserRandomSource,
      this._source.isAvailable) {
          this.isAvailable = !0,
          this.name = "Browser";
          return
      }
      if (this._source = new nD.NodeRandomSource,
      this._source.isAvailable) {
          this.isAvailable = !0,
          this.name = "Node";
          return
      }
  }
  randomBytes(t) {
      if (!this.isAvailable)
          throw new Error("System random byte generator is not available.");
      return this._source.randomBytes(t)
  }
}
Uc.SystemRandomSource = rD;
(function(e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
  }),
  e.randomStringForEntropy = e.randomString = e.randomUint32 = e.randomBytes = e.defaultRandomSource = void 0;
  const t = Uc
    , n = se
    , r = gn;
  e.defaultRandomSource = new t.SystemRandomSource;
  function i(l, c=e.defaultRandomSource) {
      return c.randomBytes(l)
  }
  e.randomBytes = i;
  function s(l=e.defaultRandomSource) {
      const c = i(4, l)
        , f = (0,
      n.readUint32LE)(c);
      return (0,
      r.wipe)(c),
      f
  }
  e.randomUint32 = s;
  const a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function o(l, c=a, f=e.defaultRandomSource) {
      if (c.length < 2)
          throw new Error("randomString charset is too short");
      if (c.length > 256)
          throw new Error("randomString charset is too long");
      let d = "";
      const y = c.length
        , m = 256 - 256 % y;
      for (; l > 0; ) {
          const v = i(Math.ceil(l * 256 / m), f);
          for (let b = 0; b < v.length && l > 0; b++) {
              const w = v[b];
              w < m && (d += c.charAt(w % y),
              l--)
          }
          (0,
          r.wipe)(v)
      }
      return d
  }
  e.randomString = o;
  function u(l, c=a, f=e.defaultRandomSource) {
      const d = Math.ceil(l / (Math.log(c.length) / Math.LN2));
      return o(d, c, f)
  }
  e.randomStringForEntropy = u
}
)(Fc);
var Wc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
  });
  var t = se
    , n = gn;
  e.DIGEST_LENGTH = 32,
  e.BLOCK_SIZE = 64;
  var r = function() {
      function o() {
          this.digestLength = e.DIGEST_LENGTH,
          this.blockSize = e.BLOCK_SIZE,
          this._state = new Int32Array(8),
          this._temp = new Int32Array(64),
          this._buffer = new Uint8Array(128),
          this._bufferLength = 0,
          this._bytesHashed = 0,
          this._finished = !1,
          this.reset()
      }
      return o.prototype._initState = function() {
          this._state[0] = 1779033703,
          this._state[1] = 3144134277,
          this._state[2] = 1013904242,
          this._state[3] = 2773480762,
          this._state[4] = 1359893119,
          this._state[5] = 2600822924,
          this._state[6] = 528734635,
          this._state[7] = 1541459225
      }
      ,
      o.prototype.reset = function() {
          return this._initState(),
          this._bufferLength = 0,
          this._bytesHashed = 0,
          this._finished = !1,
          this
      }
      ,
      o.prototype.clean = function() {
          n.wipe(this._buffer),
          n.wipe(this._temp),
          this.reset()
      }
      ,
      o.prototype.update = function(u, l) {
          if (l === void 0 && (l = u.length),
          this._finished)
              throw new Error("SHA256: can't update because hash was finished.");
          var c = 0;
          if (this._bytesHashed += l,
          this._bufferLength > 0) {
              for (; this._bufferLength < this.blockSize && l > 0; )
                  this._buffer[this._bufferLength++] = u[c++],
                  l--;
              this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize),
              this._bufferLength = 0)
          }
          for (l >= this.blockSize && (c = s(this._temp, this._state, u, c, l),
          l %= this.blockSize); l > 0; )
              this._buffer[this._bufferLength++] = u[c++],
              l--;
          return this
      }
      ,
      o.prototype.finish = function(u) {
          if (!this._finished) {
              var l = this._bytesHashed
                , c = this._bufferLength
                , f = l / 536870912 | 0
                , d = l << 3
                , y = l % 64 < 56 ? 64 : 128;
              this._buffer[c] = 128;
              for (var m = c + 1; m < y - 8; m++)
                  this._buffer[m] = 0;
              t.writeUint32BE(f, this._buffer, y - 8),
              t.writeUint32BE(d, this._buffer, y - 4),
              s(this._temp, this._state, this._buffer, 0, y),
              this._finished = !0
          }
          for (var m = 0; m < this.digestLength / 4; m++)
              t.writeUint32BE(this._state[m], u, m * 4);
          return this
      }
      ,
      o.prototype.digest = function() {
          var u = new Uint8Array(this.digestLength);
          return this.finish(u),
          u
      }
      ,
      o.prototype.saveState = function() {
          if (this._finished)
              throw new Error("SHA256: cannot save finished state");
          return {
              state: new Int32Array(this._state),
              buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
              bufferLength: this._bufferLength,
              bytesHashed: this._bytesHashed
          }
      }
      ,
      o.prototype.restoreState = function(u) {
          return this._state.set(u.state),
          this._bufferLength = u.bufferLength,
          u.buffer && this._buffer.set(u.buffer),
          this._bytesHashed = u.bytesHashed,
          this._finished = !1,
          this
      }
      ,
      o.prototype.cleanSavedState = function(u) {
          n.wipe(u.state),
          u.buffer && n.wipe(u.buffer),
          u.bufferLength = 0,
          u.bytesHashed = 0
      }
      ,
      o
  }();
  e.SHA256 = r;
  var i = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
  function s(o, u, l, c, f) {
      for (; f >= 64; ) {
          for (var d = u[0], y = u[1], m = u[2], v = u[3], b = u[4], w = u[5], h = u[6], g = u[7], x = 0; x < 16; x++) {
              var S = c + x * 4;
              o[x] = t.readUint32BE(l, S)
          }
          for (var x = 16; x < 64; x++) {
              var E = o[x - 2]
                , p = (E >>> 17 | E << 15) ^ (E >>> 19 | E << 13) ^ E >>> 10;
              E = o[x - 15];
              var C = (E >>> 7 | E << 25) ^ (E >>> 18 | E << 14) ^ E >>> 3;
              o[x] = (p + o[x - 7] | 0) + (C + o[x - 16] | 0)
          }
          for (var x = 0; x < 64; x++) {
              var p = (((b >>> 6 | b << 26) ^ (b >>> 11 | b << 21) ^ (b >>> 25 | b << 7)) + (b & w ^ ~b & h) | 0) + (g + (i[x] + o[x] | 0) | 0) | 0
                , C = ((d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10)) + (d & y ^ d & m ^ y & m) | 0;
              g = h,
              h = w,
              w = b,
              b = v + p | 0,
              v = m,
              m = y,
              y = d,
              d = p + C | 0
          }
          u[0] += d,
          u[1] += y,
          u[2] += m,
          u[3] += v,
          u[4] += b,
          u[5] += w,
          u[6] += h,
          u[7] += g,
          c += 64,
          f -= 64
      }
      return c
  }
  function a(o) {
      var u = new r;
      u.update(o);
      var l = u.digest();
      return u.clean(),
      l
  }
  e.hash = a
}
)(Wc);
var py = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
  }),
  e.sharedKey = e.generateKeyPair = e.generateKeyPairFromSeed = e.scalarMultBase = e.scalarMult = e.SHARED_KEY_LENGTH = e.SECRET_KEY_LENGTH = e.PUBLIC_KEY_LENGTH = void 0;
  const t = Fc
    , n = gn;
  e.PUBLIC_KEY_LENGTH = 32,
  e.SECRET_KEY_LENGTH = 32,
  e.SHARED_KEY_LENGTH = 32;
  function r(x) {
      const S = new Float64Array(16);
      if (x)
          for (let E = 0; E < x.length; E++)
              S[E] = x[E];
      return S
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const s = r([56129, 1]);
  function a(x) {
      let S = 1;
      for (let E = 0; E < 16; E++) {
          let p = x[E] + S + 65535;
          S = Math.floor(p / 65536),
          x[E] = p - S * 65536
      }
      x[0] += S - 1 + 37 * (S - 1)
  }
  function o(x, S, E) {
      const p = ~(E - 1);
      for (let C = 0; C < 16; C++) {
          const T = p & (x[C] ^ S[C]);
          x[C] ^= T,
          S[C] ^= T
      }
  }
  function u(x, S) {
      const E = r()
        , p = r();
      for (let C = 0; C < 16; C++)
          p[C] = S[C];
      a(p),
      a(p),
      a(p);
      for (let C = 0; C < 2; C++) {
          E[0] = p[0] - 65517;
          for (let O = 1; O < 15; O++)
              E[O] = p[O] - 65535 - (E[O - 1] >> 16 & 1),
              E[O - 1] &= 65535;
          E[15] = p[15] - 32767 - (E[14] >> 16 & 1);
          const T = E[15] >> 16 & 1;
          E[14] &= 65535,
          o(p, E, 1 - T)
      }
      for (let C = 0; C < 16; C++)
          x[2 * C] = p[C] & 255,
          x[2 * C + 1] = p[C] >> 8
  }
  function l(x, S) {
      for (let E = 0; E < 16; E++)
          x[E] = S[2 * E] + (S[2 * E + 1] << 8);
      x[15] &= 32767
  }
  function c(x, S, E) {
      for (let p = 0; p < 16; p++)
          x[p] = S[p] + E[p]
  }
  function f(x, S, E) {
      for (let p = 0; p < 16; p++)
          x[p] = S[p] - E[p]
  }
  function d(x, S, E) {
      let p, C, T = 0, O = 0, R = 0, j = 0, L = 0, M = 0, P = 0, A = 0, $ = 0, I = 0, W = 0, B = 0, ee = 0, z = 0, N = 0, F = 0, K = 0, k = 0, Q = 0, U = 0, te = 0, J = 0, Z = 0, G = 0, re = 0, De = 0, ae = 0, Ie = 0, le = 0, je = 0, tr = 0, ce = E[0], Me = E[1], Ae = E[2], he = E[3], X = E[4], oe = E[5], Fe = E[6], Ue = E[7], ve = E[8], it = E[9], st = E[10], at = E[11], ot = E[12], ut = E[13], lt = E[14], ct = E[15];
      p = S[0],
      T += p * ce,
      O += p * Me,
      R += p * Ae,
      j += p * he,
      L += p * X,
      M += p * oe,
      P += p * Fe,
      A += p * Ue,
      $ += p * ve,
      I += p * it,
      W += p * st,
      B += p * at,
      ee += p * ot,
      z += p * ut,
      N += p * lt,
      F += p * ct,
      p = S[1],
      O += p * ce,
      R += p * Me,
      j += p * Ae,
      L += p * he,
      M += p * X,
      P += p * oe,
      A += p * Fe,
      $ += p * Ue,
      I += p * ve,
      W += p * it,
      B += p * st,
      ee += p * at,
      z += p * ot,
      N += p * ut,
      F += p * lt,
      K += p * ct,
      p = S[2],
      R += p * ce,
      j += p * Me,
      L += p * Ae,
      M += p * he,
      P += p * X,
      A += p * oe,
      $ += p * Fe,
      I += p * Ue,
      W += p * ve,
      B += p * it,
      ee += p * st,
      z += p * at,
      N += p * ot,
      F += p * ut,
      K += p * lt,
      k += p * ct,
      p = S[3],
      j += p * ce,
      L += p * Me,
      M += p * Ae,
      P += p * he,
      A += p * X,
      $ += p * oe,
      I += p * Fe,
      W += p * Ue,
      B += p * ve,
      ee += p * it,
      z += p * st,
      N += p * at,
      F += p * ot,
      K += p * ut,
      k += p * lt,
      Q += p * ct,
      p = S[4],
      L += p * ce,
      M += p * Me,
      P += p * Ae,
      A += p * he,
      $ += p * X,
      I += p * oe,
      W += p * Fe,
      B += p * Ue,
      ee += p * ve,
      z += p * it,
      N += p * st,
      F += p * at,
      K += p * ot,
      k += p * ut,
      Q += p * lt,
      U += p * ct,
      p = S[5],
      M += p * ce,
      P += p * Me,
      A += p * Ae,
      $ += p * he,
      I += p * X,
      W += p * oe,
      B += p * Fe,
      ee += p * Ue,
      z += p * ve,
      N += p * it,
      F += p * st,
      K += p * at,
      k += p * ot,
      Q += p * ut,
      U += p * lt,
      te += p * ct,
      p = S[6],
      P += p * ce,
      A += p * Me,
      $ += p * Ae,
      I += p * he,
      W += p * X,
      B += p * oe,
      ee += p * Fe,
      z += p * Ue,
      N += p * ve,
      F += p * it,
      K += p * st,
      k += p * at,
      Q += p * ot,
      U += p * ut,
      te += p * lt,
      J += p * ct,
      p = S[7],
      A += p * ce,
      $ += p * Me,
      I += p * Ae,
      W += p * he,
      B += p * X,
      ee += p * oe,
      z += p * Fe,
      N += p * Ue,
      F += p * ve,
      K += p * it,
      k += p * st,
      Q += p * at,
      U += p * ot,
      te += p * ut,
      J += p * lt,
      Z += p * ct,
      p = S[8],
      $ += p * ce,
      I += p * Me,
      W += p * Ae,
      B += p * he,
      ee += p * X,
      z += p * oe,
      N += p * Fe,
      F += p * Ue,
      K += p * ve,
      k += p * it,
      Q += p * st,
      U += p * at,
      te += p * ot,
      J += p * ut,
      Z += p * lt,
      G += p * ct,
      p = S[9],
      I += p * ce,
      W += p * Me,
      B += p * Ae,
      ee += p * he,
      z += p * X,
      N += p * oe,
      F += p * Fe,
      K += p * Ue,
      k += p * ve,
      Q += p * it,
      U += p * st,
      te += p * at,
      J += p * ot,
      Z += p * ut,
      G += p * lt,
      re += p * ct,
      p = S[10],
      W += p * ce,
      B += p * Me,
      ee += p * Ae,
      z += p * he,
      N += p * X,
      F += p * oe,
      K += p * Fe,
      k += p * Ue,
      Q += p * ve,
      U += p * it,
      te += p * st,
      J += p * at,
      Z += p * ot,
      G += p * ut,
      re += p * lt,
      De += p * ct,
      p = S[11],
      B += p * ce,
      ee += p * Me,
      z += p * Ae,
      N += p * he,
      F += p * X,
      K += p * oe,
      k += p * Fe,
      Q += p * Ue,
      U += p * ve,
      te += p * it,
      J += p * st,
      Z += p * at,
      G += p * ot,
      re += p * ut,
      De += p * lt,
      ae += p * ct,
      p = S[12],
      ee += p * ce,
      z += p * Me,
      N += p * Ae,
      F += p * he,
      K += p * X,
      k += p * oe,
      Q += p * Fe,
      U += p * Ue,
      te += p * ve,
      J += p * it,
      Z += p * st,
      G += p * at,
      re += p * ot,
      De += p * ut,
      ae += p * lt,
      Ie += p * ct,
      p = S[13],
      z += p * ce,
      N += p * Me,
      F += p * Ae,
      K += p * he,
      k += p * X,
      Q += p * oe,
      U += p * Fe,
      te += p * Ue,
      J += p * ve,
      Z += p * it,
      G += p * st,
      re += p * at,
      De += p * ot,
      ae += p * ut,
      Ie += p * lt,
      le += p * ct,
      p = S[14],
      N += p * ce,
      F += p * Me,
      K += p * Ae,
      k += p * he,
      Q += p * X,
      U += p * oe,
      te += p * Fe,
      J += p * Ue,
      Z += p * ve,
      G += p * it,
      re += p * st,
      De += p * at,
      ae += p * ot,
      Ie += p * ut,
      le += p * lt,
      je += p * ct,
      p = S[15],
      F += p * ce,
      K += p * Me,
      k += p * Ae,
      Q += p * he,
      U += p * X,
      te += p * oe,
      J += p * Fe,
      Z += p * Ue,
      G += p * ve,
      re += p * it,
      De += p * st,
      ae += p * at,
      Ie += p * ot,
      le += p * ut,
      je += p * lt,
      tr += p * ct,
      T += 38 * K,
      O += 38 * k,
      R += 38 * Q,
      j += 38 * U,
      L += 38 * te,
      M += 38 * J,
      P += 38 * Z,
      A += 38 * G,
      $ += 38 * re,
      I += 38 * De,
      W += 38 * ae,
      B += 38 * Ie,
      ee += 38 * le,
      z += 38 * je,
      N += 38 * tr,
      C = 1,
      p = T + C + 65535,
      C = Math.floor(p / 65536),
      T = p - C * 65536,
      p = O + C + 65535,
      C = Math.floor(p / 65536),
      O = p - C * 65536,
      p = R + C + 65535,
      C = Math.floor(p / 65536),
      R = p - C * 65536,
      p = j + C + 65535,
      C = Math.floor(p / 65536),
      j = p - C * 65536,
      p = L + C + 65535,
      C = Math.floor(p / 65536),
      L = p - C * 65536,
      p = M + C + 65535,
      C = Math.floor(p / 65536),
      M = p - C * 65536,
      p = P + C + 65535,
      C = Math.floor(p / 65536),
      P = p - C * 65536,
      p = A + C + 65535,
      C = Math.floor(p / 65536),
      A = p - C * 65536,
      p = $ + C + 65535,
      C = Math.floor(p / 65536),
      $ = p - C * 65536,
      p = I + C + 65535,
      C = Math.floor(p / 65536),
      I = p - C * 65536,
      p = W + C + 65535,
      C = Math.floor(p / 65536),
      W = p - C * 65536,
      p = B + C + 65535,
      C = Math.floor(p / 65536),
      B = p - C * 65536,
      p = ee + C + 65535,
      C = Math.floor(p / 65536),
      ee = p - C * 65536,
      p = z + C + 65535,
      C = Math.floor(p / 65536),
      z = p - C * 65536,
      p = N + C + 65535,
      C = Math.floor(p / 65536),
      N = p - C * 65536,
      p = F + C + 65535,
      C = Math.floor(p / 65536),
      F = p - C * 65536,
      T += C - 1 + 37 * (C - 1),
      C = 1,
      p = T + C + 65535,
      C = Math.floor(p / 65536),
      T = p - C * 65536,
      p = O + C + 65535,
      C = Math.floor(p / 65536),
      O = p - C * 65536,
      p = R + C + 65535,
      C = Math.floor(p / 65536),
      R = p - C * 65536,
      p = j + C + 65535,
      C = Math.floor(p / 65536),
      j = p - C * 65536,
      p = L + C + 65535,
      C = Math.floor(p / 65536),
      L = p - C * 65536,
      p = M + C + 65535,
      C = Math.floor(p / 65536),
      M = p - C * 65536,
      p = P + C + 65535,
      C = Math.floor(p / 65536),
      P = p - C * 65536,
      p = A + C + 65535,
      C = Math.floor(p / 65536),
      A = p - C * 65536,
      p = $ + C + 65535,
      C = Math.floor(p / 65536),
      $ = p - C * 65536,
      p = I + C + 65535,
      C = Math.floor(p / 65536),
      I = p - C * 65536,
      p = W + C + 65535,
      C = Math.floor(p / 65536),
      W = p - C * 65536,
      p = B + C + 65535,
      C = Math.floor(p / 65536),
      B = p - C * 65536,
      p = ee + C + 65535,
      C = Math.floor(p / 65536),
      ee = p - C * 65536,
      p = z + C + 65535,
      C = Math.floor(p / 65536),
      z = p - C * 65536,
      p = N + C + 65535,
      C = Math.floor(p / 65536),
      N = p - C * 65536,
      p = F + C + 65535,
      C = Math.floor(p / 65536),
      F = p - C * 65536,
      T += C - 1 + 37 * (C - 1),
      x[0] = T,
      x[1] = O,
      x[2] = R,
      x[3] = j,
      x[4] = L,
      x[5] = M,
      x[6] = P,
      x[7] = A,
      x[8] = $,
      x[9] = I,
      x[10] = W,
      x[11] = B,
      x[12] = ee,
      x[13] = z,
      x[14] = N,
      x[15] = F
  }
  function y(x, S) {
      d(x, S, S)
  }
  function m(x, S) {
      const E = r();
      for (let p = 0; p < 16; p++)
          E[p] = S[p];
      for (let p = 253; p >= 0; p--)
          y(E, E),
          p !== 2 && p !== 4 && d(E, E, S);
      for (let p = 0; p < 16; p++)
          x[p] = E[p]
  }
  function v(x, S) {
      const E = new Uint8Array(32)
        , p = new Float64Array(80)
        , C = r()
        , T = r()
        , O = r()
        , R = r()
        , j = r()
        , L = r();
      for (let $ = 0; $ < 31; $++)
          E[$] = x[$];
      E[31] = x[31] & 127 | 64,
      E[0] &= 248,
      l(p, S);
      for (let $ = 0; $ < 16; $++)
          T[$] = p[$];
      C[0] = R[0] = 1;
      for (let $ = 254; $ >= 0; --$) {
          const I = E[$ >>> 3] >>> ($ & 7) & 1;
          o(C, T, I),
          o(O, R, I),
          c(j, C, O),
          f(C, C, O),
          c(O, T, R),
          f(T, T, R),
          y(R, j),
          y(L, C),
          d(C, O, C),
          d(O, T, j),
          c(j, C, O),
          f(C, C, O),
          y(T, C),
          f(O, R, L),
          d(C, O, s),
          c(C, C, R),
          d(O, O, C),
          d(C, R, L),
          d(R, T, p),
          y(T, j),
          o(C, T, I),
          o(O, R, I)
      }
      for (let $ = 0; $ < 16; $++)
          p[$ + 16] = C[$],
          p[$ + 32] = O[$],
          p[$ + 48] = T[$],
          p[$ + 64] = R[$];
      const M = p.subarray(32)
        , P = p.subarray(16);
      m(M, M),
      d(P, P, M);
      const A = new Uint8Array(32);
      return u(A, P),
      A
  }
  e.scalarMult = v;
  function b(x) {
      return v(x, i)
  }
  e.scalarMultBase = b;
  function w(x) {
      if (x.length !== e.SECRET_KEY_LENGTH)
          throw new Error(`x25519: seed must be ${e.SECRET_KEY_LENGTH} bytes`);
      const S = new Uint8Array(x);
      return {
          publicKey: b(S),
          secretKey: S
      }
  }
  e.generateKeyPairFromSeed = w;
  function h(x) {
      const S = (0,
      t.randomBytes)(32, x)
        , E = w(S);
      return (0,
      n.wipe)(S),
      E
  }
  e.generateKeyPair = h;
  function g(x, S, E=!1) {
      if (x.length !== e.PUBLIC_KEY_LENGTH)
          throw new Error("X25519: incorrect secret key length");
      if (S.length !== e.PUBLIC_KEY_LENGTH)
          throw new Error("X25519: incorrect public key length");
      const p = v(x, S);
      if (E) {
          let C = 0;
          for (let T = 0; T < p.length; T++)
              C |= p[T];
          if (C === 0)
              throw new Error("X25519: invalid shared key")
      }
      return p
  }
  e.sharedKey = g
}
)(py);
function hy(e) {
  return globalThis.Buffer != null ? new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : e
}
function gE(e=0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? hy(globalThis.Buffer.allocUnsafe(e)) : new Uint8Array(e)
}
function lv(e, t) {
  t || (t = e.reduce( (i, s) => i + s.length, 0));
  const n = gE(t);
  let r = 0;
  for (const i of e)
      n.set(i, r),
      r += i.length;
  return hy(n)
}
function iD(e, t) {
  if (e.length >= 255)
      throw new TypeError("Alphabet too long");
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++)
      n[r] = 255;
  for (var i = 0; i < e.length; i++) {
      var s = e.charAt(i)
        , a = s.charCodeAt(0);
      if (n[a] !== 255)
          throw new TypeError(s + " is ambiguous");
      n[a] = i
  }
  var o = e.length
    , u = e.charAt(0)
    , l = Math.log(o) / Math.log(256)
    , c = Math.log(256) / Math.log(o);
  function f(m) {
      if (m instanceof Uint8Array || (ArrayBuffer.isView(m) ? m = new Uint8Array(m.buffer,m.byteOffset,m.byteLength) : Array.isArray(m) && (m = Uint8Array.from(m))),
      !(m instanceof Uint8Array))
          throw new TypeError("Expected Uint8Array");
      if (m.length === 0)
          return "";
      for (var v = 0, b = 0, w = 0, h = m.length; w !== h && m[w] === 0; )
          w++,
          v++;
      for (var g = (h - w) * c + 1 >>> 0, x = new Uint8Array(g); w !== h; ) {
          for (var S = m[w], E = 0, p = g - 1; (S !== 0 || E < b) && p !== -1; p--,
          E++)
              S += 256 * x[p] >>> 0,
              x[p] = S % o >>> 0,
              S = S / o >>> 0;
          if (S !== 0)
              throw new Error("Non-zero carry");
          b = E,
          w++
      }
      for (var C = g - b; C !== g && x[C] === 0; )
          C++;
      for (var T = u.repeat(v); C < g; ++C)
          T += e.charAt(x[C]);
      return T
  }
  function d(m) {
      if (typeof m != "string")
          throw new TypeError("Expected String");
      if (m.length === 0)
          return new Uint8Array;
      var v = 0;
      if (m[v] !== " ") {
          for (var b = 0, w = 0; m[v] === u; )
              b++,
              v++;
          for (var h = (m.length - v) * l + 1 >>> 0, g = new Uint8Array(h); m[v]; ) {
              var x = n[m.charCodeAt(v)];
              if (x === 255)
                  return;
              for (var S = 0, E = h - 1; (x !== 0 || S < w) && E !== -1; E--,
              S++)
                  x += o * g[E] >>> 0,
                  g[E] = x % 256 >>> 0,
                  x = x / 256 >>> 0;
              if (x !== 0)
                  throw new Error("Non-zero carry");
              w = S,
              v++
          }
          if (m[v] !== " ") {
              for (var p = h - w; p !== h && g[p] === 0; )
                  p++;
              for (var C = new Uint8Array(b + (h - p)), T = b; p !== h; )
                  C[T++] = g[p++];
              return C
          }
      }
  }
  function y(m) {
      var v = d(m);
      if (v)
          return v;
      throw new Error(`Non-${t} character`)
  }
  return {
      encode: f,
      decodeUnsafe: d,
      decode: y
  }
}
var sD = iD
, aD = sD;
const oD = e => {
  if (e instanceof Uint8Array && e.constructor.name === "Uint8Array")
      return e;
  if (e instanceof ArrayBuffer)
      return new Uint8Array(e);
  if (ArrayBuffer.isView(e))
      return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);
  throw new Error("Unknown type, must be binary type")
}
, uD = e => new TextEncoder().encode(e)
, lD = e => new TextDecoder().decode(e);
class cD {
  constructor(t, n, r) {
      this.name = t,
      this.prefix = n,
      this.baseEncode = r
  }
  encode(t) {
      if (t instanceof Uint8Array)
          return `${this.prefix}${this.baseEncode(t)}`;
      throw Error("Unknown type, must be binary type")
  }
}
class fD {
  constructor(t, n, r) {
      if (this.name = t,
      this.prefix = n,
      n.codePointAt(0) === void 0)
          throw new Error("Invalid prefix character");
      this.prefixCodePoint = n.codePointAt(0),
      this.baseDecode = r
  }
  decode(t) {
      if (typeof t == "string") {
          if (t.codePointAt(0) !== this.prefixCodePoint)
              throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          return this.baseDecode(t.slice(this.prefix.length))
      } else
          throw Error("Can only multibase decode strings")
  }
  or(t) {
      return vE(this, t)
  }
}
class dD {
  constructor(t) {
      this.decoders = t
  }
  or(t) {
      return vE(this, t)
  }
  decode(t) {
      const n = t[0]
        , r = this.decoders[n];
      if (r)
          return r.decode(t);
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
  }
}
const vE = (e, t) => new dD({
  ...e.decoders || {
      [e.prefix]: e
  },
  ...t.decoders || {
      [t.prefix]: t
  }
});
class pD {
  constructor(t, n, r, i) {
      this.name = t,
      this.prefix = n,
      this.baseEncode = r,
      this.baseDecode = i,
      this.encoder = new cD(t,n,r),
      this.decoder = new fD(t,n,i)
  }
  encode(t) {
      return this.encoder.encode(t)
  }
  decode(t) {
      return this.decoder.decode(t)
  }
}
const Hc = ({name: e, prefix: t, encode: n, decode: r}) => new pD(e,t,n,r)
, So = ({prefix: e, name: t, alphabet: n}) => {
  const {encode: r, decode: i} = aD(n, t);
  return Hc({
      prefix: e,
      name: t,
      encode: r,
      decode: s => oD(i(s))
  })
}
, hD = (e, t, n, r) => {
  const i = {};
  for (let c = 0; c < t.length; ++c)
      i[t[c]] = c;
  let s = e.length;
  for (; e[s - 1] === "="; )
      --s;
  const a = new Uint8Array(s * n / 8 | 0);
  let o = 0
    , u = 0
    , l = 0;
  for (let c = 0; c < s; ++c) {
      const f = i[e[c]];
      if (f === void 0)
          throw new SyntaxError(`Non-${r} character`);
      u = u << n | f,
      o += n,
      o >= 8 && (o -= 8,
      a[l++] = 255 & u >> o)
  }
  if (o >= n || 255 & u << 8 - o)
      throw new SyntaxError("Unexpected end of data");
  return a
}
, mD = (e, t, n) => {
  const r = t[t.length - 1] === "="
    , i = (1 << n) - 1;
  let s = ""
    , a = 0
    , o = 0;
  for (let u = 0; u < e.length; ++u)
      for (o = o << 8 | e[u],
      a += 8; a > n; )
          a -= n,
          s += t[i & o >> a];
  if (a && (s += t[i & o << n - a]),
  r)
      for (; s.length * n & 7; )
          s += "=";
  return s
}
, rt = ({name: e, prefix: t, bitsPerChar: n, alphabet: r}) => Hc({
  prefix: t,
  name: e,
  encode(i) {
      return mD(i, r, n)
  },
  decode(i) {
      return hD(i, r, n, e)
  }
})
, yD = Hc({
  prefix: "\0",
  name: "identity",
  encode: e => lD(e),
  decode: e => uD(e)
})
, gD = Object.freeze(Object.defineProperty({
  __proto__: null,
  identity: yD
}, Symbol.toStringTag, {
  value: "Module"
}))
, vD = rt({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
})
, wD = Object.freeze(Object.defineProperty({
  __proto__: null,
  base2: vD
}, Symbol.toStringTag, {
  value: "Module"
}))
, bD = rt({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
})
, xD = Object.freeze(Object.defineProperty({
  __proto__: null,
  base8: bD
}, Symbol.toStringTag, {
  value: "Module"
}))
, ED = So({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
})
, SD = Object.freeze(Object.defineProperty({
  __proto__: null,
  base10: ED
}, Symbol.toStringTag, {
  value: "Module"
}))
, CD = rt({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
})
, _D = rt({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
})
, PD = Object.freeze(Object.defineProperty({
  __proto__: null,
  base16: CD,
  base16upper: _D
}, Symbol.toStringTag, {
  value: "Module"
}))
, TD = rt({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
})
, OD = rt({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
})
, kD = rt({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
})
, DD = rt({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
})
, ID = rt({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
})
, AD = rt({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
})
, $D = rt({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
})
, RD = rt({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
})
, ND = rt({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
})
, jD = Object.freeze(Object.defineProperty({
  __proto__: null,
  base32: TD,
  base32hex: ID,
  base32hexpad: $D,
  base32hexpadupper: RD,
  base32hexupper: AD,
  base32pad: kD,
  base32padupper: DD,
  base32upper: OD,
  base32z: ND
}, Symbol.toStringTag, {
  value: "Module"
}))
, MD = So({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
})
, LD = So({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
})
, FD = Object.freeze(Object.defineProperty({
  __proto__: null,
  base36: MD,
  base36upper: LD
}, Symbol.toStringTag, {
  value: "Module"
}))
, UD = So({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
})
, zD = So({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
})
, BD = Object.freeze(Object.defineProperty({
  __proto__: null,
  base58btc: UD,
  base58flickr: zD
}, Symbol.toStringTag, {
  value: "Module"
}))
, WD = rt({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
})
, HD = rt({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
})
, qD = rt({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
})
, VD = rt({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
})
, KD = Object.freeze(Object.defineProperty({
  __proto__: null,
  base64: WD,
  base64pad: HD,
  base64url: qD,
  base64urlpad: VD
}, Symbol.toStringTag, {
  value: "Module"
}))
, wE = Array.from("")
, GD = wE.reduce( (e, t, n) => (e[n] = t,
e), [])
, QD = wE.reduce( (e, t, n) => (e[t.codePointAt(0)] = n,
e), []);
function YD(e) {
  return e.reduce( (t, n) => (t += GD[n],
  t), "")
}
function XD(e) {
  const t = [];
  for (const n of e) {
      const r = QD[n.codePointAt(0)];
      if (r === void 0)
          throw new Error(`Non-base256emoji character: ${n}`);
      t.push(r)
  }
  return new Uint8Array(t)
}
const JD = Hc({
  prefix: "",
  name: "base256emoji",
  encode: YD,
  decode: XD
})
, ZD = Object.freeze(Object.defineProperty({
  __proto__: null,
  base256emoji: JD
}, Symbol.toStringTag, {
  value: "Module"
}));
new TextEncoder;
new TextDecoder;
const cv = {
  ...gD,
  ...wD,
  ...xD,
  ...SD,
  ...PD,
  ...jD,
  ...FD,
  ...BD,
  ...KD,
  ...ZD
};
function bE(e, t, n, r) {
  return {
      name: e,
      prefix: t,
      encoder: {
          name: e,
          prefix: t,
          encode: n
      },
      decoder: {
          decode: r
      }
  }
}
const fv = bE("utf8", "u", e => "u" + new TextDecoder("utf8").decode(e), e => new TextEncoder().encode(e.substring(1)))
, id = bE("ascii", "a", e => {
  let t = "a";
  for (let n = 0; n < e.length; n++)
      t += String.fromCharCode(e[n]);
  return t
}
, e => {
  e = e.substring(1);
  const t = gE(e.length);
  for (let n = 0; n < e.length; n++)
      t[n] = e.charCodeAt(n);
  return t
}
)
, xE = {
  utf8: fv,
  "utf-8": fv,
  hex: cv.base16,
  latin1: id,
  ascii: id,
  binary: id,
  ...cv
};
function fn(e, t="utf8") {
  const n = xE[t];
  if (!n)
      throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? hy(globalThis.Buffer.from(e, "utf-8")) : n.decoder.decode(`${n.prefix}${e}`)
}
function yn(e, t="utf8") {
  const n = xE[t];
  if (!n)
      throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString("utf8") : n.encoder.encode(e).substring(1)
}
var dv = function(e, t, n) {
  if (n || arguments.length === 2)
      for (var r = 0, i = t.length, s; r < i; r++)
          (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)),
          s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t))
}
, e4 = function() {
  function e(t, n, r) {
      this.name = t,
      this.version = n,
      this.os = r,
      this.type = "browser"
  }
  return e
}()
, t4 = function() {
  function e(t) {
      this.version = t,
      this.type = "node",
      this.name = "node",
      this.os = process.platform
  }
  return e
}()
, n4 = function() {
  function e(t, n, r, i) {
      this.name = t,
      this.version = n,
      this.os = r,
      this.bot = i,
      this.type = "bot-device"
  }
  return e
}()
, r4 = function() {
  function e() {
      this.type = "bot",
      this.bot = !0,
      this.name = "bot",
      this.version = null,
      this.os = null
  }
  return e
}()
, i4 = function() {
  function e() {
      this.type = "react-native",
      this.name = "react-native",
      this.version = null,
      this.os = null
  }
  return e
}()
, s4 = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/
, a4 = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/
, pv = 3
, o4 = [["aol", /AOLShield\/([0-9\._]+)/], ["edge", /Edge\/([0-9\._]+)/], ["edge-ios", /EdgiOS\/([0-9\._]+)/], ["yandexbrowser", /YaBrowser\/([0-9\._]+)/], ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/], ["samsung", /SamsungBrowser\/([0-9\.]+)/], ["silk", /\bSilk\/([0-9._-]+)\b/], ["miui", /MiuiBrowser\/([0-9\.]+)$/], ["beaker", /BeakerBrowser\/([0-9\.]+)/], ["edge-chromium", /EdgA?\/([0-9\.]+)/], ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/], ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/], ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/], ["fxios", /FxiOS\/([0-9\.]+)/], ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/], ["opera", /Opera\/([0-9\.]+)(?:\s|$)/], ["opera", /OPR\/([0-9\.]+)(:?\s|$)/], ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/], ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/], ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/], ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ["ie", /MSIE\s(7\.0)/], ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/], ["android", /Android\s([0-9\.]+)/], ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/], ["safari", /Version\/([0-9\._]+).*Safari/], ["facebook", /FB[AS]V\/([0-9\.]+)/], ["instagram", /Instagram\s([0-9\.]+)/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ["curl", /^curl\/([0-9\.]+)$/], ["searchbot", s4]]
, hv = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
function u4(e) {
  return e ? mv(e) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new i4 : typeof navigator < "u" ? mv(navigator.userAgent) : f4()
}
function l4(e) {
  return e !== "" && o4.reduce(function(t, n) {
      var r = n[0]
        , i = n[1];
      if (t)
          return t;
      var s = i.exec(e);
      return !!s && [r, s]
  }, !1)
}
function mv(e) {
  var t = l4(e);
  if (!t)
      return null;
  var n = t[0]
    , r = t[1];
  if (n === "searchbot")
      return new r4;
  var i = r[1] && r[1].split(".").join("_").split("_").slice(0, 3);
  i ? i.length < pv && (i = dv(dv([], i, !0), d4(pv - i.length), !0)) : i = [];
  var s = i.join(".")
    , a = c4(e)
    , o = a4.exec(e);
  return o && o[1] ? new n4(n,s,a,o[1]) : new e4(n,s,a)
}
function c4(e) {
  for (var t = 0, n = hv.length; t < n; t++) {
      var r = hv[t]
        , i = r[0]
        , s = r[1]
        , a = s.exec(e);
      if (a)
          return i
  }
  return null
}
function f4() {
  var e = typeof process < "u" && process.version;
  return e ? new t4(process.version.slice(1)) : null
}
function d4(e) {
  for (var t = [], n = 0; n < e; n++)
      t.push("0");
  return t
}
var ui = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Zp = function(e, t) {
  return Zp = Object.setPrototypeOf || {
      __proto__: []
  }instanceof Array && function(n, r) {
      n.__proto__ = r
  }
  || function(n, r) {
      for (var i in r)
          r.hasOwnProperty(i) && (n[i] = r[i])
  }
  ,
  Zp(e, t)
};
function p4(e, t) {
  Zp(e, t);
  function n() {
      this.constructor = e
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype,
  new n)
}
var eh = function() {
  return eh = Object.assign || function(t) {
      for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var s in n)
              Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s])
      }
      return t
  }
  ,
  eh.apply(this, arguments)
};
function h4(e, t) {
  var n = {};
  for (var r in e)
      Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
      for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
          t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n
}
function m4(e, t, n, r) {
  var i = arguments.length, s = i < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, n) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      s = Reflect.decorate(e, t, n, r);
  else
      for (var o = e.length - 1; o >= 0; o--)
          (a = e[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(t, n, s) : a(t, n)) || s);
  return i > 3 && s && Object.defineProperty(t, n, s),
  s
}
function y4(e, t) {
  return function(n, r) {
      t(n, r, e)
  }
}
function g4(e, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
      return Reflect.metadata(e, t)
}
function v4(e, t, n, r) {
  function i(s) {
      return s instanceof n ? s : new n(function(a) {
          a(s)
      }
      )
  }
  return new (n || (n = Promise))(function(s, a) {
      function o(c) {
          try {
              l(r.next(c))
          } catch (f) {
              a(f)
          }
      }
      function u(c) {
          try {
              l(r.throw(c))
          } catch (f) {
              a(f)
          }
      }
      function l(c) {
          c.done ? s(c.value) : i(c.value).then(o, u)
      }
      l((r = r.apply(e, t || [])).next())
  }
  )
}
function w4(e, t) {
  var n = {
      label: 0,
      sent: function() {
          if (s[0] & 1)
              throw s[1];
          return s[1]
      },
      trys: [],
      ops: []
  }, r, i, s, a;
  return a = {
      next: o(0),
      throw: o(1),
      return: o(2)
  },
  typeof Symbol == "function" && (a[Symbol.iterator] = function() {
      return this
  }
  ),
  a;
  function o(l) {
      return function(c) {
          return u([l, c])
      }
  }
  function u(l) {
      if (r)
          throw new TypeError("Generator is already executing.");
      for (; n; )
          try {
              if (r = 1,
              i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i),
              0) : i.next) && !(s = s.call(i, l[1])).done)
                  return s;
              switch (i = 0,
              s && (l = [l[0] & 2, s.value]),
              l[0]) {
              case 0:
              case 1:
                  s = l;
                  break;
              case 4:
                  return n.label++,
                  {
                      value: l[1],
                      done: !1
                  };
              case 5:
                  n.label++,
                  i = l[1],
                  l = [0];
                  continue;
              case 7:
                  l = n.ops.pop(),
                  n.trys.pop();
                  continue;
              default:
                  if (s = n.trys,
                  !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
                      n = 0;
                      continue
                  }
                  if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
                      n.label = l[1];
                      break
                  }
                  if (l[0] === 6 && n.label < s[1]) {
                      n.label = s[1],
                      s = l;
                      break
                  }
                  if (s && n.label < s[2]) {
                      n.label = s[2],
                      n.ops.push(l);
                      break
                  }
                  s[2] && n.ops.pop(),
                  n.trys.pop();
                  continue
              }
              l = t.call(e, n)
          } catch (c) {
              l = [6, c],
              i = 0
          } finally {
              r = s = 0
          }
      if (l[0] & 5)
          throw l[1];
      return {
          value: l[0] ? l[1] : void 0,
          done: !0
      }
  }
}
function b4(e, t, n, r) {
  r === void 0 && (r = n),
  e[r] = t[n]
}
function x4(e, t) {
  for (var n in e)
      n !== "default" && !t.hasOwnProperty(n) && (t[n] = e[n])
}
function th(e) {
  var t = typeof Symbol == "function" && Symbol.iterator
    , n = t && e[t]
    , r = 0;
  if (n)
      return n.call(e);
  if (e && typeof e.length == "number")
      return {
          next: function() {
              return e && r >= e.length && (e = void 0),
              {
                  value: e && e[r++],
                  done: !e
              }
          }
      };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function EE(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n)
      return e;
  var r = n.call(e), i, s = [], a;
  try {
      for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; )
          s.push(i.value)
  } catch (o) {
      a = {
          error: o
      }
  } finally {
      try {
          i && !i.done && (n = r.return) && n.call(r)
      } finally {
          if (a)
              throw a.error
      }
  }
  return s
}
function E4() {
  for (var e = [], t = 0; t < arguments.length; t++)
      e = e.concat(EE(arguments[t]));
  return e
}
function S4() {
  for (var e = 0, t = 0, n = arguments.length; t < n; t++)
      e += arguments[t].length;
  for (var r = Array(e), i = 0, t = 0; t < n; t++)
      for (var s = arguments[t], a = 0, o = s.length; a < o; a++,
      i++)
          r[i] = s[a];
  return r
}
function Ja(e) {
  return this instanceof Ja ? (this.v = e,
  this) : new Ja(e)
}
function C4(e, t, n) {
  if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), i, s = [];
  return i = {},
  a("next"),
  a("throw"),
  a("return"),
  i[Symbol.asyncIterator] = function() {
      return this
  }
  ,
  i;
  function a(d) {
      r[d] && (i[d] = function(y) {
          return new Promise(function(m, v) {
              s.push([d, y, m, v]) > 1 || o(d, y)
          }
          )
      }
      )
  }
  function o(d, y) {
      try {
          u(r[d](y))
      } catch (m) {
          f(s[0][3], m)
      }
  }
  function u(d) {
      d.value instanceof Ja ? Promise.resolve(d.value.v).then(l, c) : f(s[0][2], d)
  }
  function l(d) {
      o("next", d)
  }
  function c(d) {
      o("throw", d)
  }
  function f(d, y) {
      d(y),
      s.shift(),
      s.length && o(s[0][0], s[0][1])
  }
}
function _4(e) {
  var t, n;
  return t = {},
  r("next"),
  r("throw", function(i) {
      throw i
  }),
  r("return"),
  t[Symbol.iterator] = function() {
      return this
  }
  ,
  t;
  function r(i, s) {
      t[i] = e[i] ? function(a) {
          return (n = !n) ? {
              value: Ja(e[i](a)),
              done: i === "return"
          } : s ? s(a) : a
      }
      : s
  }
}
function P4(e) {
  if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], n;
  return t ? t.call(e) : (e = typeof th == "function" ? th(e) : e[Symbol.iterator](),
  n = {},
  r("next"),
  r("throw"),
  r("return"),
  n[Symbol.asyncIterator] = function() {
      return this
  }
  ,
  n);
  function r(s) {
      n[s] = e[s] && function(a) {
          return new Promise(function(o, u) {
              a = e[s](a),
              i(o, u, a.done, a.value)
          }
          )
      }
  }
  function i(s, a, o, u) {
      Promise.resolve(u).then(function(l) {
          s({
              value: l,
              done: o
          })
      }, a)
  }
}
function T4(e, t) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", {
      value: t
  }) : e.raw = t,
  e
}
function O4(e) {
  if (e && e.__esModule)
      return e;
  var t = {};
  if (e != null)
      for (var n in e)
          Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
  return t.default = e,
  t
}
function k4(e) {
  return e && e.__esModule ? e : {
      default: e
  }
}
function D4(e, t) {
  if (!t.has(e))
      throw new TypeError("attempted to get private field on non-instance");
  return t.get(e)
}
function I4(e, t, n) {
  if (!t.has(e))
      throw new TypeError("attempted to set private field on non-instance");
  return t.set(e, n),
  n
}
const A4 = Object.freeze(Object.defineProperty({
  __proto__: null,
  get __assign() {
      return eh
  },
  __asyncDelegator: _4,
  __asyncGenerator: C4,
  __asyncValues: P4,
  __await: Ja,
  __awaiter: v4,
  __classPrivateFieldGet: D4,
  __classPrivateFieldSet: I4,
  __createBinding: b4,
  __decorate: m4,
  __exportStar: x4,
  __extends: p4,
  __generator: w4,
  __importDefault: k4,
  __importStar: O4,
  __makeTemplateObject: T4,
  __metadata: g4,
  __param: y4,
  __read: EE,
  __rest: h4,
  __spread: E4,
  __spreadArrays: S4,
  __values: th
}, Symbol.toStringTag, {
  value: "Module"
}))
, qc = cw(A4);
var sd = {}, Vs = {}, yv;
function $4() {
  if (yv)
      return Vs;
  yv = 1,
  Object.defineProperty(Vs, "__esModule", {
      value: !0
  }),
  Vs.delay = void 0;
  function e(t) {
      return new Promise(n => {
          setTimeout( () => {
              n(!0)
          }
          , t)
      }
      )
  }
  return Vs.delay = e,
  Vs
}
var Kr = {}, ad = {}, Gr = {}, gv;
function R4() {
  return gv || (gv = 1,
  Object.defineProperty(Gr, "__esModule", {
      value: !0
  }),
  Gr.ONE_THOUSAND = Gr.ONE_HUNDRED = void 0,
  Gr.ONE_HUNDRED = 100,
  Gr.ONE_THOUSAND = 1e3),
  Gr
}
var od = {}, vv;
function N4() {
  return vv || (vv = 1,
  function(e) {
      Object.defineProperty(e, "__esModule", {
          value: !0
      }),
      e.ONE_YEAR = e.FOUR_WEEKS = e.THREE_WEEKS = e.TWO_WEEKS = e.ONE_WEEK = e.THIRTY_DAYS = e.SEVEN_DAYS = e.FIVE_DAYS = e.THREE_DAYS = e.ONE_DAY = e.TWENTY_FOUR_HOURS = e.TWELVE_HOURS = e.SIX_HOURS = e.THREE_HOURS = e.ONE_HOUR = e.SIXTY_MINUTES = e.THIRTY_MINUTES = e.TEN_MINUTES = e.FIVE_MINUTES = e.ONE_MINUTE = e.SIXTY_SECONDS = e.THIRTY_SECONDS = e.TEN_SECONDS = e.FIVE_SECONDS = e.ONE_SECOND = void 0,
      e.ONE_SECOND = 1,
      e.FIVE_SECONDS = 5,
      e.TEN_SECONDS = 10,
      e.THIRTY_SECONDS = 30,
      e.SIXTY_SECONDS = 60,
      e.ONE_MINUTE = e.SIXTY_SECONDS,
      e.FIVE_MINUTES = e.ONE_MINUTE * 5,
      e.TEN_MINUTES = e.ONE_MINUTE * 10,
      e.THIRTY_MINUTES = e.ONE_MINUTE * 30,
      e.SIXTY_MINUTES = e.ONE_MINUTE * 60,
      e.ONE_HOUR = e.SIXTY_MINUTES,
      e.THREE_HOURS = e.ONE_HOUR * 3,
      e.SIX_HOURS = e.ONE_HOUR * 6,
      e.TWELVE_HOURS = e.ONE_HOUR * 12,
      e.TWENTY_FOUR_HOURS = e.ONE_HOUR * 24,
      e.ONE_DAY = e.TWENTY_FOUR_HOURS,
      e.THREE_DAYS = e.ONE_DAY * 3,
      e.FIVE_DAYS = e.ONE_DAY * 5,
      e.SEVEN_DAYS = e.ONE_DAY * 7,
      e.THIRTY_DAYS = e.ONE_DAY * 30,
      e.ONE_WEEK = e.SEVEN_DAYS,
      e.TWO_WEEKS = e.ONE_WEEK * 2,
      e.THREE_WEEKS = e.ONE_WEEK * 3,
      e.FOUR_WEEKS = e.ONE_WEEK * 4,
      e.ONE_YEAR = e.ONE_DAY * 365
  }(od)),
  od
}
var wv;
function SE() {
  return wv || (wv = 1,
  function(e) {
      Object.defineProperty(e, "__esModule", {
          value: !0
      });
      const t = qc;
      t.__exportStar(R4(), e),
      t.__exportStar(N4(), e)
  }(ad)),
  ad
}
var bv;
function j4() {
  if (bv)
      return Kr;
  bv = 1,
  Object.defineProperty(Kr, "__esModule", {
      value: !0
  }),
  Kr.fromMiliseconds = Kr.toMiliseconds = void 0;
  const e = SE();
  function t(r) {
      return r * e.ONE_THOUSAND
  }
  Kr.toMiliseconds = t;
  function n(r) {
      return Math.floor(r / e.ONE_THOUSAND)
  }
  return Kr.fromMiliseconds = n,
  Kr
}
var xv;
function M4() {
  return xv || (xv = 1,
  function(e) {
      Object.defineProperty(e, "__esModule", {
          value: !0
      });
      const t = qc;
      t.__exportStar($4(), e),
      t.__exportStar(j4(), e)
  }(sd)),
  sd
}
var ki = {}, Ev;
function L4() {
  if (Ev)
      return ki;
  Ev = 1,
  Object.defineProperty(ki, "__esModule", {
      value: !0
  }),
  ki.Watch = void 0;
  class e {
      constructor() {
          this.timestamps = new Map
      }
      start(n) {
          if (this.timestamps.has(n))
              throw new Error(`Watch already started for label: ${n}`);
          this.timestamps.set(n, {
              started: Date.now()
          })
      }
      stop(n) {
          const r = this.get(n);
          if (typeof r.elapsed < "u")
              throw new Error(`Watch already stopped for label: ${n}`);
          const i = Date.now() - r.started;
          this.timestamps.set(n, {
              started: r.started,
              elapsed: i
          })
      }
      get(n) {
          const r = this.timestamps.get(n);
          if (typeof r > "u")
              throw new Error(`No timestamp found for label: ${n}`);
          return r
      }
      elapsed(n) {
          const r = this.get(n);
          return r.elapsed || Date.now() - r.started
      }
  }
  return ki.Watch = e,
  ki.default = e,
  ki
}
var ud = {}, Ks = {}, Sv;
function F4() {
  if (Sv)
      return Ks;
  Sv = 1,
  Object.defineProperty(Ks, "__esModule", {
      value: !0
  }),
  Ks.IWatch = void 0;
  class e {
  }
  return Ks.IWatch = e,
  Ks
}
var Cv;
function U4() {
  return Cv || (Cv = 1,
  function(e) {
      Object.defineProperty(e, "__esModule", {
          value: !0
      }),
      qc.__exportStar(F4(), e)
  }(ud)),
  ud
}
(function(e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
  });
  const t = qc;
  t.__exportStar(M4(), e),
  t.__exportStar(L4(), e),
  t.__exportStar(U4(), e),
  t.__exportStar(SE(), e)
}
)(ui);
var ye = {};
Object.defineProperty(ye, "__esModule", {
  value: !0
});
ye.getLocalStorage = ye.getLocalStorageOrThrow = ye.getCrypto = ye.getCryptoOrThrow = CE = ye.getLocation = ye.getLocationOrThrow = yy = ye.getNavigator = ye.getNavigatorOrThrow = my = ye.getDocument = ye.getDocumentOrThrow = ye.getFromWindowOrThrow = ye.getFromWindow = void 0;
function bi(e) {
  let t;
  return typeof window < "u" && typeof window[e] < "u" && (t = window[e]),
  t
}
ye.getFromWindow = bi;
function Os(e) {
  const t = bi(e);
  if (!t)
      throw new Error(`${e} is not defined in Window`);
  return t
}
ye.getFromWindowOrThrow = Os;
function z4() {
  return Os("document")
}
ye.getDocumentOrThrow = z4;
function B4() {
  return bi("document")
}
var my = ye.getDocument = B4;
function W4() {
  return Os("navigator")
}
ye.getNavigatorOrThrow = W4;
function H4() {
  return bi("navigator")
}
var yy = ye.getNavigator = H4;
function q4() {
  return Os("location")
}
ye.getLocationOrThrow = q4;
function V4() {
  return bi("location")
}
var CE = ye.getLocation = V4;
function K4() {
  return Os("crypto")
}
ye.getCryptoOrThrow = K4;
function G4() {
  return bi("crypto")
}
ye.getCrypto = G4;
function Q4() {
  return Os("localStorage")
}
ye.getLocalStorageOrThrow = Q4;
function Y4() {
  return bi("localStorage")
}
ye.getLocalStorage = Y4;
var gy = {};
Object.defineProperty(gy, "__esModule", {
  value: !0
});
var _E = gy.getWindowMetadata = void 0;
const _v = ye;
function X4() {
  let e, t;
  try {
      e = _v.getDocumentOrThrow(),
      t = _v.getLocationOrThrow()
  } catch {
      return null
  }
  function n() {
      const f = e.getElementsByTagName("link")
        , d = [];
      for (let y = 0; y < f.length; y++) {
          const m = f[y]
            , v = m.getAttribute("rel");
          if (v && v.toLowerCase().indexOf("icon") > -1) {
              const b = m.getAttribute("href");
              if (b)
                  if (b.toLowerCase().indexOf("https:") === -1 && b.toLowerCase().indexOf("http:") === -1 && b.indexOf("//") !== 0) {
                      let w = t.protocol + "//" + t.host;
                      if (b.indexOf("/") === 0)
                          w += b;
                      else {
                          const h = t.pathname.split("/");
                          h.pop();
                          const g = h.join("/");
                          w += g + "/" + b
                      }
                      d.push(w)
                  } else if (b.indexOf("//") === 0) {
                      const w = t.protocol + b;
                      d.push(w)
                  } else
                      d.push(b)
          }
      }
      return d
  }
  function r(...f) {
      const d = e.getElementsByTagName("meta");
      for (let y = 0; y < d.length; y++) {
          const m = d[y]
            , v = ["itemprop", "property", "name"].map(b => m.getAttribute(b)).filter(b => b ? f.includes(b) : !1);
          if (v.length && v) {
              const b = m.getAttribute("content");
              if (b)
                  return b
          }
      }
      return ""
  }
  function i() {
      let f = r("name", "og:site_name", "og:title", "twitter:title");
      return f || (f = e.title),
      f
  }
  function s() {
      return r("description", "og:description", "twitter:description", "keywords")
  }
  const a = i()
    , o = s()
    , u = t.origin
    , l = n();
  return {
      description: o,
      url: u,
      icons: l,
      name: a
  }
}
_E = gy.getWindowMetadata = X4;
var Za = {}
, J4 = e => encodeURIComponent(e).replace(/[!'()*]/g, t => `%${t.charCodeAt(0).toString(16).toUpperCase()}`)
, PE = "%[a-f0-9]{2}"
, Pv = new RegExp("(" + PE + ")|([^%]+?)","gi")
, Tv = new RegExp("(" + PE + ")+","gi");
function nh(e, t) {
  try {
      return [decodeURIComponent(e.join(""))]
  } catch {}
  if (e.length === 1)
      return e;
  t = t || 1;
  var n = e.slice(0, t)
    , r = e.slice(t);
  return Array.prototype.concat.call([], nh(n), nh(r))
}
function Z4(e) {
  try {
      return decodeURIComponent(e)
  } catch {
      for (var t = e.match(Pv) || [], n = 1; n < t.length; n++)
          e = nh(t, n).join(""),
          t = e.match(Pv) || [];
      return e
  }
}
function eI(e) {
  for (var t = {
      "%FE%FF": "",
      "%FF%FE": ""
  }, n = Tv.exec(e); n; ) {
      try {
          t[n[0]] = decodeURIComponent(n[0])
      } catch {
          var r = Z4(n[0]);
          r !== n[0] && (t[n[0]] = r)
      }
      n = Tv.exec(e)
  }
  t["%C2"] = "";
  for (var i = Object.keys(t), s = 0; s < i.length; s++) {
      var a = i[s];
      e = e.replace(new RegExp(a,"g"), t[a])
  }
  return e
}
var tI = function(e) {
  if (typeof e != "string")
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof e + "`");
  try {
      return e = e.replace(/\+/g, " "),
      decodeURIComponent(e)
  } catch {
      return eI(e)
  }
}
, nI = (e, t) => {
  if (!(typeof e == "string" && typeof t == "string"))
      throw new TypeError("Expected the arguments to be of type `string`");
  if (t === "")
      return [e];
  const n = e.indexOf(t);
  return n === -1 ? [e] : [e.slice(0, n), e.slice(n + t.length)]
}
, rI = function(e, t) {
  for (var n = {}, r = Object.keys(e), i = Array.isArray(t), s = 0; s < r.length; s++) {
      var a = r[s]
        , o = e[a];
      (i ? t.indexOf(a) !== -1 : t(a, o, e)) && (n[a] = o)
  }
  return n
};
(function(e) {
  const t = J4
    , n = tI
    , r = nI
    , i = rI
    , s = h => h == null
    , a = Symbol("encodeFragmentIdentifier");
  function o(h) {
      switch (h.arrayFormat) {
      case "index":
          return g => (x, S) => {
              const E = x.length;
              return S === void 0 || h.skipNull && S === null || h.skipEmptyString && S === "" ? x : S === null ? [...x, [c(g, h), "[", E, "]"].join("")] : [...x, [c(g, h), "[", c(E, h), "]=", c(S, h)].join("")]
          }
          ;
      case "bracket":
          return g => (x, S) => S === void 0 || h.skipNull && S === null || h.skipEmptyString && S === "" ? x : S === null ? [...x, [c(g, h), "[]"].join("")] : [...x, [c(g, h), "[]=", c(S, h)].join("")];
      case "colon-list-separator":
          return g => (x, S) => S === void 0 || h.skipNull && S === null || h.skipEmptyString && S === "" ? x : S === null ? [...x, [c(g, h), ":list="].join("")] : [...x, [c(g, h), ":list=", c(S, h)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator":
          {
              const g = h.arrayFormat === "bracket-separator" ? "[]=" : "=";
              return x => (S, E) => E === void 0 || h.skipNull && E === null || h.skipEmptyString && E === "" ? S : (E = E === null ? "" : E,
              S.length === 0 ? [[c(x, h), g, c(E, h)].join("")] : [[S, c(E, h)].join(h.arrayFormatSeparator)])
          }
      default:
          return g => (x, S) => S === void 0 || h.skipNull && S === null || h.skipEmptyString && S === "" ? x : S === null ? [...x, c(g, h)] : [...x, [c(g, h), "=", c(S, h)].join("")]
      }
  }
  function u(h) {
      let g;
      switch (h.arrayFormat) {
      case "index":
          return (x, S, E) => {
              if (g = /\[(\d*)\]$/.exec(x),
              x = x.replace(/\[\d*\]$/, ""),
              !g) {
                  E[x] = S;
                  return
              }
              E[x] === void 0 && (E[x] = {}),
              E[x][g[1]] = S
          }
          ;
      case "bracket":
          return (x, S, E) => {
              if (g = /(\[\])$/.exec(x),
              x = x.replace(/\[\]$/, ""),
              !g) {
                  E[x] = S;
                  return
              }
              if (E[x] === void 0) {
                  E[x] = [S];
                  return
              }
              E[x] = [].concat(E[x], S)
          }
          ;
      case "colon-list-separator":
          return (x, S, E) => {
              if (g = /(:list)$/.exec(x),
              x = x.replace(/:list$/, ""),
              !g) {
                  E[x] = S;
                  return
              }
              if (E[x] === void 0) {
                  E[x] = [S];
                  return
              }
              E[x] = [].concat(E[x], S)
          }
          ;
      case "comma":
      case "separator":
          return (x, S, E) => {
              const p = typeof S == "string" && S.includes(h.arrayFormatSeparator)
                , C = typeof S == "string" && !p && f(S, h).includes(h.arrayFormatSeparator);
              S = C ? f(S, h) : S;
              const T = p || C ? S.split(h.arrayFormatSeparator).map(O => f(O, h)) : S === null ? S : f(S, h);
              E[x] = T
          }
          ;
      case "bracket-separator":
          return (x, S, E) => {
              const p = /(\[\])$/.test(x);
              if (x = x.replace(/\[\]$/, ""),
              !p) {
                  E[x] = S && f(S, h);
                  return
              }
              const C = S === null ? [] : S.split(h.arrayFormatSeparator).map(T => f(T, h));
              if (E[x] === void 0) {
                  E[x] = C;
                  return
              }
              E[x] = [].concat(E[x], C)
          }
          ;
      default:
          return (x, S, E) => {
              if (E[x] === void 0) {
                  E[x] = S;
                  return
              }
              E[x] = [].concat(E[x], S)
          }
      }
  }
  function l(h) {
      if (typeof h != "string" || h.length !== 1)
          throw new TypeError("arrayFormatSeparator must be single character string")
  }
  function c(h, g) {
      return g.encode ? g.strict ? t(h) : encodeURIComponent(h) : h
  }
  function f(h, g) {
      return g.decode ? n(h) : h
  }
  function d(h) {
      return Array.isArray(h) ? h.sort() : typeof h == "object" ? d(Object.keys(h)).sort( (g, x) => Number(g) - Number(x)).map(g => h[g]) : h
  }
  function y(h) {
      const g = h.indexOf("#");
      return g !== -1 && (h = h.slice(0, g)),
      h
  }
  function m(h) {
      let g = "";
      const x = h.indexOf("#");
      return x !== -1 && (g = h.slice(x)),
      g
  }
  function v(h) {
      h = y(h);
      const g = h.indexOf("?");
      return g === -1 ? "" : h.slice(g + 1)
  }
  function b(h, g) {
      return g.parseNumbers && !Number.isNaN(Number(h)) && typeof h == "string" && h.trim() !== "" ? h = Number(h) : g.parseBooleans && h !== null && (h.toLowerCase() === "true" || h.toLowerCase() === "false") && (h = h.toLowerCase() === "true"),
      h
  }
  function w(h, g) {
      g = Object.assign({
          decode: !0,
          sort: !0,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
          parseNumbers: !1,
          parseBooleans: !1
      }, g),
      l(g.arrayFormatSeparator);
      const x = u(g)
        , S = Object.create(null);
      if (typeof h != "string" || (h = h.trim().replace(/^[?#&]/, ""),
      !h))
          return S;
      for (const E of h.split("&")) {
          if (E === "")
              continue;
          let[p,C] = r(g.decode ? E.replace(/\+/g, " ") : E, "=");
          C = C === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(g.arrayFormat) ? C : f(C, g),
          x(f(p, g), C, S)
      }
      for (const E of Object.keys(S)) {
          const p = S[E];
          if (typeof p == "object" && p !== null)
              for (const C of Object.keys(p))
                  p[C] = b(p[C], g);
          else
              S[E] = b(p, g)
      }
      return g.sort === !1 ? S : (g.sort === !0 ? Object.keys(S).sort() : Object.keys(S).sort(g.sort)).reduce( (E, p) => {
          const C = S[p];
          return C && typeof C == "object" && !Array.isArray(C) ? E[p] = d(C) : E[p] = C,
          E
      }
      , Object.create(null))
  }
  e.extract = v,
  e.parse = w,
  e.stringify = (h, g) => {
      if (!h)
          return "";
      g = Object.assign({
          encode: !0,
          strict: !0,
          arrayFormat: "none",
          arrayFormatSeparator: ","
      }, g),
      l(g.arrayFormatSeparator);
      const x = C => g.skipNull && s(h[C]) || g.skipEmptyString && h[C] === ""
        , S = o(g)
        , E = {};
      for (const C of Object.keys(h))
          x(C) || (E[C] = h[C]);
      const p = Object.keys(E);
      return g.sort !== !1 && p.sort(g.sort),
      p.map(C => {
          const T = h[C];
          return T === void 0 ? "" : T === null ? c(C, g) : Array.isArray(T) ? T.length === 0 && g.arrayFormat === "bracket-separator" ? c(C, g) + "[]" : T.reduce(S(C), []).join("&") : c(C, g) + "=" + c(T, g)
      }
      ).filter(C => C.length > 0).join("&")
  }
  ,
  e.parseUrl = (h, g) => {
      g = Object.assign({
          decode: !0
      }, g);
      const [x,S] = r(h, "#");
      return Object.assign({
          url: x.split("?")[0] || "",
          query: w(v(h), g)
      }, g && g.parseFragmentIdentifier && S ? {
          fragmentIdentifier: f(S, g)
      } : {})
  }
  ,
  e.stringifyUrl = (h, g) => {
      g = Object.assign({
          encode: !0,
          strict: !0,
          [a]: !0
      }, g);
      const x = y(h.url).split("?")[0] || ""
        , S = e.extract(h.url)
        , E = e.parse(S, {
          sort: !1
      })
        , p = Object.assign(E, h.query);
      let C = e.stringify(p, g);
      C && (C = `?${C}`);
      let T = m(h.url);
      return h.fragmentIdentifier && (T = `#${g[a] ? c(h.fragmentIdentifier, g) : h.fragmentIdentifier}`),
      `${x}${C}${T}`
  }
  ,
  e.pick = (h, g, x) => {
      x = Object.assign({
          parseFragmentIdentifier: !0,
          [a]: !1
      }, x);
      const {url: S, query: E, fragmentIdentifier: p} = e.parseUrl(h, x);
      return e.stringifyUrl({
          url: S,
          query: i(E, g),
          fragmentIdentifier: p
      }, x)
  }
  ,
  e.exclude = (h, g, x) => {
      const S = Array.isArray(g) ? E => !g.includes(E) : (E, p) => !g(E, p);
      return e.pick(h, S, x)
  }
}
)(Za);
const iI = {
  waku: {
      publish: "waku_publish",
      batchPublish: "waku_batchPublish",
      subscribe: "waku_subscribe",
      batchSubscribe: "waku_batchSubscribe",
      subscription: "waku_subscription",
      unsubscribe: "waku_unsubscribe",
      batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
      publish: "irn_publish",
      batchPublish: "irn_batchPublish",
      subscribe: "irn_subscribe",
      batchSubscribe: "irn_batchSubscribe",
      subscription: "irn_subscription",
      unsubscribe: "irn_unsubscribe",
      batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
      publish: "iridium_publish",
      batchPublish: "iridium_batchPublish",
      subscribe: "iridium_subscribe",
      batchSubscribe: "iridium_batchSubscribe",
      subscription: "iridium_subscription",
      unsubscribe: "iridium_unsubscribe",
      batchUnsubscribe: "iridium_batchUnsubscribe"
  }
}
, sI = ":";
function n9(e) {
  const [t,n] = e.split(sI);
  return {
      namespace: t,
      reference: n
  }
}
function r9(e, t=[]) {
  const n = [];
  return Object.keys(e).forEach(r => {
      if (t.length && !t.includes(r))
          return;
      const i = e[r];
      n.push(...i.accounts)
  }
  ),
  n
}
function TE(e, t) {
  return e.includes(":") ? [e] : t.chains || []
}
const OE = "base10"
, At = "base16"
, rh = "base64pad"
, vy = "utf8"
, kE = 0
, Co = 1
, aI = 0
, Ov = 1
, ih = 12
, wy = 32;
function i9() {
  const e = py.generateKeyPair();
  return {
      privateKey: yn(e.secretKey, At),
      publicKey: yn(e.publicKey, At)
  }
}
function s9() {
  const e = Fc.randomBytes(wy);
  return yn(e, At)
}
function a9(e, t) {
  const n = py.sharedKey(fn(e, At), fn(t, At), !0)
    , r = new G8(Wc.SHA256,n).expand(wy);
  return yn(r, At)
}
function o9(e) {
  const t = Wc.hash(fn(e, At));
  return yn(t, At)
}
function u9(e) {
  const t = Wc.hash(fn(e, vy));
  return yn(t, At)
}
function oI(e) {
  return fn(`${e}`, OE)
}
function Vc(e) {
  return Number(yn(e, OE))
}
function l9(e) {
  const t = oI(typeof e.type < "u" ? e.type : kE);
  if (Vc(t) === Co && typeof e.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
  const n = typeof e.senderPublicKey < "u" ? fn(e.senderPublicKey, At) : void 0
    , r = typeof e.iv < "u" ? fn(e.iv, At) : Fc.randomBytes(ih)
    , i = new fy.ChaCha20Poly1305(fn(e.symKey, At)).seal(r, fn(e.message, vy));
  return uI({
      type: t,
      sealed: i,
      iv: r,
      senderPublicKey: n
  })
}
function c9(e) {
  const t = new fy.ChaCha20Poly1305(fn(e.symKey, At))
    , {sealed: n, iv: r} = DE(e.encoded)
    , i = t.open(r, n);
  if (i === null)
      throw new Error("Failed to decrypt");
  return yn(i, vy)
}
function uI(e) {
  if (Vc(e.type) === Co) {
      if (typeof e.senderPublicKey > "u")
          throw new Error("Missing sender public key for type 1 envelope");
      return yn(lv([e.type, e.senderPublicKey, e.iv, e.sealed]), rh)
  }
  return yn(lv([e.type, e.iv, e.sealed]), rh)
}
function DE(e) {
  const t = fn(e, rh)
    , n = t.slice(aI, Ov)
    , r = Ov;
  if (Vc(n) === Co) {
      const o = r + wy
        , u = o + ih
        , l = t.slice(r, o)
        , c = t.slice(o, u)
        , f = t.slice(u);
      return {
          type: n,
          sealed: f,
          iv: c,
          senderPublicKey: l
      }
  }
  const i = r + ih
    , s = t.slice(r, i)
    , a = t.slice(i);
  return {
      type: n,
      sealed: a,
      iv: s
  }
}
function f9(e, t) {
  const n = DE(e);
  return lI({
      type: Vc(n.type),
      senderPublicKey: typeof n.senderPublicKey < "u" ? yn(n.senderPublicKey, At) : void 0,
      receiverPublicKey: t == null ? void 0 : t.receiverPublicKey
  })
}
function lI(e) {
  const t = (e == null ? void 0 : e.type) || kE;
  if (t === Co) {
      if (typeof (e == null ? void 0 : e.senderPublicKey) > "u")
          throw new Error("missing sender public key");
      if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u")
          throw new Error("missing receiver public key")
  }
  return {
      type: t,
      senderPublicKey: e == null ? void 0 : e.senderPublicKey,
      receiverPublicKey: e == null ? void 0 : e.receiverPublicKey
  }
}
function d9(e) {
  return e.type === Co && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string"
}
var cI = Object.defineProperty
, kv = Object.getOwnPropertySymbols
, fI = Object.prototype.hasOwnProperty
, dI = Object.prototype.propertyIsEnumerable
, Dv = (e, t, n) => t in e ? cI(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n
, Iv = (e, t) => {
  for (var n in t || (t = {}))
      fI.call(t, n) && Dv(e, n, t[n]);
  if (kv)
      for (var n of kv(t))
          dI.call(t, n) && Dv(e, n, t[n]);
  return e
}
;
const pI = "ReactNative"
, jt = {
  reactNative: "react-native",
  node: "node",
  browser: "browser",
  unknown: "unknown"
}
, hI = "js";
function IE() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
}
function _o() {
  return !my() && !!yy() && navigator.product === pI
}
function Kc() {
  return !IE() && !!yy() && !!my()
}
function Po() {
  return _o() ? jt.reactNative : IE() ? jt.node : Kc() ? jt.browser : jt.unknown
}
function p9() {
  var e;
  try {
      return _o() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0
  } catch {
      return
  }
}
function mI(e, t) {
  let n = Za.parse(e);
  return n = Iv(Iv({}, n), t),
  e = Za.stringify(n),
  e
}
function h9() {
  return _E() || {
      name: "",
      description: "",
      url: "",
      icons: [""]
  }
}
function yI() {
  if (Po() === jt.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
      const {OS: n, Version: r} = global.Platform;
      return [n, r].join("-")
  }
  const e = u4();
  if (e === null)
      return "unknown";
  const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [t, e.name, e.version].join("-") : [t, e.version].join("-")
}
function gI() {
  var e;
  const t = Po();
  return t === jt.browser ? [t, ((e = CE()) == null ? void 0 : e.host) || "unknown"].join(":") : t
}
function vI(e, t, n) {
  const r = yI()
    , i = gI();
  return [[e, t].join("-"), [hI, n].join("-"), r, i].join("/")
}
function m9({protocol: e, version: t, relayUrl: n, sdkVersion: r, auth: i, projectId: s, useOnCloseEvent: a, bundleId: o}) {
  const u = n.split("?")
    , l = vI(e, t, r)
    , c = {
      auth: i,
      ua: l,
      projectId: s,
      useOnCloseEvent: a || void 0,
      origin: o || void 0
  }
    , f = mI(u[1] || "", c);
  return u[0] + "?" + f
}
function ii(e, t) {
  return e.filter(n => t.includes(n)).length === e.length
}
function y9(e) {
  return Object.fromEntries(e.entries())
}
function g9(e) {
  return new Map(Object.entries(e))
}
function v9(e=ui.FIVE_MINUTES, t) {
  const n = ui.toMiliseconds(e || ui.FIVE_MINUTES);
  let r, i, s;
  return {
      resolve: a => {
          s && r && (clearTimeout(s),
          r(a))
      }
      ,
      reject: a => {
          s && i && (clearTimeout(s),
          i(a))
      }
      ,
      done: () => new Promise( (a, o) => {
          s = setTimeout( () => {
              o(new Error(t))
          }
          , n),
          r = a,
          i = o
      }
      )
  }
}
function w9(e, t, n) {
  return new Promise(async (r, i) => {
      const s = setTimeout( () => i(new Error(n)), t);
      try {
          const a = await e;
          r(a)
      } catch (a) {
          i(a)
      }
      clearTimeout(s)
  }
  )
}
function AE(e, t) {
  if (typeof t == "string" && t.startsWith(`${e}:`))
      return t;
  if (e.toLowerCase() === "topic") {
      if (typeof t != "string")
          throw new Error('Value must be "string" for expirer target type: topic');
      return `topic:${t}`
  } else if (e.toLowerCase() === "id") {
      if (typeof t != "number")
          throw new Error('Value must be "number" for expirer target type: id');
      return `id:${t}`
  }
  throw new Error(`Unknown expirer target type: ${e}`)
}
function b9(e) {
  return AE("topic", e)
}
function x9(e) {
  return AE("id", e)
}
function E9(e) {
  const [t,n] = e.split(":")
    , r = {
      id: void 0,
      topic: void 0
  };
  if (t === "topic" && typeof n == "string")
      r.topic = n;
  else if (t === "id" && Number.isInteger(Number(n)))
      r.id = Number(n);
  else
      throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n}`);
  return r
}
function S9(e, t) {
  return ui.fromMiliseconds((t || Date.now()) + ui.toMiliseconds(e))
}
function C9(e) {
  return Date.now() >= ui.toMiliseconds(e)
}
function _9(e, t) {
  return `${e}${t ? `:${t}` : ""}`
}
function ld(e=[], t=[]) {
  return [...new Set([...e, ...t])]
}
async function P9({id: e, topic: t, wcDeepLink: n}) {
  try {
      if (!n)
          return;
      const r = typeof n == "string" ? JSON.parse(n) : n;
      let i = r == null ? void 0 : r.href;
      if (typeof i != "string")
          return;
      i.endsWith("/") && (i = i.slice(0, -1));
      const s = `${i}/wc?requestId=${e}&sessionTopic=${t}`
        , a = Po();
      a === jt.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : a === jt.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s)
  } catch (r) {
      console.error(r)
  }
}
async function T9(e, t) {
  try {
      return await e.getItem(t) || (Kc() ? localStorage.getItem(t) : void 0)
  } catch (n) {
      console.error(n)
  }
}
const wI = "irn";
function O9(e) {
  return (e == null ? void 0 : e.relay) || {
      protocol: wI
  }
}
function k9(e) {
  const t = iI[e];
  if (typeof t > "u")
      throw new Error(`Relay Protocol not supported: ${e}`);
  return t
}
var bI = Object.defineProperty
, Av = Object.getOwnPropertySymbols
, xI = Object.prototype.hasOwnProperty
, EI = Object.prototype.propertyIsEnumerable
, $v = (e, t, n) => t in e ? bI(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n
, SI = (e, t) => {
  for (var n in t || (t = {}))
      xI.call(t, n) && $v(e, n, t[n]);
  if (Av)
      for (var n of Av(t))
          EI.call(t, n) && $v(e, n, t[n]);
  return e
}
;
function CI(e, t="-") {
  const n = {}
    , r = "relay" + t;
  return Object.keys(e).forEach(i => {
      if (i.startsWith(r)) {
          const s = i.replace(r, "")
            , a = e[i];
          n[s] = a
      }
  }
  ),
  n
}
function D9(e) {
  e = e.includes("wc://") ? e.replace("wc://", "") : e,
  e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const t = e.indexOf(":")
    , n = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0
    , r = e.substring(0, t)
    , i = e.substring(t + 1, n).split("@")
    , s = typeof n < "u" ? e.substring(n) : ""
    , a = Za.parse(s);
  return {
      protocol: r,
      topic: _I(i[0]),
      version: parseInt(i[1], 10),
      symKey: a.symKey,
      relay: CI(a)
  }
}
function _I(e) {
  return e.startsWith("//") ? e.substring(2) : e
}
function PI(e, t="-") {
  const n = "relay"
    , r = {};
  return Object.keys(e).forEach(i => {
      const s = n + t + i;
      e[i] && (r[s] = e[i])
  }
  ),
  r
}
function I9(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + Za.stringify(SI({
      symKey: e.symKey
  }, PI(e.relay)))
}
var TI = Object.defineProperty
, OI = Object.defineProperties
, kI = Object.getOwnPropertyDescriptors
, Rv = Object.getOwnPropertySymbols
, DI = Object.prototype.hasOwnProperty
, II = Object.prototype.propertyIsEnumerable
, Nv = (e, t, n) => t in e ? TI(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n
, AI = (e, t) => {
  for (var n in t || (t = {}))
      DI.call(t, n) && Nv(e, n, t[n]);
  if (Rv)
      for (var n of Rv(t))
          II.call(t, n) && Nv(e, n, t[n]);
  return e
}
, $I = (e, t) => OI(e, kI(t));
function ks(e) {
  const t = [];
  return e.forEach(n => {
      const [r,i] = n.split(":");
      t.push(`${r}:${i}`)
  }
  ),
  t
}
function RI(e) {
  const t = [];
  return Object.values(e).forEach(n => {
      t.push(...ks(n.accounts))
  }
  ),
  t
}
function NI(e, t) {
  const n = [];
  return Object.values(e).forEach(r => {
      ks(r.accounts).includes(t) && n.push(...r.methods)
  }
  ),
  n
}
function jI(e, t) {
  const n = [];
  return Object.values(e).forEach(r => {
      ks(r.accounts).includes(t) && n.push(...r.events)
  }
  ),
  n
}
function A9(e, t) {
  const n = VI(e, t);
  if (n)
      throw new Error(n.message);
  const r = {};
  for (const [i,s] of Object.entries(e))
      r[i] = {
          methods: s.methods,
          events: s.events,
          chains: s.accounts.map(a => `${a.split(":")[0]}:${a.split(":")[1]}`)
      };
  return r
}
function $E(e) {
  return e.includes(":")
}
function MI(e) {
  return $E(e) ? e.split(":")[0] : e
}
function RE(e) {
  var t, n, r;
  const i = {};
  if (!by(e))
      return i;
  for (const [s,a] of Object.entries(e)) {
      const o = $E(s) ? [s] : a.chains
        , u = a.methods || []
        , l = a.events || []
        , c = MI(s);
      i[c] = $I(AI({}, i[c]), {
          chains: ld(o, (t = i[c]) == null ? void 0 : t.chains),
          methods: ld(u, (n = i[c]) == null ? void 0 : n.methods),
          events: ld(l, (r = i[c]) == null ? void 0 : r.events)
      })
  }
  return i
}
const LI = {
  INVALID_METHOD: {
      message: "Invalid method.",
      code: 1001
  },
  INVALID_EVENT: {
      message: "Invalid event.",
      code: 1002
  },
  INVALID_UPDATE_REQUEST: {
      message: "Invalid update request.",
      code: 1003
  },
  INVALID_EXTEND_REQUEST: {
      message: "Invalid extend request.",
      code: 1004
  },
  INVALID_SESSION_SETTLE_REQUEST: {
      message: "Invalid session settle request.",
      code: 1005
  },
  UNAUTHORIZED_METHOD: {
      message: "Unauthorized method.",
      code: 3001
  },
  UNAUTHORIZED_EVENT: {
      message: "Unauthorized event.",
      code: 3002
  },
  UNAUTHORIZED_UPDATE_REQUEST: {
      message: "Unauthorized update request.",
      code: 3003
  },
  UNAUTHORIZED_EXTEND_REQUEST: {
      message: "Unauthorized extend request.",
      code: 3004
  },
  USER_REJECTED: {
      message: "User rejected.",
      code: 5e3
  },
  USER_REJECTED_CHAINS: {
      message: "User rejected chains.",
      code: 5001
  },
  USER_REJECTED_METHODS: {
      message: "User rejected methods.",
      code: 5002
  },
  USER_REJECTED_EVENTS: {
      message: "User rejected events.",
      code: 5003
  },
  UNSUPPORTED_CHAINS: {
      message: "Unsupported chains.",
      code: 5100
  },
  UNSUPPORTED_METHODS: {
      message: "Unsupported methods.",
      code: 5101
  },
  UNSUPPORTED_EVENTS: {
      message: "Unsupported events.",
      code: 5102
  },
  UNSUPPORTED_ACCOUNTS: {
      message: "Unsupported accounts.",
      code: 5103
  },
  UNSUPPORTED_NAMESPACE_KEY: {
      message: "Unsupported namespace key.",
      code: 5104
  },
  USER_DISCONNECTED: {
      message: "User disconnected.",
      code: 6e3
  },
  SESSION_SETTLEMENT_FAILED: {
      message: "Session settlement failed.",
      code: 7e3
  },
  WC_METHOD_UNSUPPORTED: {
      message: "Unsupported wc_ method.",
      code: 10001
  }
}
, FI = {
  NOT_INITIALIZED: {
      message: "Not initialized.",
      code: 1
  },
  NO_MATCHING_KEY: {
      message: "No matching key.",
      code: 2
  },
  RESTORE_WILL_OVERRIDE: {
      message: "Restore will override.",
      code: 3
  },
  RESUBSCRIBED: {
      message: "Resubscribed.",
      code: 4
  },
  MISSING_OR_INVALID: {
      message: "Missing or invalid.",
      code: 5
  },
  EXPIRED: {
      message: "Expired.",
      code: 6
  },
  UNKNOWN_TYPE: {
      message: "Unknown type.",
      code: 7
  },
  MISMATCHED_TOPIC: {
      message: "Mismatched topic.",
      code: 8
  },
  NON_CONFORMING_NAMESPACES: {
      message: "Non conforming namespaces.",
      code: 9
  }
};
function dr(e, t) {
  const {message: n, code: r} = FI[e];
  return {
      message: t ? `${n} ${t}` : n,
      code: r
  }
}
function hs(e, t) {
  const {message: n, code: r} = LI[e];
  return {
      message: t ? `${n} ${t}` : n,
      code: r
  }
}
function Gc(e, t) {
  return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : !0 : !1
}
function by(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length
}
function li(e) {
  return typeof e > "u"
}
function an(e, t) {
  return t && li(e) ? !0 : typeof e == "string" && !!e.trim().length
}
function xy(e, t) {
  return t && li(e) ? !0 : typeof e == "number" && !isNaN(e)
}
function $9(e, t) {
  const {requiredNamespaces: n} = t
    , r = Object.keys(e.namespaces)
    , i = Object.keys(n);
  let s = !0;
  return ii(i, r) ? (r.forEach(a => {
      const {accounts: o, methods: u, events: l} = e.namespaces[a]
        , c = ks(o)
        , f = n[a];
      (!ii(TE(a, f), c) || !ii(f.methods, u) || !ii(f.events, l)) && (s = !1)
  }
  ),
  s) : !1
}
function Il(e) {
  return an(e, !1) && e.includes(":") ? e.split(":").length === 2 : !1
}
function UI(e) {
  if (an(e, !1) && e.includes(":")) {
      const t = e.split(":");
      if (t.length === 3) {
          const n = t[0] + ":" + t[1];
          return !!t[2] && Il(n)
      }
  }
  return !1
}
function R9(e) {
  if (an(e, !1))
      try {
          return typeof new URL(e) < "u"
      } catch {
          return !1
      }
  return !1
}
function N9(e) {
  var t;
  return (t = e == null ? void 0 : e.proposer) == null ? void 0 : t.publicKey
}
function j9(e) {
  return e == null ? void 0 : e.topic
}
function M9(e, t) {
  let n = null;
  return an(e == null ? void 0 : e.publicKey, !1) || (n = dr("MISSING_OR_INVALID", `${t} controller public key should be a string`)),
  n
}
function jv(e) {
  let t = !0;
  return Gc(e) ? e.length && (t = e.every(n => an(n, !1))) : t = !1,
  t
}
function zI(e, t, n) {
  let r = null;
  return Gc(t) && t.length ? t.forEach(i => {
      r || Il(i) || (r = hs("UNSUPPORTED_CHAINS", `${n}, chain ${i} should be a string and conform to "namespace:chainId" format`))
  }
  ) : Il(e) || (r = hs("UNSUPPORTED_CHAINS", `${n}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),
  r
}
function BI(e, t, n) {
  let r = null;
  return Object.entries(e).forEach( ([i,s]) => {
      if (r)
          return;
      const a = zI(i, TE(i, s), `${t} ${n}`);
      a && (r = a)
  }
  ),
  r
}
function WI(e, t) {
  let n = null;
  return Gc(e) ? e.forEach(r => {
      n || UI(r) || (n = hs("UNSUPPORTED_ACCOUNTS", `${t}, account ${r} should be a string and conform to "namespace:chainId:address" format`))
  }
  ) : n = hs("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),
  n
}
function HI(e, t) {
  let n = null;
  return Object.values(e).forEach(r => {
      if (n)
          return;
      const i = WI(r == null ? void 0 : r.accounts, `${t} namespace`);
      i && (n = i)
  }
  ),
  n
}
function qI(e, t) {
  let n = null;
  return jv(e == null ? void 0 : e.methods) ? jv(e == null ? void 0 : e.events) || (n = hs("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : n = hs("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`),
  n
}
function NE(e, t) {
  let n = null;
  return Object.values(e).forEach(r => {
      if (n)
          return;
      const i = qI(r, `${t}, namespace`);
      i && (n = i)
  }
  ),
  n
}
function L9(e, t, n) {
  let r = null;
  if (e && by(e)) {
      const i = NE(e, t);
      i && (r = i);
      const s = BI(e, t, n);
      s && (r = s)
  } else
      r = dr("MISSING_OR_INVALID", `${t}, ${n} should be an object with data`);
  return r
}
function VI(e, t) {
  let n = null;
  if (e && by(e)) {
      const r = NE(e, t);
      r && (n = r);
      const i = HI(e, t);
      i && (n = i)
  } else
      n = dr("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
  return n
}
function KI(e) {
  return an(e.protocol, !0)
}
function F9(e, t) {
  let n = !1;
  return t && !e ? n = !0 : e && Gc(e) && e.length && e.forEach(r => {
      n = KI(r)
  }
  ),
  n
}
function U9(e) {
  return typeof e == "number"
}
function z9(e) {
  return typeof e < "u" && typeof e !== null
}
function B9(e) {
  return !(!e || typeof e != "object" || !e.code || !xy(e.code, !1) || !e.message || !an(e.message, !1))
}
function W9(e) {
  return !(li(e) || !an(e.method, !1))
}
function H9(e) {
  return !(li(e) || li(e.result) && li(e.error) || !xy(e.id, !1) || !an(e.jsonrpc, !1))
}
function q9(e) {
  return !(li(e) || !an(e.name, !1))
}
function V9(e, t) {
  return !(!Il(t) || !RI(e).includes(t))
}
function K9(e, t, n) {
  return an(n, !1) ? NI(e, t).includes(n) : !1
}
function G9(e, t, n) {
  return an(n, !1) ? jI(e, t).includes(n) : !1
}
function Q9(e, t, n) {
  let r = null;
  const i = GI(e)
    , s = QI(t)
    , a = Object.keys(i)
    , o = Object.keys(s)
    , u = Mv(Object.keys(e))
    , l = Mv(Object.keys(t))
    , c = u.filter(f => !l.includes(f));
  return c.length && (r = dr("NON_CONFORMING_NAMESPACES", `${n} namespaces keys don't satisfy requiredNamespaces.
    Required: ${c.toString()}
    Received: ${Object.keys(t).toString()}`)),
  ii(a, o) || (r = dr("NON_CONFORMING_NAMESPACES", `${n} namespaces chains don't satisfy required namespaces.
    Required: ${a.toString()}
    Approved: ${o.toString()}`)),
  Object.keys(t).forEach(f => {
      if (!f.includes(":") || r)
          return;
      const d = ks(t[f].accounts);
      d.includes(f) || (r = dr("NON_CONFORMING_NAMESPACES", `${n} namespaces accounts don't satisfy namespace accounts for ${f}
      Required: ${f}
      Approved: ${d.toString()}`))
  }
  ),
  a.forEach(f => {
      r || (ii(i[f].methods, s[f].methods) ? ii(i[f].events, s[f].events) || (r = dr("NON_CONFORMING_NAMESPACES", `${n} namespaces events don't satisfy namespace events for ${f}`)) : r = dr("NON_CONFORMING_NAMESPACES", `${n} namespaces methods don't satisfy namespace methods for ${f}`))
  }
  ),
  r
}
function GI(e) {
  const t = {};
  return Object.keys(e).forEach(n => {
      var r;
      n.includes(":") ? t[n] = e[n] : (r = e[n].chains) == null || r.forEach(i => {
          t[i] = {
              methods: e[n].methods,
              events: e[n].events
          }
      }
      )
  }
  ),
  t
}
function Mv(e) {
  return [...new Set(e.map(t => t.includes(":") ? t.split(":")[0] : t))]
}
function QI(e) {
  const t = {};
  return Object.keys(e).forEach(n => {
      if (n.includes(":"))
          t[n] = e[n];
      else {
          const r = ks(e[n].accounts);
          r == null || r.forEach(i => {
              t[i] = {
                  accounts: e[n].accounts.filter(s => s.includes(`${i}:`)),
                  methods: e[n].methods,
                  events: e[n].events
              }
          }
          )
      }
  }
  ),
  t
}
function Y9(e, t) {
  return xy(e, !1) && e <= t.max && e >= t.min
}
function X9() {
  const e = Po();
  return new Promise(t => {
      switch (e) {
      case jt.browser:
          t(YI());
          break;
      case jt.reactNative:
          t(XI());
          break;
      case jt.node:
          t(JI());
          break;
      default:
          t(!0)
      }
  }
  )
}
function YI() {
  return Kc() && (navigator == null ? void 0 : navigator.onLine)
}
async function XI() {
  if (_o() && typeof global < "u" && global != null && global.NetInfo) {
      const e = await (global == null ? void 0 : global.NetInfo.fetch());
      return e == null ? void 0 : e.isConnected
  }
  return !0
}
function JI() {
  return !0
}
function J9(e) {
  switch (Po()) {
  case jt.browser:
      ZI(e);
      break;
  case jt.reactNative:
      eA(e);
      break
  }
}
function ZI(e) {
  !_o() && Kc() && (window.addEventListener("online", () => e(!0)),
  window.addEventListener("offline", () => e(!1)))
}
function eA(e) {
  _o() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener(t => e(t == null ? void 0 : t.isConnected)))
}
const cd = {};
class Z9 {
  static get(t) {
      return cd[t]
  }
  static set(t, n) {
      cd[t] = n
  }
  static delete(t) {
      delete cd[t]
  }
}
var jE = "eip155", tA = "store", ME = "requestedChains", sh = "wallet_addEthereumChain", Te, pa, Lu, ah, Ey, LE, Fu, oh, uh, FE, Al, Sy, $i, na, $l, Cy, Rl, _y, Nl, Py, nA = class extends Lx {
  constructor(e) {
      super({
          ...e,
          options: {
              isNewChainsStale: !0,
              ...e.options
          }
      }),
      Vt(this, Lu),
      Vt(this, Ey),
      Vt(this, Fu),
      Vt(this, uh),
      Vt(this, Al),
      Vt(this, $i),
      Vt(this, $l),
      Vt(this, Rl),
      Vt(this, Nl),
      this.id = "walletConnect",
      this.name = "WalletConnect",
      this.ready = !0,
      Vt(this, Te, void 0),
      Vt(this, pa, void 0),
      this.onAccountsChanged = t => {
          t.length === 0 ? this.emit("disconnect") : this.emit("change", {
              account: Tr(t[0])
          })
      }
      ,
      this.onChainChanged = t => {
          const n = Number(t)
            , r = this.isChainUnsupported(n);
          this.emit("change", {
              chain: {
                  id: n,
                  unsupported: r
              }
          })
      }
      ,
      this.onDisconnect = () => {
          Qe(this, $i, na).call(this, []),
          this.emit("disconnect")
      }
      ,
      this.onDisplayUri = t => {
          this.emit("message", {
              type: "display_uri",
              data: t
          })
      }
      ,
      this.onConnect = () => {
          this.emit("connect", {})
      }
      ,
      Qe(this, Lu, ah).call(this)
  }
  async connect({chainId: e, pairingTopic: t}={}) {
      var n, r, i, s, a;
      try {
          let o = e;
          if (!o) {
              const m = (n = this.storage) == null ? void 0 : n.getItem(tA)
                , v = (s = (i = (r = m == null ? void 0 : m.state) == null ? void 0 : r.data) == null ? void 0 : i.chain) == null ? void 0 : s.id;
              v && !this.isChainUnsupported(v) ? o = v : o = (a = this.chains[0]) == null ? void 0 : a.id
          }
          if (!o)
              throw new Error("No chains found on connector.");
          const u = await this.getProvider();
          Qe(this, uh, FE).call(this);
          const l = Qe(this, Fu, oh).call(this);
          if (u.session && l && await u.disconnect(),
          !u.session || l) {
              const m = this.chains.filter(v => v.id !== o).map(v => v.id);
              this.emit("message", {
                  type: "connecting"
              }),
              await u.connect({
                  pairingTopic: t,
                  optionalChains: [o, ...m]
              }),
              Qe(this, $i, na).call(this, this.chains.map( ({id: v}) => v))
          }
          const c = await u.enable()
            , f = Tr(c[0])
            , d = await this.getChainId()
            , y = this.isChainUnsupported(d);
          return {
              account: f,
              chain: {
                  id: d,
                  unsupported: y
              }
          }
      } catch (o) {
          throw /user rejected/i.test(o == null ? void 0 : o.message) ? new Jt(o) : o
      }
  }
  async disconnect() {
      const e = await this.getProvider();
      try {
          await e.disconnect()
      } catch (t) {
          if (!/No matching key/i.test(t.message))
              throw t
      } finally {
          Qe(this, Al, Sy).call(this),
          Qe(this, $i, na).call(this, [])
      }
  }
  async getAccount() {
      const {accounts: e} = await this.getProvider();
      return Tr(e[0])
  }
  async getChainId() {
      const {chainId: e} = await this.getProvider();
      return e
  }
  async getProvider({chainId: e}={}) {
      return Pe(this, Te) || await Qe(this, Lu, ah).call(this),
      e && await this.switchChain(e),
      Pe(this, Te)
  }
  async getWalletClient({chainId: e}={}) {
      const [t,n] = await Promise.all([this.getProvider({
          chainId: e
      }), this.getAccount()])
        , r = this.chains.find(i => i.id === e);
      if (!t)
          throw new Error("provider is required.");
      return Nx({
          account: n,
          chain: r,
          transport: gx(t)
      })
  }
  async isAuthorized() {
      try {
          const [e,t] = await Promise.all([this.getAccount(), this.getProvider()])
            , n = Qe(this, Fu, oh).call(this);
          if (!e)
              return !1;
          if (n && t.session) {
              try {
                  await t.disconnect()
              } catch {}
              return !1
          }
          return !0
      } catch {
          return !1
      }
  }
  async switchChain(e) {
      var n, r;
      const t = this.chains.find(i => i.id === e);
      if (!t)
          throw new Nr(new Error("chain not found on connector."));
      try {
          const i = await this.getProvider()
            , s = Qe(this, Rl, _y).call(this)
            , a = Qe(this, Nl, Py).call(this);
          if (!s.includes(e) && a.includes(sh)) {
              await i.request({
                  method: sh,
                  params: [{
                      chainId: ie(t.id),
                      blockExplorerUrls: [(r = (n = t.blockExplorers) == null ? void 0 : n.default) == null ? void 0 : r.url],
                      chainName: t.name,
                      nativeCurrency: t.nativeCurrency,
                      rpcUrls: [...t.rpcUrls.default.http]
                  }]
              });
              const u = Qe(this, $l, Cy).call(this);
              u.push(e),
              Qe(this, $i, na).call(this, u)
          }
          return await i.request({
              method: "wallet_switchEthereumChain",
              params: [{
                  chainId: ie(e)
              }]
          }),
          t
      } catch (i) {
          const s = typeof i == "string" ? i : i == null ? void 0 : i.message;
          throw /user rejected request/i.test(s) ? new Jt(i) : new Nr(i)
      }
  }
}
;
Te = new WeakMap;
pa = new WeakMap;
Lu = new WeakSet;
ah = async function() {
  return !Pe(this, pa) && typeof window < "u" && sy(this, pa, Qe(this, Ey, LE).call(this)),
  Pe(this, pa)
}
;
Ey = new WeakSet;
LE = async function() {
  const {EthereumProvider: e} = await sn( () => import("./index.es-6EvgWQqA.js"), __vite__mapDeps([4, 5]))
    , t = this.chains.map( ({id: n}) => n);
  if (t.length) {
      const {projectId: n, showQrModal: r=!0, qrModalOptions: i, metadata: s, relayUrl: a} = this.options;
      sy(this, Te, await e.init({
          showQrModal: r,
          qrModalOptions: i,
          projectId: n,
          optionalChains: t,
          rpcMap: Object.fromEntries(this.chains.map(o => [o.id, o.rpcUrls.default.http[0]])),
          metadata: s,
          relayUrl: a
      }))
  }
}
;
Fu = new WeakSet;
oh = function() {
  if (Qe(this, Nl, Py).call(this).includes(sh) || !this.options.isNewChainsStale)
      return !1;
  const t = Qe(this, $l, Cy).call(this)
    , n = this.chains.map( ({id: i}) => i)
    , r = Qe(this, Rl, _y).call(this);
  return r.length && !r.some(i => n.includes(i)) ? !1 : !n.every(i => t.includes(i))
}
;
uh = new WeakSet;
FE = function() {
  Pe(this, Te) && (Qe(this, Al, Sy).call(this),
  Pe(this, Te).on("accountsChanged", this.onAccountsChanged),
  Pe(this, Te).on("chainChanged", this.onChainChanged),
  Pe(this, Te).on("disconnect", this.onDisconnect),
  Pe(this, Te).on("session_delete", this.onDisconnect),
  Pe(this, Te).on("display_uri", this.onDisplayUri),
  Pe(this, Te).on("connect", this.onConnect))
}
;
Al = new WeakSet;
Sy = function() {
  Pe(this, Te) && (Pe(this, Te).removeListener("accountsChanged", this.onAccountsChanged),
  Pe(this, Te).removeListener("chainChanged", this.onChainChanged),
  Pe(this, Te).removeListener("disconnect", this.onDisconnect),
  Pe(this, Te).removeListener("session_delete", this.onDisconnect),
  Pe(this, Te).removeListener("display_uri", this.onDisplayUri),
  Pe(this, Te).removeListener("connect", this.onConnect))
}
;
$i = new WeakSet;
na = function(e) {
  var t;
  (t = this.storage) == null || t.setItem(ME, e)
}
;
$l = new WeakSet;
Cy = function() {
  var e;
  return ((e = this.storage) == null ? void 0 : e.getItem(ME)) ?? []
}
;
Rl = new WeakSet;
_y = function() {
  var r, i, s;
  if (!Pe(this, Te))
      return [];
  const e = (r = Pe(this, Te).session) == null ? void 0 : r.namespaces;
  return e ? ((s = (i = RE(e)[jE]) == null ? void 0 : i.chains) == null ? void 0 : s.map(a => parseInt(a.split(":")[1] || ""))) ?? [] : []
}
;
Nl = new WeakSet;
Py = function() {
  var r, i;
  if (!Pe(this, Te))
      return [];
  const e = (r = Pe(this, Te).session) == null ? void 0 : r.namespaces;
  return e ? ((i = RE(e)[jE]) == null ? void 0 : i.methods) ?? [] : []
}
;
const rA = "wallet_addEthereumChain";
let iA = class {
  constructor(t, n) {
      this.wagmi = {},
      this.chains = [],
      this.namespace = "eip155",
      this.disconnect = LO,
      this.getAccount = oy,
      this.watchAccount = Gx,
      this.fetchBalance = qO,
      this.getNetwork = Ic,
      this.watchNetwork = Qx,
      this.switchNetwork = Kx,
      this.fetchEnsName = KO,
      this.fetchEnsAvatar = VO,
      this.wagmi = t,
      this.chains = n
  }
  getWalletConnectConnector() {
      const t = this.wagmi.connectors.find(n => n.id === "walletConnect");
      if (!t)
          throw new Error("WalletConnectConnector is required");
      return t
  }
  async connectWalletConnectProvider(t, n) {
      return await t.getProvider(),
      new Promise(r => {
          t.once("message", i => {
              i.type === "display_uri" && (n(i.data),
              r())
          }
          )
      }
      )
  }
  getConnectorById(t) {
      const n = this.wagmi.connectors.find(r => r.id === t);
      if (!n)
          throw new Error(`Connector for id ${t} was not found`);
      return n
  }
  getConnectors() {
      return this.wagmi.connectors.filter(t => !t.id.includes("walletConnect"))
  }
  async connectWalletConnect(t, n) {
      const r = this.getWalletConnectConnector()
        , i = {
          connector: r
      };
      return n && (i.chainId = n),
      Promise.all([B0(i), this.connectWalletConnectProvider(r, t)])
  }
  async connectConnector(t, n) {
      const r = {
          connector: this.getConnectorById(t)
      };
      return n && (r.chainId = n),
      await B0(r)
  }
  isInjectedProviderInstalled() {
      return typeof window.ethereum < "u"
  }
  safeCheckInjectedProvider(t) {
      var n;
      try {
          const r = String(t);
          return !!((n = window.ethereum) != null && n[r])
      } catch (r) {
          return console.error(r),
          !1
      }
  }
  async getConnectedChainIds() {
      var t, n, r;
      const i = (n = (t = (await this.getWalletConnectConnector().getProvider()).signer) == null ? void 0 : t.session) == null ? void 0 : n.namespaces
        , s = (r = i == null ? void 0 : i[this.namespace]) == null ? void 0 : r.methods;
      if (s != null && s.includes(rA))
          return "ALL";
      if (i) {
          const a = [];
          return Object.keys(i).forEach(o => {
              o.includes(this.namespace) && a.push(...i[o].accounts)
          }
          ),
          a == null ? void 0 : a.map(o => o.split(":")[1])
      }
      return "ALL"
  }
}
;
function sA({chains: e, projectId: t}) {
  return [new nA({
      chains: e,
      options: {
          projectId: t,
          showQrModal: !1
      }
  }), new Fx({
      chains: e,
      options: {
          shimDisconnect: !0
      }
  })]
}
let aA = {
  data: ""
}
, oA = e => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), {
  innerHTML: " ",
  id: "_goober"
})).firstChild : e || aA
, uA = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g
, lA = /\/\*[^]*?\*\/|  +/g
, Lv = /\n+/g
, pr = (e, t) => {
  let n = ""
    , r = ""
    , i = "";
  for (let s in e) {
      let a = e[s];
      s[0] == "@" ? s[1] == "i" ? n = s + " " + a + ";" : r += s[1] == "f" ? pr(a, s) : s + "{" + pr(a, s[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += pr(a, t ? t.replace(/([^,])+/g, o => s.replace(/(^:.*)|([^,])+/g, u => /&/.test(u) ? u.replace(/&/g, o) : o ? o + " " + u : u)) : s) : a != null && (s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, "-$&").toLowerCase(),
      i += pr.p ? pr.p(s, a) : s + ":" + a + ";")
  }
  return n + (t && i ? t + "{" + i + "}" : i) + r
}
, $n = {}
, UE = e => {
  if (typeof e == "object") {
      let t = "";
      for (let n in e)
          t += n + UE(e[n]);
      return t
  }
  return e
}
, cA = (e, t, n, r, i) => {
  let s = UE(e)
    , a = $n[s] || ($n[s] = (u => {
      let l = 0
        , c = 11;
      for (; l < u.length; )
          c = 101 * c + u.charCodeAt(l++) >>> 0;
      return "go" + c
  }
  )(s));
  if (!$n[a]) {
      let u = s !== e ? e : (l => {
          let c, f, d = [{}];
          for (; c = uA.exec(l.replace(lA, "")); )
              c[4] ? d.shift() : c[3] ? (f = c[3].replace(Lv, " ").trim(),
              d.unshift(d[0][f] = d[0][f] || {})) : d[0][c[1]] = c[2].replace(Lv, " ").trim();
          return d[0]
      }
      )(e);
      $n[a] = pr(i ? {
          ["@keyframes " + a]: u
      } : u, n ? "" : "." + a)
  }
  let o = n && $n.g ? $n.g : null;
  return n && ($n.g = $n[a]),
  ( (u, l, c, f) => {
      f ? l.data = l.data.replace(f, u) : l.data.indexOf(u) === -1 && (l.data = c ? u + l.data : l.data + u)
  }
  )($n[a], t, r, o),
  a
}
, fA = (e, t, n) => e.reduce( (r, i, s) => {
  let a = t[s];
  if (a && a.call) {
      let o = a(n)
        , u = o && o.props && o.props.className || /^go/.test(o) && o;
      a = u ? "." + u : o && typeof o == "object" ? o.props ? "" : pr(o, "") : o === !1 ? "" : o
  }
  return r + i + (a ?? "")
}
, "");
function Qc(e) {
  let t = this || {}
    , n = e.call ? e(t.p) : e;
  return cA(n.unshift ? n.raw ? fA(n, [].slice.call(arguments, 1), t.p) : n.reduce( (r, i) => Object.assign(r, i && i.call ? i(t.p) : i), {}) : n, oA(t.target), t.g, t.o, t.k)
}
let zE, lh, ch;
Qc.bind({
  g: 1
});
let Xn = Qc.bind({
  k: 1
});
function dA(e, t, n, r) {
  pr.p = t,
  zE = e,
  lh = n,
  ch = r
}
function Hr(e, t) {
  let n = this || {};
  return function() {
      let r = arguments;
      function i(s, a) {
          let o = Object.assign({}, s)
            , u = o.className || i.className;
          n.p = Object.assign({
              theme: lh && lh()
          }, o),
          n.o = / *go\d+/.test(u),
          o.className = Qc.apply(n, r) + (u ? " " + u : ""),
          t && (o.ref = a);
          let l = e;
          return e[0] && (l = o.as || e,
          delete o.as),
          ch && l[0] && ch(o),
          zE(l, o)
      }
      return t ? t(i) : i
  }
}
var pA = e => typeof e == "function"
, jl = (e, t) => pA(e) ? e(t) : e
, hA = ( () => {
  let e = 0;
  return () => (++e).toString()
}
)()
, BE = ( () => {
  let e;
  return () => {
      if (e === void 0 && typeof window < "u") {
          let t = matchMedia("(prefers-reduced-motion: reduce)");
          e = !t || t.matches
      }
      return e
  }
}
)()
, mA = 20
, Uu = new Map
, yA = 1e3
, Fv = e => {
  if (Uu.has(e))
      return;
  let t = setTimeout( () => {
      Uu.delete(e),
      xi({
          type: 4,
          toastId: e
      })
  }
  , yA);
  Uu.set(e, t)
}
, gA = e => {
  let t = Uu.get(e);
  t && clearTimeout(t)
}
, fh = (e, t) => {
  switch (t.type) {
  case 0:
      return {
          ...e,
          toasts: [t.toast, ...e.toasts].slice(0, mA)
      };
  case 1:
      return t.toast.id && gA(t.toast.id),
      {
          ...e,
          toasts: e.toasts.map(s => s.id === t.toast.id ? {
              ...s,
              ...t.toast
          } : s)
      };
  case 2:
      let {toast: n} = t;
      return e.toasts.find(s => s.id === n.id) ? fh(e, {
          type: 1,
          toast: n
      }) : fh(e, {
          type: 0,
          toast: n
      });
  case 3:
      let {toastId: r} = t;
      return r ? Fv(r) : e.toasts.forEach(s => {
          Fv(s.id)
      }
      ),
      {
          ...e,
          toasts: e.toasts.map(s => s.id === r || r === void 0 ? {
              ...s,
              visible: !1
          } : s)
      };
  case 4:
      return t.toastId === void 0 ? {
          ...e,
          toasts: []
      } : {
          ...e,
          toasts: e.toasts.filter(s => s.id !== t.toastId)
      };
  case 5:
      return {
          ...e,
          pausedAt: t.time
      };
  case 6:
      let i = t.time - (e.pausedAt || 0);
      return {
          ...e,
          pausedAt: void 0,
          toasts: e.toasts.map(s => ({
              ...s,
              pauseDuration: s.pauseDuration + i
          }))
      }
  }
}
, zu = []
, Bu = {
  toasts: [],
  pausedAt: void 0
}
, xi = e => {
  Bu = fh(Bu, e),
  zu.forEach(t => {
      t(Bu)
  }
  )
}
, vA = {
  blank: 4e3,
  error: 4e3,
  success: 2e3,
  loading: 1 / 0,
  custom: 4e3
}
, wA = (e={}) => {
  let[t,n] = _.useState(Bu);
  _.useEffect( () => (zu.push(n),
  () => {
      let i = zu.indexOf(n);
      i > -1 && zu.splice(i, 1)
  }
  ), [t]);
  let r = t.toasts.map(i => {
      var s, a;
      return {
          ...e,
          ...e[i.type],
          ...i,
          duration: i.duration || ((s = e[i.type]) == null ? void 0 : s.duration) || (e == null ? void 0 : e.duration) || vA[i.type],
          style: {
              ...e.style,
              ...(a = e[i.type]) == null ? void 0 : a.style,
              ...i.style
          }
      }
  }
  );
  return {
      ...t,
      toasts: r
  }
}
, bA = (e, t="blank", n) => ({
  createdAt: Date.now(),
  visible: !0,
  type: t,
  ariaProps: {
      role: "status",
      "aria-live": "polite"
  },
  message: e,
  pauseDuration: 0,
  ...n,
  id: (n == null ? void 0 : n.id) || hA()
})
, To = e => (t, n) => {
  let r = bA(t, e, n);
  return xi({
      type: 2,
      toast: r
  }),
  r.id
}
, Mt = (e, t) => To("blank")(e, t);
Mt.error = To("error");
Mt.success = To("success");
Mt.loading = To("loading");
Mt.custom = To("custom");
Mt.dismiss = e => {
  xi({
      type: 3,
      toastId: e
  })
}
;
Mt.remove = e => xi({
  type: 4,
  toastId: e
});
Mt.promise = (e, t, n) => {
  let r = Mt.loading(t.loading, {
      ...n,
      ...n == null ? void 0 : n.loading
  });
  return e.then(i => (Mt.success(jl(t.success, i), {
      id: r,
      ...n,
      ...n == null ? void 0 : n.success
  }),
  i)).catch(i => {
      Mt.error(jl(t.error, i), {
          id: r,
          ...n,
          ...n == null ? void 0 : n.error
      })
  }
  ),
  e
}
;
var xA = (e, t) => {
  xi({
      type: 1,
      toast: {
          id: e,
          height: t
      }
  })
}
, EA = () => {
  xi({
      type: 5,
      time: Date.now()
  })
}
, SA = e => {
  let {toasts: t, pausedAt: n} = wA(e);
  _.useEffect( () => {
      if (n)
          return;
      let s = Date.now()
        , a = t.map(o => {
          if (o.duration === 1 / 0)
              return;
          let u = (o.duration || 0) + o.pauseDuration - (s - o.createdAt);
          if (u < 0) {
              o.visible && Mt.dismiss(o.id);
              return
          }
          return setTimeout( () => Mt.dismiss(o.id), u)
      }
      );
      return () => {
          a.forEach(o => o && clearTimeout(o))
      }
  }
  , [t, n]);
  let r = _.useCallback( () => {
      n && xi({
          type: 6,
          time: Date.now()
      })
  }
  , [n])
    , i = _.useCallback( (s, a) => {
      let {reverseOrder: o=!1, gutter: u=8, defaultPosition: l} = a || {}
        , c = t.filter(y => (y.position || l) === (s.position || l) && y.height)
        , f = c.findIndex(y => y.id === s.id)
        , d = c.filter( (y, m) => m < f && y.visible).length;
      return c.filter(y => y.visible).slice(...o ? [d + 1] : [0, d]).reduce( (y, m) => y + (m.height || 0) + u, 0)
  }
  , [t]);
  return {
      toasts: t,
      handlers: {
          updateHeight: xA,
          startPause: EA,
          endPause: r,
          calculateOffset: i
      }
  }
}
, CA = Xn`
from {
transform: scale(0) rotate(45deg);
opacity: 0;
}
to {
transform: scale(1) rotate(45deg);
opacity: 1;
}`
, _A = Xn`
from {
transform: scale(0);
opacity: 0;
}
to {
transform: scale(1);
opacity: 1;
}`
, PA = Xn`
from {
transform: scale(0) rotate(90deg);
opacity: 0;
}
to {
transform: scale(1) rotate(90deg);
opacity: 1;
}`
, TA = Hr("div")`
width: 20px;
opacity: 0;
height: 20px;
border-radius: 10px;
background: ${e => e.primary || "#ff4b4b"};
position: relative;
transform: rotate(45deg);

animation: ${CA} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
  forwards;
animation-delay: 100ms;

&:after,
&:before {
  content: '';
  animation: ${_A} 0.15s ease-out forwards;
  animation-delay: 150ms;
  position: absolute;
  border-radius: 3px;
  opacity: 0;
  background: ${e => e.secondary || "#fff"};
  bottom: 9px;
  left: 4px;
  height: 2px;
  width: 12px;
}

&:before {
  animation: ${PA} 0.15s ease-out forwards;
  animation-delay: 180ms;
  transform: rotate(90deg);
}
`
, OA = Xn`
from {
  transform: rotate(0deg);
}
to {
  transform: rotate(360deg);
}
`
, kA = Hr("div")`
width: 12px;
height: 12px;
box-sizing: border-box;
border: 2px solid;
border-radius: 100%;
border-color: ${e => e.secondary || "#e0e0e0"};
border-right-color: ${e => e.primary || "#616161"};
animation: ${OA} 1s linear infinite;
`
, DA = Xn`
from {
transform: scale(0) rotate(45deg);
opacity: 0;
}
to {
transform: scale(1) rotate(45deg);
opacity: 1;
}`
, IA = Xn`
0% {
height: 0;
width: 0;
opacity: 0;
}
40% {
height: 0;
width: 6px;
opacity: 1;
}
100% {
opacity: 1;
height: 10px;
}`
, AA = Hr("div")`
width: 20px;
opacity: 0;
height: 20px;
border-radius: 10px;
background: ${e => e.primary || "#61d345"};
position: relative;
transform: rotate(45deg);

animation: ${DA} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
  forwards;
animation-delay: 100ms;
&:after {
  content: '';
  box-sizing: border-box;
  animation: ${IA} 0.2s ease-out forwards;
  opacity: 0;
  animation-delay: 200ms;
  position: absolute;
  border-right: 2px solid;
  border-bottom: 2px solid;
  border-color: ${e => e.secondary || "#fff"};
  bottom: 6px;
  left: 6px;
  height: 10px;
  width: 6px;
}
`
, $A = Hr("div")`
position: absolute;
`
, RA = Hr("div")`
position: relative;
display: flex;
justify-content: center;
align-items: center;
min-width: 20px;
min-height: 20px;
`
, NA = Xn`
from {
transform: scale(0.6);
opacity: 0.4;
}
to {
transform: scale(1);
opacity: 1;
}`
, jA = Hr("div")`
position: relative;
transform: scale(0.6);
opacity: 0.4;
min-width: 20px;
animation: ${NA} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
  forwards;
`
, MA = ({toast: e}) => {
  let {icon: t, type: n, iconTheme: r} = e;
  return t !== void 0 ? typeof t == "string" ? _.createElement(jA, null, t) : t : n === "blank" ? null : _.createElement(RA, null, _.createElement(kA, {
      ...r
  }), n !== "loading" && _.createElement($A, null, n === "error" ? _.createElement(TA, {
      ...r
  }) : _.createElement(AA, {
      ...r
  })))
}
, LA = e => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`
, FA = e => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`
, UA = "0%{opacity:0;} 100%{opacity:1;}"
, zA = "0%{opacity:1;} 100%{opacity:0;}"
, BA = Hr("div")`
display: flex;
align-items: center;
background: #fff;
color: #363636;
line-height: 1.3;
will-change: transform;
box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
max-width: 350px;
pointer-events: auto;
padding: 8px 10px;
border-radius: 8px;
`
, WA = Hr("div")`
display: flex;
justify-content: center;
margin: 4px 10px;
color: inherit;
flex: 1 1 auto;
white-space: pre-line;
`
, HA = (e, t) => {
  let n = e.includes("top") ? 1 : -1
    , [r,i] = BE() ? [UA, zA] : [LA(n), FA(n)];
  return {
      animation: t ? `${Xn(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Xn(i)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`
  }
}
, qA = _.memo( ({toast: e, position: t, style: n, children: r}) => {
  let i = e.height ? HA(e.position || t || "top-center", e.visible) : {
      opacity: 0
  }
    , s = _.createElement(MA, {
      toast: e
  })
    , a = _.createElement(WA, {
      ...e.ariaProps
  }, jl(e.message, e));
  return _.createElement(BA, {
      className: e.className,
      style: {
          ...i,
          ...n,
          ...e.style
      }
  }, typeof r == "function" ? r({
      icon: s,
      message: a
  }) : _.createElement(_.Fragment, null, s, a))
}
);
dA(_.createElement);
var VA = ({id: e, className: t, style: n, onHeightUpdate: r, children: i}) => {
  let s = _.useCallback(a => {
      if (a) {
          let o = () => {
              let u = a.getBoundingClientRect().height;
              r(e, u)
          }
          ;
          o(),
          new MutationObserver(o).observe(a, {
              subtree: !0,
              childList: !0,
              characterData: !0
          })
      }
  }
  , [e, r]);
  return _.createElement("div", {
      ref: s,
      className: t,
      style: n
  }, i)
}
, KA = (e, t) => {
  let n = e.includes("top")
    , r = n ? {
      top: 0
  } : {
      bottom: 0
  }
    , i = e.includes("center") ? {
      justifyContent: "center"
  } : e.includes("right") ? {
      justifyContent: "flex-end"
  } : {};
  return {
      left: 0,
      right: 0,
      display: "flex",
      position: "absolute",
      transition: BE() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)",
      transform: `translateY(${t * (n ? 1 : -1)}px)`,
      ...r,
      ...i
  }
}
, GA = Qc`
z-index: 9999;
> * {
  pointer-events: auto;
}
`
, fu = 16
, QA = ({reverseOrder: e, position: t="top-center", toastOptions: n, gutter: r, children: i, containerStyle: s, containerClassName: a}) => {
  let {toasts: o, handlers: u} = SA(n);
  return _.createElement("div", {
      style: {
          position: "fixed",
          zIndex: 9999,
          top: fu,
          left: fu,
          right: fu,
          bottom: fu,
          pointerEvents: "none",
          ...s
      },
      className: a,
      onMouseEnter: u.startPause,
      onMouseLeave: u.endPause
  }, o.map(l => {
      let c = l.position || t
        , f = u.calculateOffset(l, {
          reverseOrder: e,
          gutter: r,
          defaultPosition: t
      })
        , d = KA(c, f);
      return _.createElement(VA, {
          id: l.id,
          key: l.id,
          onHeightUpdate: u.updateHeight,
          className: l.visible ? GA : "",
          style: d
      }, l.type === "custom" ? jl(l.message, l) : i ? i(l) : _.createElement(qA, {
          toast: l,
          position: c
      }))
  }
  ))
}
, t7 = Mt
, WE = {
  exports: {}
}
, YA = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
, XA = YA
, JA = XA;
function HE() {}
function qE() {}
qE.resetWarningCache = HE;
var ZA = function() {
  function e(r, i, s, a, o, u) {
      if (u !== JA) {
          var l = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
          throw l.name = "Invariant Violation",
          l
      }
  }
  e.isRequired = e;
  function t() {
      return e
  }
  var n = {
      array: e,
      bigint: e,
      bool: e,
      func: e,
      number: e,
      object: e,
      string: e,
      symbol: e,
      any: e,
      arrayOf: t,
      element: e,
      elementType: e,
      instanceOf: t,
      node: e,
      objectOf: t,
      oneOf: t,
      oneOfType: t,
      shape: t,
      exact: t,
      checkPropTypes: qE,
      resetWarningCache: HE
  };
  return n.PropTypes = n,
  n
};
WE.exports = ZA();
var Oo = WE.exports;
const Qr = gi(Oo);
function Yc(e, t) {
  const n = Ll(e)
    , r = Ll(t)
    , i = n.pop()
    , s = r.pop()
    , a = dh(n, r);
  return a !== 0 ? a : i && s ? dh(i.split("."), s.split(".")) : i || s ? i ? -1 : 1 : 0
}
const e$ = e => typeof e == "string" && /^[v\d]/.test(e) && VE.test(e)
, Ml = (e, t, n) => {
  r$(n);
  const r = Yc(e, t);
  return KE[n].includes(r)
}
, t$ = (e, t) => {
  const n = t.match(/^([<>=~^]+)/)
    , r = n ? n[1] : "=";
  if (r !== "^" && r !== "~")
      return Ml(e, t, r);
  const [i,s,a] = Ll(e)
    , [o,u,l] = Ll(t);
  return Wu(i, o) !== 0 ? !1 : r === "^" ? dh([s, a], [u, l]) >= 0 : Wu(s, u) !== 0 ? !1 : Wu(a, l) >= 0
}
;
Yc.validate = e$;
Yc.compare = Ml;
Yc.satisfies = t$;
const VE = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i
, Ll = e => {
  if (typeof e != "string")
      throw new TypeError("Invalid argument expected string");
  const t = e.match(VE);
  if (!t)
      throw new Error(`Invalid argument not valid semver ('${e}' received)`);
  return t.shift(),
  t
}
, Uv = e => e === "*" || e === "x" || e === "X"
, zv = e => {
  const t = parseInt(e, 10);
  return isNaN(t) ? e : t
}
, n$ = (e, t) => typeof e != typeof t ? [String(e), String(t)] : [e, t]
, Wu = (e, t) => {
  if (Uv(e) || Uv(t))
      return 0;
  const [n,r] = n$(zv(e), zv(t));
  return n > r ? 1 : n < r ? -1 : 0
}
, dh = (e, t) => {
  for (let n = 0; n < Math.max(e.length, t.length); n++) {
      const r = Wu(e[n] || 0, t[n] || 0);
      if (r !== 0)
          return r
  }
  return 0
}
, KE = {
  ">": [1],
  ">=": [0, 1],
  "=": [0],
  "<=": [-1, 0],
  "<": [-1]
}
, Bv = Object.keys(KE)
, r$ = e => {
  if (typeof e != "string")
      throw new TypeError(`Invalid operator type, expected string but got ${typeof e}`);
  if (Bv.indexOf(e) === -1)
      throw new Error(`Invalid operator, expected one of ${Bv.join("|")}`)
}
;
typeof Symbol < "u" && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")));
typeof Symbol < "u" && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
function Wv(e, t) {
  try {
      var n = e()
  } catch (r) {
      return t(r)
  }
  return n && n.then ? n.then(void 0, t) : n
}
var i$ = _.createContext({
  checkCacheStatus: function() {}
});
function GE(e) {
  var t = e.children
    , n = t === void 0 ? null : t
    , r = e.currentVersion
    , i = e.isEnabled
    , s = i === void 0 ? !1 : i
    , a = e.isVerboseMode
    , o = a === void 0 ? !1 : a
    , u = e.loadingComponent
    , l = u === void 0 ? null : u
    , c = e.metaFileDirectory
    , f = c === void 0 ? null : c
    , d = e.reloadOnDowngrade
    , y = d === void 0 ? !1 : d
    , m = e.onCacheClear
    , v = _.useState({
      loading: !0,
      isLatestVersion: !1
  })
    , b = v[0]
    , w = v[1]
    , h = function(C, T) {
      o && (T ? console.error(C) : console.log(C))
  };
  _.useEffect(function() {
      s ? x() : h("React Cache Buster is disabled.")
  }, []);
  var g = function() {
      return !f || f === "." ? "" : f
  }
    , x = _.useCallback(function() {
      try {
          var p = Wv(function() {
              return Promise.resolve(fetch(g() + "/meta.json")).then(function(C) {
                  return Promise.resolve(C.json()).then(function(T) {
                      var O = T.version
                        , R = S(O, r);
                      R ? (h("There is a new version (v" + O + "). Should force refresh."),
                      w({
                          loading: !1,
                          isLatestVersion: !1
                      })) : (h("There is no new version. No cache refresh needed."),
                      w({
                          loading: !1,
                          isLatestVersion: !0
                      }))
                  })
              })
          }, function(C) {
              h("An error occurred while checking cache status.", !0),
              h(C, !0),
              !o && w({
                  loading: !1,
                  isLatestVersion: !0
              })
          });
          return Promise.resolve(p && p.then ? p.then(function() {}) : void 0)
      } catch (C) {
          return Promise.reject(C)
      }
  }, [r, o, f])
    , S = function(C, T) {
      return y ? !Ml(C, T, "=") : Ml(C, T, ">")
  }
    , E = function() {
      try {
          return Promise.resolve(Wv(function() {
              var C = function() {
                  var T;
                  if ((T = window) !== null && T !== void 0 && T.caches) {
                      var O = window
                        , R = O.caches;
                      return Promise.resolve(R.keys()).then(function(j) {
                          var L = j.map(function(M) {
                              return R.delete(M)
                          });
                          return Promise.resolve(Promise.all(L)).then(function() {
                              h("The cache has been deleted."),
                              window.location.reload(!0)
                          })
                      })
                  }
              }();
              if (C && C.then)
                  return C.then(function() {})
          }, function(C) {
              h("An error occurred while deleting the cache.", !0),
              h(C, !0)
          }))
      } catch (C) {
          return Promise.reject(C)
      }
  };
  return s ? b.loading ? l : !b.loading && !b.isLatestVersion ? (m ? m(E) : E(),
  null) : We.createElement(i$.Provider, {
      value: {
          checkCacheStatus: x
      }
  }, n) : n
}
GE.propTypes = {
  children: Qr.element.isRequired,
  currentVersion: Qr.string.isRequired,
  isEnabled: Qr.bool.isRequired,
  isVerboseMode: Qr.bool,
  loadingComponent: Qr.element,
  metaFileDirectory: Qr.string,
  onCacheClear: Qr.func
};
const s$ = "chimpzee-stake-website"
, a$ = "0.2.2"
, o$ = "module"
, u$ = {
  "generate-meta-tag": "node ./node_modules/react-cache-buster/dist/generate-meta-tag.js",
  dev: "vite",
  build: "yarn generate-meta-tag && vite build",
  lint: "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
  preview: "vite preview"
}
, l$ = {
  "@web3modal/ethereum": "^2.7.1",
  "@web3modal/react": "^2.7.1",
  "driver.js": "^1.3.1",
  "framer-motion": "^10.16.16",
  i18next: "^23.7.11",
  "i18next-browser-languagedetector": "^7.2.0",
  "i18next-http-backend": "^2.4.2",
  "loadable-image": "^3.2.3",
  react: "^18.2.0",
  "react-cache-buster": "^0.1.8",
  "react-countdown": "^2.3.5",
  "react-dom": "^18.2.0",
  "react-hot-toast": "^2.4.1",
  "react-i18next": "^14.0.0",
  "react-icons": "^4.12.0",
  "react-loader-spinner": "^6.1.4",
  "react-paginate": "^8.2.0",
  "react-router-dom": "^6.21.1",
  "react-scroll": "^1.9.0",
  "styled-components": "5.3.11",
  "transitions-kit": "^1.2.3",
  viem: "1.21.4",
  wagmi: "1.4.13",
  web3: "^4.3.0"
}
, c$ = {
  "@types/react": "^18.2.43",
  "@types/react-dom": "^18.2.17",
  "@vitejs/plugin-react": "^4.2.1",
  eslint: "^8.55.0",
  "eslint-plugin-react": "^7.33.2",
  "eslint-plugin-react-hooks": "^4.6.0",
  "eslint-plugin-react-refresh": "^0.4.5",
  vite: "^5.0.8"
}
, f$ = {
  name: s$,
  private: !0,
  version: a$,
  type: o$,
  scripts: u$,
  dependencies: l$,
  devDependencies: c$
};
var QE = {
  exports: {}
}
, pe = {};
/** @license React v16.13.1
* react-is.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var Ze = typeof Symbol == "function" && Symbol.for
, Ty = Ze ? Symbol.for("react.element") : 60103
, Oy = Ze ? Symbol.for("react.portal") : 60106
, Xc = Ze ? Symbol.for("react.fragment") : 60107
, Jc = Ze ? Symbol.for("react.strict_mode") : 60108
, Zc = Ze ? Symbol.for("react.profiler") : 60114
, ef = Ze ? Symbol.for("react.provider") : 60109
, tf = Ze ? Symbol.for("react.context") : 60110
, ky = Ze ? Symbol.for("react.async_mode") : 60111
, nf = Ze ? Symbol.for("react.concurrent_mode") : 60111
, rf = Ze ? Symbol.for("react.forward_ref") : 60112
, sf = Ze ? Symbol.for("react.suspense") : 60113
, d$ = Ze ? Symbol.for("react.suspense_list") : 60120
, af = Ze ? Symbol.for("react.memo") : 60115
, of = Ze ? Symbol.for("react.lazy") : 60116
, p$ = Ze ? Symbol.for("react.block") : 60121
, h$ = Ze ? Symbol.for("react.fundamental") : 60117
, m$ = Ze ? Symbol.for("react.responder") : 60118
, y$ = Ze ? Symbol.for("react.scope") : 60119;
function Wt(e) {
  if (typeof e == "object" && e !== null) {
      var t = e.$$typeof;
      switch (t) {
      case Ty:
          switch (e = e.type,
          e) {
          case ky:
          case nf:
          case Xc:
          case Zc:
          case Jc:
          case sf:
              return e;
          default:
              switch (e = e && e.$$typeof,
              e) {
              case tf:
              case rf:
              case of:
              case af:
              case ef:
                  return e;
              default:
                  return t
              }
          }
      case Oy:
          return t
      }
  }
}
function YE(e) {
  return Wt(e) === nf
}
pe.AsyncMode = ky;
pe.ConcurrentMode = nf;
pe.ContextConsumer = tf;
pe.ContextProvider = ef;
pe.Element = Ty;
pe.ForwardRef = rf;
pe.Fragment = Xc;
pe.Lazy = of;
pe.Memo = af;
pe.Portal = Oy;
pe.Profiler = Zc;
pe.StrictMode = Jc;
pe.Suspense = sf;
pe.isAsyncMode = function(e) {
  return YE(e) || Wt(e) === ky
}
;
pe.isConcurrentMode = YE;
pe.isContextConsumer = function(e) {
  return Wt(e) === tf
}
;
pe.isContextProvider = function(e) {
  return Wt(e) === ef
}
;
pe.isElement = function(e) {
  return typeof e == "object" && e !== null && e.$$typeof === Ty
}
;
pe.isForwardRef = function(e) {
  return Wt(e) === rf
}
;
pe.isFragment = function(e) {
  return Wt(e) === Xc
}
;
pe.isLazy = function(e) {
  return Wt(e) === of
}
;
pe.isMemo = function(e) {
  return Wt(e) === af
}
;
pe.isPortal = function(e) {
  return Wt(e) === Oy
}
;
pe.isProfiler = function(e) {
  return Wt(e) === Zc
}
;
pe.isStrictMode = function(e) {
  return Wt(e) === Jc
}
;
pe.isSuspense = function(e) {
  return Wt(e) === sf
}
;
pe.isValidElementType = function(e) {
  return typeof e == "string" || typeof e == "function" || e === Xc || e === nf || e === Zc || e === Jc || e === sf || e === d$ || typeof e == "object" && e !== null && (e.$$typeof === of || e.$$typeof === af || e.$$typeof === ef || e.$$typeof === tf || e.$$typeof === rf || e.$$typeof === h$ || e.$$typeof === m$ || e.$$typeof === y$ || e.$$typeof === p$)
}
;
pe.typeOf = Wt;
QE.exports = pe;
var Dy = QE.exports;
function g$(e) {
  function t(z, N, F, K, k) {
      for (var Q = 0, U = 0, te = 0, J = 0, Z, G, re = 0, De = 0, ae, Ie = ae = Z = 0, le = 0, je = 0, tr = 0, ce = 0, Me = F.length, Ae = Me - 1, he, X = "", oe = "", Fe = "", Ue = "", ve; le < Me; ) {
          if (G = F.charCodeAt(le),
          le === Ae && U + J + te + Q !== 0 && (U !== 0 && (G = U === 47 ? 10 : 47),
          J = te = Q = 0,
          Me++,
          Ae++),
          U + J + te + Q === 0) {
              if (le === Ae && (0 < je && (X = X.replace(d, "")),
              0 < X.trim().length)) {
                  switch (G) {
                  case 32:
                  case 9:
                  case 59:
                  case 13:
                  case 10:
                      break;
                  default:
                      X += F.charAt(le)
                  }
                  G = 59
              }
              switch (G) {
              case 123:
                  for (X = X.trim(),
                  Z = X.charCodeAt(0),
                  ae = 1,
                  ce = ++le; le < Me; ) {
                      switch (G = F.charCodeAt(le)) {
                      case 123:
                          ae++;
                          break;
                      case 125:
                          ae--;
                          break;
                      case 47:
                          switch (G = F.charCodeAt(le + 1)) {
                          case 42:
                          case 47:
                              e: {
                                  for (Ie = le + 1; Ie < Ae; ++Ie)
                                      switch (F.charCodeAt(Ie)) {
                                      case 47:
                                          if (G === 42 && F.charCodeAt(Ie - 1) === 42 && le + 2 !== Ie) {
                                              le = Ie + 1;
                                              break e
                                          }
                                          break;
                                      case 10:
                                          if (G === 47) {
                                              le = Ie + 1;
                                              break e
                                          }
                                      }
                                  le = Ie
                              }
                          }
                          break;
                      case 91:
                          G++;
                      case 40:
                          G++;
                      case 34:
                      case 39:
                          for (; le++ < Ae && F.charCodeAt(le) !== G; )
                              ;
                      }
                      if (ae === 0)
                          break;
                      le++
                  }
                  switch (ae = F.substring(ce, le),
                  Z === 0 && (Z = (X = X.replace(f, "").trim()).charCodeAt(0)),
                  Z) {
                  case 64:
                      switch (0 < je && (X = X.replace(d, "")),
                      G = X.charCodeAt(1),
                      G) {
                      case 100:
                      case 109:
                      case 115:
                      case 45:
                          je = N;
                          break;
                      default:
                          je = A
                      }
                      if (ae = t(N, je, ae, G, k + 1),
                      ce = ae.length,
                      0 < I && (je = n(A, X, tr),
                      ve = o(3, ae, je, N, L, j, ce, G, k, K),
                      X = je.join(""),
                      ve !== void 0 && (ce = (ae = ve.trim()).length) === 0 && (G = 0,
                      ae = "")),
                      0 < ce)
                          switch (G) {
                          case 115:
                              X = X.replace(E, a);
                          case 100:
                          case 109:
                          case 45:
                              ae = X + "{" + ae + "}";
                              break;
                          case 107:
                              X = X.replace(h, "$1 $2"),
                              ae = X + "{" + ae + "}",
                              ae = P === 1 || P === 2 && s("@" + ae, 3) ? "@-webkit-" + ae + "@" + ae : "@" + ae;
                              break;
                          default:
                              ae = X + ae,
                              K === 112 && (ae = (oe += ae,
                              ""))
                          }
                      else
                          ae = "";
                      break;
                  default:
                      ae = t(N, n(N, X, tr), ae, K, k + 1)
                  }
                  Fe += ae,
                  ae = tr = je = Ie = Z = 0,
                  X = "",
                  G = F.charCodeAt(++le);
                  break;
              case 125:
              case 59:
                  if (X = (0 < je ? X.replace(d, "") : X).trim(),
                  1 < (ce = X.length))
                      switch (Ie === 0 && (Z = X.charCodeAt(0),
                      Z === 45 || 96 < Z && 123 > Z) && (ce = (X = X.replace(" ", ":")).length),
                      0 < I && (ve = o(1, X, N, z, L, j, oe.length, K, k, K)) !== void 0 && (ce = (X = ve.trim()).length) === 0 && (X = "\0\0"),
                      Z = X.charCodeAt(0),
                      G = X.charCodeAt(1),
                      Z) {
                      case 0:
                          break;
                      case 64:
                          if (G === 105 || G === 99) {
                              Ue += X + F.charAt(le);
                              break
                          }
                      default:
                          X.charCodeAt(ce - 1) !== 58 && (oe += i(X, Z, G, X.charCodeAt(2)))
                      }
                  tr = je = Ie = Z = 0,
                  X = "",
                  G = F.charCodeAt(++le)
              }
          }
          switch (G) {
          case 13:
          case 10:
              U === 47 ? U = 0 : 1 + Z === 0 && K !== 107 && 0 < X.length && (je = 1,
              X += "\0"),
              0 < I * B && o(0, X, N, z, L, j, oe.length, K, k, K),
              j = 1,
              L++;
              break;
          case 59:
          case 125:
              if (U + J + te + Q === 0) {
                  j++;
                  break
              }
          default:
              switch (j++,
              he = F.charAt(le),
              G) {
              case 9:
              case 32:
                  if (J + Q + U === 0)
                      switch (re) {
                      case 44:
                      case 58:
                      case 9:
                      case 32:
                          he = "";
                          break;
                      default:
                          G !== 32 && (he = " ")
                      }
                  break;
              case 0:
                  he = "\\0";
                  break;
              case 12:
                  he = "\\f";
                  break;
              case 11:
                  he = "\\v";
                  break;
              case 38:
                  J + U + Q === 0 && (je = tr = 1,
                  he = "\f" + he);
                  break;
              case 108:
                  if (J + U + Q + M === 0 && 0 < Ie)
                      switch (le - Ie) {
                      case 2:
                          re === 112 && F.charCodeAt(le - 3) === 58 && (M = re);
                      case 8:
                          De === 111 && (M = De)
                      }
                  break;
              case 58:
                  J + U + Q === 0 && (Ie = le);
                  break;
              case 44:
                  U + te + J + Q === 0 && (je = 1,
                  he += "\r");
                  break;
              case 34:
              case 39:
                  U === 0 && (J = J === G ? 0 : J === 0 ? G : J);
                  break;
              case 91:
                  J + U + te === 0 && Q++;
                  break;
              case 93:
                  J + U + te === 0 && Q--;
                  break;
              case 41:
                  J + U + Q === 0 && te--;
                  break;
              case 40:
                  if (J + U + Q === 0) {
                      if (Z === 0)
                          switch (2 * re + 3 * De) {
                          case 533:
                              break;
                          default:
                              Z = 1
                          }
                      te++
                  }
                  break;
              case 64:
                  U + te + J + Q + Ie + ae === 0 && (ae = 1);
                  break;
              case 42:
              case 47:
                  if (!(0 < J + Q + te))
                      switch (U) {
                      case 0:
                          switch (2 * G + 3 * F.charCodeAt(le + 1)) {
                          case 235:
                              U = 47;
                              break;
                          case 220:
                              ce = le,
                              U = 42
                          }
                          break;
                      case 42:
                          G === 47 && re === 42 && ce + 2 !== le && (F.charCodeAt(ce + 2) === 33 && (oe += F.substring(ce, le + 1)),
                          he = "",
                          U = 0)
                      }
              }
              U === 0 && (X += he)
          }
          De = re,
          re = G,
          le++
      }
      if (ce = oe.length,
      0 < ce) {
          if (je = N,
          0 < I && (ve = o(2, oe, je, z, L, j, ce, K, k, K),
          ve !== void 0 && (oe = ve).length === 0))
              return Ue + oe + Fe;
          if (oe = je.join(",") + "{" + oe + "}",
          P * M !== 0) {
              switch (P !== 2 || s(oe, 2) || (M = 0),
              M) {
              case 111:
                  oe = oe.replace(x, ":-moz-$1") + oe;
                  break;
              case 112:
                  oe = oe.replace(g, "::-webkit-input-$1") + oe.replace(g, "::-moz-$1") + oe.replace(g, ":-ms-input-$1") + oe
              }
              M = 0
          }
      }
      return Ue + oe + Fe
  }
  function n(z, N, F) {
      var K = N.trim().split(b);
      N = K;
      var k = K.length
        , Q = z.length;
      switch (Q) {
      case 0:
      case 1:
          var U = 0;
          for (z = Q === 0 ? "" : z[0] + " "; U < k; ++U)
              N[U] = r(z, N[U], F).trim();
          break;
      default:
          var te = U = 0;
          for (N = []; U < k; ++U)
              for (var J = 0; J < Q; ++J)
                  N[te++] = r(z[J] + " ", K[U], F).trim()
      }
      return N
  }
  function r(z, N, F) {
      var K = N.charCodeAt(0);
      switch (33 > K && (K = (N = N.trim()).charCodeAt(0)),
      K) {
      case 38:
          return N.replace(w, "$1" + z.trim());
      case 58:
          return z.trim() + N.replace(w, "$1" + z.trim());
      default:
          if (0 < 1 * F && 0 < N.indexOf("\f"))
              return N.replace(w, (z.charCodeAt(0) === 58 ? "" : "$1") + z.trim())
      }
      return z + N
  }
  function i(z, N, F, K) {
      var k = z + ";"
        , Q = 2 * N + 3 * F + 4 * K;
      if (Q === 944) {
          z = k.indexOf(":", 9) + 1;
          var U = k.substring(z, k.length - 1).trim();
          return U = k.substring(0, z).trim() + U + ";",
          P === 1 || P === 2 && s(U, 1) ? "-webkit-" + U + U : U
      }
      if (P === 0 || P === 2 && !s(k, 1))
          return k;
      switch (Q) {
      case 1015:
          return k.charCodeAt(10) === 97 ? "-webkit-" + k + k : k;
      case 951:
          return k.charCodeAt(3) === 116 ? "-webkit-" + k + k : k;
      case 963:
          return k.charCodeAt(5) === 110 ? "-webkit-" + k + k : k;
      case 1009:
          if (k.charCodeAt(4) !== 100)
              break;
      case 969:
      case 942:
          return "-webkit-" + k + k;
      case 978:
          return "-webkit-" + k + "-moz-" + k + k;
      case 1019:
      case 983:
          return "-webkit-" + k + "-moz-" + k + "-ms-" + k + k;
      case 883:
          if (k.charCodeAt(8) === 45)
              return "-webkit-" + k + k;
          if (0 < k.indexOf("image-set(", 11))
              return k.replace(R, "$1-webkit-$2") + k;
          break;
      case 932:
          if (k.charCodeAt(4) === 45)
              switch (k.charCodeAt(5)) {
              case 103:
                  return "-webkit-box-" + k.replace("-grow", "") + "-webkit-" + k + "-ms-" + k.replace("grow", "positive") + k;
              case 115:
                  return "-webkit-" + k + "-ms-" + k.replace("shrink", "negative") + k;
              case 98:
                  return "-webkit-" + k + "-ms-" + k.replace("basis", "preferred-size") + k
              }
          return "-webkit-" + k + "-ms-" + k + k;
      case 964:
          return "-webkit-" + k + "-ms-flex-" + k + k;
      case 1023:
          if (k.charCodeAt(8) !== 99)
              break;
          return U = k.substring(k.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"),
          "-webkit-box-pack" + U + "-webkit-" + k + "-ms-flex-pack" + U + k;
      case 1005:
          return m.test(k) ? k.replace(y, ":-webkit-") + k.replace(y, ":-moz-") + k : k;
      case 1e3:
          switch (U = k.substring(13).trim(),
          N = U.indexOf("-") + 1,
          U.charCodeAt(0) + U.charCodeAt(N)) {
          case 226:
              U = k.replace(S, "tb");
              break;
          case 232:
              U = k.replace(S, "tb-rl");
              break;
          case 220:
              U = k.replace(S, "lr");
              break;
          default:
              return k
          }
          return "-webkit-" + k + "-ms-" + U + k;
      case 1017:
          if (k.indexOf("sticky", 9) === -1)
              break;
      case 975:
          switch (N = (k = z).length - 10,
          U = (k.charCodeAt(N) === 33 ? k.substring(0, N) : k).substring(z.indexOf(":", 7) + 1).trim(),
          Q = U.charCodeAt(0) + (U.charCodeAt(7) | 0)) {
          case 203:
              if (111 > U.charCodeAt(8))
                  break;
          case 115:
              k = k.replace(U, "-webkit-" + U) + ";" + k;
              break;
          case 207:
          case 102:
              k = k.replace(U, "-webkit-" + (102 < Q ? "inline-" : "") + "box") + ";" + k.replace(U, "-webkit-" + U) + ";" + k.replace(U, "-ms-" + U + "box") + ";" + k
          }
          return k + ";";
      case 938:
          if (k.charCodeAt(5) === 45)
              switch (k.charCodeAt(6)) {
              case 105:
                  return U = k.replace("-items", ""),
                  "-webkit-" + k + "-webkit-box-" + U + "-ms-flex-" + U + k;
              case 115:
                  return "-webkit-" + k + "-ms-flex-item-" + k.replace(C, "") + k;
              default:
                  return "-webkit-" + k + "-ms-flex-line-pack" + k.replace("align-content", "").replace(C, "") + k
              }
          break;
      case 973:
      case 989:
          if (k.charCodeAt(3) !== 45 || k.charCodeAt(4) === 122)
              break;
      case 931:
      case 953:
          if (O.test(z) === !0)
              return (U = z.substring(z.indexOf(":") + 1)).charCodeAt(0) === 115 ? i(z.replace("stretch", "fill-available"), N, F, K).replace(":fill-available", ":stretch") : k.replace(U, "-webkit-" + U) + k.replace(U, "-moz-" + U.replace("fill-", "")) + k;
          break;
      case 962:
          if (k = "-webkit-" + k + (k.charCodeAt(5) === 102 ? "-ms-" + k : "") + k,
          F + K === 211 && k.charCodeAt(13) === 105 && 0 < k.indexOf("transform", 10))
              return k.substring(0, k.indexOf(";", 27) + 1).replace(v, "$1-webkit-$2") + k
      }
      return k
  }
  function s(z, N) {
      var F = z.indexOf(N === 1 ? ":" : "{")
        , K = z.substring(0, N !== 3 ? F : 10);
      return F = z.substring(F + 1, z.length - 1),
      W(N !== 2 ? K : K.replace(T, "$1"), F, N)
  }
  function a(z, N) {
      var F = i(N, N.charCodeAt(0), N.charCodeAt(1), N.charCodeAt(2));
      return F !== N + ";" ? F.replace(p, " or ($1)").substring(4) : "(" + N + ")"
  }
  function o(z, N, F, K, k, Q, U, te, J, Z) {
      for (var G = 0, re = N, De; G < I; ++G)
          switch (De = $[G].call(c, z, re, F, K, k, Q, U, te, J, Z)) {
          case void 0:
          case !1:
          case !0:
          case null:
              break;
          default:
              re = De
          }
      if (re !== N)
          return re
  }
  function u(z) {
      switch (z) {
      case void 0:
      case null:
          I = $.length = 0;
          break;
      default:
          if (typeof z == "function")
              $[I++] = z;
          else if (typeof z == "object")
              for (var N = 0, F = z.length; N < F; ++N)
                  u(z[N]);
          else
              B = !!z | 0
      }
      return u
  }
  function l(z) {
      return z = z.prefix,
      z !== void 0 && (W = null,
      z ? typeof z != "function" ? P = 1 : (P = 2,
      W = z) : P = 0),
      l
  }
  function c(z, N) {
      var F = z;
      if (33 > F.charCodeAt(0) && (F = F.trim()),
      ee = F,
      F = [ee],
      0 < I) {
          var K = o(-1, N, F, F, L, j, 0, 0, 0, 0);
          K !== void 0 && typeof K == "string" && (N = K)
      }
      var k = t(A, F, N, 0, 0);
      return 0 < I && (K = o(-2, k, F, F, L, j, k.length, 0, 0, 0),
      K !== void 0 && (k = K)),
      ee = "",
      M = 0,
      j = L = 1,
      k
  }
  var f = /^\0+/g
    , d = /[\0\r\f]/g
    , y = /: */g
    , m = /zoo|gra/
    , v = /([,: ])(transform)/g
    , b = /,\r+?/g
    , w = /([\t\r\n ])*\f?&/g
    , h = /@(k\w+)\s*(\S*)\s*/
    , g = /::(place)/g
    , x = /:(read-only)/g
    , S = /[svh]\w+-[tblr]{2}/
    , E = /\(\s*(.*)\s*\)/g
    , p = /([\s\S]*?);/g
    , C = /-self|flex-/g
    , T = /[^]*?(:[rp][el]a[\w-]+)[^]*/
    , O = /stretch|:\s*\w+\-(?:conte|avail)/
    , R = /([^-])(image-set\()/
    , j = 1
    , L = 1
    , M = 0
    , P = 1
    , A = []
    , $ = []
    , I = 0
    , W = null
    , B = 0
    , ee = "";
  return c.use = u,
  c.set = l,
  e !== void 0 && l(e),
  c
}
var v$ = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
function w$(e) {
  var t = Object.create(null);
  return function(n) {
      return t[n] === void 0 && (t[n] = e(n)),
      t[n]
  }
}
var b$ = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/
, Hv = w$(function(e) {
  return b$.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91
})
, Iy = Dy
, x$ = {
  childContextTypes: !0,
  contextType: !0,
  contextTypes: !0,
  defaultProps: !0,
  displayName: !0,
  getDefaultProps: !0,
  getDerivedStateFromError: !0,
  getDerivedStateFromProps: !0,
  mixins: !0,
  propTypes: !0,
  type: !0
}
, E$ = {
  name: !0,
  length: !0,
  prototype: !0,
  caller: !0,
  callee: !0,
  arguments: !0,
  arity: !0
}
, S$ = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}
, XE = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}
, Ay = {};
Ay[Iy.ForwardRef] = S$;
Ay[Iy.Memo] = XE;
function qv(e) {
  return Iy.isMemo(e) ? XE : Ay[e.$$typeof] || x$
}
var C$ = Object.defineProperty
, _$ = Object.getOwnPropertyNames
, Vv = Object.getOwnPropertySymbols
, P$ = Object.getOwnPropertyDescriptor
, T$ = Object.getPrototypeOf
, Kv = Object.prototype;
function JE(e, t, n) {
  if (typeof t != "string") {
      if (Kv) {
          var r = T$(t);
          r && r !== Kv && JE(e, r, n)
      }
      var i = _$(t);
      Vv && (i = i.concat(Vv(t)));
      for (var s = qv(e), a = qv(t), o = 0; o < i.length; ++o) {
          var u = i[o];
          if (!E$[u] && !(n && n[u]) && !(a && a[u]) && !(s && s[u])) {
              var l = P$(t, u);
              try {
                  C$(e, u, l)
              } catch {}
          }
      }
  }
  return e
}
var O$ = JE;
const k$ = gi(O$);
var Kt = {};
function Un() {
  return (Un = Object.assign || function(e) {
      for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
      }
      return e
  }
  ).apply(this, arguments)
}
var Gv = function(e, t) {
  for (var n = [e[0]], r = 0, i = t.length; r < i; r += 1)
      n.push(t[r], e[r + 1]);
  return n
}
, ph = function(e) {
  return e !== null && typeof e == "object" && (e.toString ? e.toString() : Object.prototype.toString.call(e)) === "[object Object]" && !Dy.typeOf(e)
}
, Fl = Object.freeze([])
, Or = Object.freeze({});
function eo(e) {
  return typeof e == "function"
}
function Qv(e) {
  return e.displayName || e.name || "Component"
}
function $y(e) {
  return e && typeof e.styledComponentId == "string"
}
var ms = typeof process < "u" && Kt !== void 0 && (Kt.REACT_APP_SC_ATTR || Kt.SC_ATTR) || "data-styled"
, Ry = typeof window < "u" && "HTMLElement"in window
, D$ = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && Kt !== void 0 && (Kt.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && Kt.REACT_APP_SC_DISABLE_SPEEDY !== "" ? Kt.REACT_APP_SC_DISABLE_SPEEDY !== "false" && Kt.REACT_APP_SC_DISABLE_SPEEDY : Kt.SC_DISABLE_SPEEDY !== void 0 && Kt.SC_DISABLE_SPEEDY !== "" && Kt.SC_DISABLE_SPEEDY !== "false" && Kt.SC_DISABLE_SPEEDY));
function ko(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      n[r - 1] = arguments[r];
  throw new Error("An error occurred. See https://git.io/JUIaE#" + e + " for more information." + (n.length > 0 ? " Args: " + n.join(", ") : ""))
}
var I$ = function() {
  function e(n) {
      this.groupSizes = new Uint32Array(512),
      this.length = 512,
      this.tag = n
  }
  var t = e.prototype;
  return t.indexOfGroup = function(n) {
      for (var r = 0, i = 0; i < n; i++)
          r += this.groupSizes[i];
      return r
  }
  ,
  t.insertRules = function(n, r) {
      if (n >= this.groupSizes.length) {
          for (var i = this.groupSizes, s = i.length, a = s; n >= a; )
              (a <<= 1) < 0 && ko(16, "" + n);
          this.groupSizes = new Uint32Array(a),
          this.groupSizes.set(i),
          this.length = a;
          for (var o = s; o < a; o++)
              this.groupSizes[o] = 0
      }
      for (var u = this.indexOfGroup(n + 1), l = 0, c = r.length; l < c; l++)
          this.tag.insertRule(u, r[l]) && (this.groupSizes[n]++,
          u++)
  }
  ,
  t.clearGroup = function(n) {
      if (n < this.length) {
          var r = this.groupSizes[n]
            , i = this.indexOfGroup(n)
            , s = i + r;
          this.groupSizes[n] = 0;
          for (var a = i; a < s; a++)
              this.tag.deleteRule(i)
      }
  }
  ,
  t.getGroup = function(n) {
      var r = "";
      if (n >= this.length || this.groupSizes[n] === 0)
          return r;
      for (var i = this.groupSizes[n], s = this.indexOfGroup(n), a = s + i, o = s; o < a; o++)
          r += this.tag.getRule(o) + `/*!sc*/
`;
      return r
  }
  ,
  e
}()
, Hu = new Map
, Ul = new Map
, ha = 1
, du = function(e) {
  if (Hu.has(e))
      return Hu.get(e);
  for (; Ul.has(ha); )
      ha++;
  var t = ha++;
  return Hu.set(e, t),
  Ul.set(t, e),
  t
}
, A$ = function(e) {
  return Ul.get(e)
}
, $$ = function(e, t) {
  t >= ha && (ha = t + 1),
  Hu.set(e, t),
  Ul.set(t, e)
}
, R$ = "style[" + ms + '][data-styled-version="5.3.11"]'
, N$ = new RegExp("^" + ms + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')
, j$ = function(e, t, n) {
  for (var r, i = n.split(","), s = 0, a = i.length; s < a; s++)
      (r = i[s]) && e.registerName(t, r)
}
, M$ = function(e, t) {
  for (var n = (t.textContent || "").split(`/*!sc*/
`), r = [], i = 0, s = n.length; i < s; i++) {
      var a = n[i].trim();
      if (a) {
          var o = a.match(N$);
          if (o) {
              var u = 0 | parseInt(o[1], 10)
                , l = o[2];
              u !== 0 && ($$(l, u),
              j$(e, l, o[3]),
              e.getTag().insertRules(u, r)),
              r.length = 0
          } else
              r.push(a)
      }
  }
}
, L$ = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null
}
, ZE = function(e) {
  var t = document.head
    , n = e || t
    , r = document.createElement("style")
    , i = function(o) {
      for (var u = o.childNodes, l = u.length; l >= 0; l--) {
          var c = u[l];
          if (c && c.nodeType === 1 && c.hasAttribute(ms))
              return c
      }
  }(n)
    , s = i !== void 0 ? i.nextSibling : null;
  r.setAttribute(ms, "active"),
  r.setAttribute("data-styled-version", "5.3.11");
  var a = L$();
  return a && r.setAttribute("nonce", a),
  n.insertBefore(r, s),
  r
}
, F$ = function() {
  function e(n) {
      var r = this.element = ZE(n);
      r.appendChild(document.createTextNode("")),
      this.sheet = function(i) {
          if (i.sheet)
              return i.sheet;
          for (var s = document.styleSheets, a = 0, o = s.length; a < o; a++) {
              var u = s[a];
              if (u.ownerNode === i)
                  return u
          }
          ko(17)
      }(r),
      this.length = 0
  }
  var t = e.prototype;
  return t.insertRule = function(n, r) {
      try {
          return this.sheet.insertRule(r, n),
          this.length++,
          !0
      } catch {
          return !1
      }
  }
  ,
  t.deleteRule = function(n) {
      this.sheet.deleteRule(n),
      this.length--
  }
  ,
  t.getRule = function(n) {
      var r = this.sheet.cssRules[n];
      return r !== void 0 && typeof r.cssText == "string" ? r.cssText : ""
  }
  ,
  e
}()
, U$ = function() {
  function e(n) {
      var r = this.element = ZE(n);
      this.nodes = r.childNodes,
      this.length = 0
  }
  var t = e.prototype;
  return t.insertRule = function(n, r) {
      if (n <= this.length && n >= 0) {
          var i = document.createTextNode(r)
            , s = this.nodes[n];
          return this.element.insertBefore(i, s || null),
          this.length++,
          !0
      }
      return !1
  }
  ,
  t.deleteRule = function(n) {
      this.element.removeChild(this.nodes[n]),
      this.length--
  }
  ,
  t.getRule = function(n) {
      return n < this.length ? this.nodes[n].textContent : ""
  }
  ,
  e
}()
, z$ = function() {
  function e(n) {
      this.rules = [],
      this.length = 0
  }
  var t = e.prototype;
  return t.insertRule = function(n, r) {
      return n <= this.length && (this.rules.splice(n, 0, r),
      this.length++,
      !0)
  }
  ,
  t.deleteRule = function(n) {
      this.rules.splice(n, 1),
      this.length--
  }
  ,
  t.getRule = function(n) {
      return n < this.length ? this.rules[n] : ""
  }
  ,
  e
}()
, Yv = Ry
, B$ = {
  isServer: !Ry,
  useCSSOMInjection: !D$
}
, eS = function() {
  function e(n, r, i) {
      n === void 0 && (n = Or),
      r === void 0 && (r = {}),
      this.options = Un({}, B$, {}, n),
      this.gs = r,
      this.names = new Map(i),
      this.server = !!n.isServer,
      !this.server && Ry && Yv && (Yv = !1,
      function(s) {
          for (var a = document.querySelectorAll(R$), o = 0, u = a.length; o < u; o++) {
              var l = a[o];
              l && l.getAttribute(ms) !== "active" && (M$(s, l),
              l.parentNode && l.parentNode.removeChild(l))
          }
      }(this))
  }
  e.registerId = function(n) {
      return du(n)
  }
  ;
  var t = e.prototype;
  return t.reconstructWithOptions = function(n, r) {
      return r === void 0 && (r = !0),
      new e(Un({}, this.options, {}, n),this.gs,r && this.names || void 0)
  }
  ,
  t.allocateGSInstance = function(n) {
      return this.gs[n] = (this.gs[n] || 0) + 1
  }
  ,
  t.getTag = function() {
      return this.tag || (this.tag = (i = (r = this.options).isServer,
      s = r.useCSSOMInjection,
      a = r.target,
      n = i ? new z$(a) : s ? new F$(a) : new U$(a),
      new I$(n)));
      var n, r, i, s, a
  }
  ,
  t.hasNameForId = function(n, r) {
      return this.names.has(n) && this.names.get(n).has(r)
  }
  ,
  t.registerName = function(n, r) {
      if (du(n),
      this.names.has(n))
          this.names.get(n).add(r);
      else {
          var i = new Set;
          i.add(r),
          this.names.set(n, i)
      }
  }
  ,
  t.insertRules = function(n, r, i) {
      this.registerName(n, r),
      this.getTag().insertRules(du(n), i)
  }
  ,
  t.clearNames = function(n) {
      this.names.has(n) && this.names.get(n).clear()
  }
  ,
  t.clearRules = function(n) {
      this.getTag().clearGroup(du(n)),
      this.clearNames(n)
  }
  ,
  t.clearTag = function() {
      this.tag = void 0
  }
  ,
  t.toString = function() {
      return function(n) {
          for (var r = n.getTag(), i = r.length, s = "", a = 0; a < i; a++) {
              var o = A$(a);
              if (o !== void 0) {
                  var u = n.names.get(o)
                    , l = r.getGroup(a);
                  if (u && l && u.size) {
                      var c = ms + ".g" + a + '[id="' + o + '"]'
                        , f = "";
                      u !== void 0 && u.forEach(function(d) {
                          d.length > 0 && (f += d + ",")
                      }),
                      s += "" + l + c + '{content:"' + f + `"}/*!sc*/
`
                  }
              }
          }
          return s
      }(this)
  }
  ,
  e
}()
, W$ = /(a)(d)/gi
, Xv = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97))
};
function hh(e) {
  var t, n = "";
  for (t = Math.abs(e); t > 52; t = t / 52 | 0)
      n = Xv(t % 52) + n;
  return (Xv(t % 52) + n).replace(W$, "$1-$2")
}
var Gi = function(e, t) {
  for (var n = t.length; n; )
      e = 33 * e ^ t.charCodeAt(--n);
  return e
}
, tS = function(e) {
  return Gi(5381, e)
};
function H$(e) {
  for (var t = 0; t < e.length; t += 1) {
      var n = e[t];
      if (eo(n) && !$y(n))
          return !1
  }
  return !0
}
var q$ = tS("5.3.11")
, V$ = function() {
  function e(t, n, r) {
      this.rules = t,
      this.staticRulesId = "",
      this.isStatic = (r === void 0 || r.isStatic) && H$(t),
      this.componentId = n,
      this.baseHash = Gi(q$, n),
      this.baseStyle = r,
      eS.registerId(n)
  }
  return e.prototype.generateAndInjectStyles = function(t, n, r) {
      var i = this.componentId
        , s = [];
      if (this.baseStyle && s.push(this.baseStyle.generateAndInjectStyles(t, n, r)),
      this.isStatic && !r.hash)
          if (this.staticRulesId && n.hasNameForId(i, this.staticRulesId))
              s.push(this.staticRulesId);
          else {
              var a = ys(this.rules, t, n, r).join("")
                , o = hh(Gi(this.baseHash, a) >>> 0);
              if (!n.hasNameForId(i, o)) {
                  var u = r(a, "." + o, void 0, i);
                  n.insertRules(i, o, u)
              }
              s.push(o),
              this.staticRulesId = o
          }
      else {
          for (var l = this.rules.length, c = Gi(this.baseHash, r.hash), f = "", d = 0; d < l; d++) {
              var y = this.rules[d];
              if (typeof y == "string")
                  f += y;
              else if (y) {
                  var m = ys(y, t, n, r)
                    , v = Array.isArray(m) ? m.join("") : m;
                  c = Gi(c, v + d),
                  f += v
              }
          }
          if (f) {
              var b = hh(c >>> 0);
              if (!n.hasNameForId(i, b)) {
                  var w = r(f, "." + b, void 0, i);
                  n.insertRules(i, b, w)
              }
              s.push(b)
          }
      }
      return s.join(" ")
  }
  ,
  e
}()
, K$ = /^\s*\/\/.*$/gm
, G$ = [":", "[", ".", "#"];
function Q$(e) {
  var t, n, r, i, s = e === void 0 ? Or : e, a = s.options, o = a === void 0 ? Or : a, u = s.plugins, l = u === void 0 ? Fl : u, c = new g$(o), f = [], d = function(v) {
      function b(w) {
          if (w)
              try {
                  v(w + "}")
              } catch {}
      }
      return function(w, h, g, x, S, E, p, C, T, O) {
          switch (w) {
          case 1:
              if (T === 0 && h.charCodeAt(0) === 64)
                  return v(h + ";"),
                  "";
              break;
          case 2:
              if (C === 0)
                  return h + "/*|*/";
              break;
          case 3:
              switch (C) {
              case 102:
              case 112:
                  return v(g[0] + h),
                  "";
              default:
                  return h + (O === 0 ? "/*|*/" : "")
              }
          case -2:
              h.split("/*|*/}").forEach(b)
          }
      }
  }(function(v) {
      f.push(v)
  }), y = function(v, b, w) {
      return b === 0 && G$.indexOf(w[n.length]) !== -1 || w.match(i) ? v : "." + t
  };
  function m(v, b, w, h) {
      h === void 0 && (h = "&");
      var g = v.replace(K$, "")
        , x = b && w ? w + " " + b + " { " + g + " }" : g;
      return t = h,
      n = b,
      r = new RegExp("\\" + n + "\\b","g"),
      i = new RegExp("(\\" + n + "\\b){2,}"),
      c(w || !b ? "" : b, x)
  }
  return c.use([].concat(l, [function(v, b, w) {
      v === 2 && w.length && w[0].lastIndexOf(n) > 0 && (w[0] = w[0].replace(r, y))
  }
  , d, function(v) {
      if (v === -2) {
          var b = f;
          return f = [],
          b
      }
  }
  ])),
  m.hash = l.length ? l.reduce(function(v, b) {
      return b.name || ko(15),
      Gi(v, b.name)
  }, 5381).toString() : "",
  m
}
var nS = We.createContext();
nS.Consumer;
var rS = We.createContext()
, Y$ = (rS.Consumer,
new eS)
, mh = Q$();
function X$() {
  return _.useContext(nS) || Y$
}
function J$() {
  return _.useContext(rS) || mh
}
var Z$ = function() {
  function e(t, n) {
      var r = this;
      this.inject = function(i, s) {
          s === void 0 && (s = mh);
          var a = r.name + s.hash;
          i.hasNameForId(r.id, a) || i.insertRules(r.id, a, s(r.rules, a, "@keyframes"))
      }
      ,
      this.toString = function() {
          return ko(12, String(r.name))
      }
      ,
      this.name = t,
      this.id = "sc-keyframes-" + t,
      this.rules = n
  }
  return e.prototype.getName = function(t) {
      return t === void 0 && (t = mh),
      this.name + t.hash
  }
  ,
  e
}()
, eR = /([A-Z])/
, tR = /([A-Z])/g
, nR = /^ms-/
, rR = function(e) {
  return "-" + e.toLowerCase()
};
function Jv(e) {
  return eR.test(e) ? e.replace(tR, rR).replace(nR, "-ms-") : e
}
var Zv = function(e) {
  return e == null || e === !1 || e === ""
};
function ys(e, t, n, r) {
  if (Array.isArray(e)) {
      for (var i, s = [], a = 0, o = e.length; a < o; a += 1)
          (i = ys(e[a], t, n, r)) !== "" && (Array.isArray(i) ? s.push.apply(s, i) : s.push(i));
      return s
  }
  if (Zv(e))
      return "";
  if ($y(e))
      return "." + e.styledComponentId;
  if (eo(e)) {
      if (typeof (l = e) != "function" || l.prototype && l.prototype.isReactComponent || !t)
          return e;
      var u = e(t);
      return ys(u, t, n, r)
  }
  var l;
  return e instanceof Z$ ? n ? (e.inject(n, r),
  e.getName(r)) : e : ph(e) ? function c(f, d) {
      var y, m, v = [];
      for (var b in f)
          f.hasOwnProperty(b) && !Zv(f[b]) && (Array.isArray(f[b]) && f[b].isCss || eo(f[b]) ? v.push(Jv(b) + ":", f[b], ";") : ph(f[b]) ? v.push.apply(v, c(f[b], b)) : v.push(Jv(b) + ": " + (y = b,
          (m = f[b]) == null || typeof m == "boolean" || m === "" ? "" : typeof m != "number" || m === 0 || y in v$ || y.startsWith("--") ? String(m).trim() : m + "px") + ";"));
      return d ? [d + " {"].concat(v, ["}"]) : v
  }(e) : e.toString()
}
var e1 = function(e) {
  return Array.isArray(e) && (e.isCss = !0),
  e
};
function iR(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      n[r - 1] = arguments[r];
  return eo(e) || ph(e) ? e1(ys(Gv(Fl, [e].concat(n)))) : n.length === 0 && e.length === 1 && typeof e[0] == "string" ? e : e1(ys(Gv(e, n)))
}
var sR = function(e, t, n) {
  return n === void 0 && (n = Or),
  e.theme !== n.theme && e.theme || t || n.theme
}
, aR = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g
, oR = /(^-|-$)/g;
function fd(e) {
  return e.replace(aR, "-").replace(oR, "")
}
var uR = function(e) {
  return hh(tS(e) >>> 0)
};
function pu(e) {
  return typeof e == "string" && !0
}
var yh = function(e) {
  return typeof e == "function" || typeof e == "object" && e !== null && !Array.isArray(e)
}
, lR = function(e) {
  return e !== "__proto__" && e !== "constructor" && e !== "prototype"
};
function cR(e, t, n) {
  var r = e[n];
  yh(t) && yh(r) ? iS(r, t) : e[n] = t
}
function iS(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      n[r - 1] = arguments[r];
  for (var i = 0, s = n; i < s.length; i++) {
      var a = s[i];
      if (yh(a))
          for (var o in a)
              lR(o) && cR(e, a[o], o)
  }
  return e
}
var sS = We.createContext();
sS.Consumer;
var dd = {};
function aS(e, t, n) {
  var r = $y(e)
    , i = !pu(e)
    , s = t.attrs
    , a = s === void 0 ? Fl : s
    , o = t.componentId
    , u = o === void 0 ? function(h, g) {
      var x = typeof h != "string" ? "sc" : fd(h);
      dd[x] = (dd[x] || 0) + 1;
      var S = x + "-" + uR("5.3.11" + x + dd[x]);
      return g ? g + "-" + S : S
  }(t.displayName, t.parentComponentId) : o
    , l = t.displayName
    , c = l === void 0 ? function(h) {
      return pu(h) ? "styled." + h : "Styled(" + Qv(h) + ")"
  }(e) : l
    , f = t.displayName && t.componentId ? fd(t.displayName) + "-" + t.componentId : t.componentId || u
    , d = r && e.attrs ? Array.prototype.concat(e.attrs, a).filter(Boolean) : a
    , y = t.shouldForwardProp;
  r && e.shouldForwardProp && (y = t.shouldForwardProp ? function(h, g, x) {
      return e.shouldForwardProp(h, g, x) && t.shouldForwardProp(h, g, x)
  }
  : e.shouldForwardProp);
  var m, v = new V$(n,f,r ? e.componentStyle : void 0), b = v.isStatic && a.length === 0, w = function(h, g) {
      return function(x, S, E, p) {
          var C = x.attrs
            , T = x.componentStyle
            , O = x.defaultProps
            , R = x.foldedComponentIds
            , j = x.shouldForwardProp
            , L = x.styledComponentId
            , M = x.target
            , P = function(K, k, Q) {
              K === void 0 && (K = Or);
              var U = Un({}, k, {
                  theme: K
              })
                , te = {};
              return Q.forEach(function(J) {
                  var Z, G, re, De = J;
                  for (Z in eo(De) && (De = De(U)),
                  De)
                      U[Z] = te[Z] = Z === "className" ? (G = te[Z],
                      re = De[Z],
                      G && re ? G + " " + re : G || re) : De[Z]
              }),
              [U, te]
          }(sR(S, _.useContext(sS), O) || Or, S, C)
            , A = P[0]
            , $ = P[1]
            , I = function(K, k, Q, U) {
              var te = X$()
                , J = J$()
                , Z = k ? K.generateAndInjectStyles(Or, te, J) : K.generateAndInjectStyles(Q, te, J);
              return Z
          }(T, p, A)
            , W = E
            , B = $.$as || S.$as || $.as || S.as || M
            , ee = pu(B)
            , z = $ !== S ? Un({}, S, {}, $) : S
            , N = {};
          for (var F in z)
              F[0] !== "$" && F !== "as" && (F === "forwardedAs" ? N.as = z[F] : (j ? j(F, Hv, B) : !ee || Hv(F)) && (N[F] = z[F]));
          return S.style && $.style !== S.style && (N.style = Un({}, S.style, {}, $.style)),
          N.className = Array.prototype.concat(R, L, I !== L ? I : null, S.className, $.className).filter(Boolean).join(" "),
          N.ref = W,
          _.createElement(B, N)
      }(m, h, g, b)
  };
  return w.displayName = c,
  (m = We.forwardRef(w)).attrs = d,
  m.componentStyle = v,
  m.displayName = c,
  m.shouldForwardProp = y,
  m.foldedComponentIds = r ? Array.prototype.concat(e.foldedComponentIds, e.styledComponentId) : Fl,
  m.styledComponentId = f,
  m.target = r ? e.target : e,
  m.withComponent = function(h) {
      var g = t.componentId
        , x = function(E, p) {
          if (E == null)
              return {};
          var C, T, O = {}, R = Object.keys(E);
          for (T = 0; T < R.length; T++)
              C = R[T],
              p.indexOf(C) >= 0 || (O[C] = E[C]);
          return O
      }(t, ["componentId"])
        , S = g && g + "-" + (pu(h) ? h : fd(Qv(h)));
      return aS(h, Un({}, x, {
          attrs: d,
          componentId: S
      }), n)
  }
  ,
  Object.defineProperty(m, "defaultProps", {
      get: function() {
          return this._foldedDefaultProps
      },
      set: function(h) {
          this._foldedDefaultProps = r ? iS({}, e.defaultProps, h) : h
      }
  }),
  Object.defineProperty(m, "toString", {
      value: function() {
          return "." + m.styledComponentId
      }
  }),
  i && k$(m, e, {
      attrs: !0,
      componentStyle: !0,
      displayName: !0,
      foldedComponentIds: !0,
      shouldForwardProp: !0,
      styledComponentId: !0,
      target: !0,
      withComponent: !0
  }),
  m
}
var gh = function(e) {
  return function t(n, r, i) {
      if (i === void 0 && (i = Or),
      !Dy.isValidElementType(r))
          return ko(1, String(r));
      var s = function() {
          return n(r, i, iR.apply(void 0, arguments))
      };
      return s.withConfig = function(a) {
          return t(n, r, Un({}, i, {}, a))
      }
      ,
      s.attrs = function(a) {
          return t(n, r, Un({}, i, {
              attrs: Array.prototype.concat(i.attrs, a).filter(Boolean)
          }))
      }
      ,
      s
  }(aS, e)
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e) {
  gh[e] = gh(e)
});
const q = gh
, fR = q.div`
background: #053821;
display: flex;
justify-content: center;
align-items: center;
padding: 0 30px;
min-height: 100vh;
z-index: 1;
`
, dR = q.div`
top: 0;
right: 0;
bottom: 0;
left: 0;
height: 100%;
width: 100%;
overflow: hidden;
text-align: center;
justify-content: center;
align-items: center;
`;
q.h1`
font-size: 64px;
color: #000;
letter-spacing: 5px;

@media screen and (max-width: 768px) {
  font-size: 48px;
}

@media screen and (max-width: 480px) {
  font-size: 36px;
}
`;
const vh = () => D.jsx(fR, {
  children: D.jsx(dR, {
      children: D.jsxs("div", {
          className: "spinner",
          children: [D.jsx("div", {
              className: "bounce1"
          }), D.jsx("div", {
              className: "bounce2"
          }), D.jsx("div", {
              className: "bounce3"
          })]
      })
  })
});
/**
* @remix-run/router v1.14.1
*
* Copyright (c) Remix Software Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE.md file in the root directory of this source tree.
*
* @license MIT
*/
function to() {
  return to = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
      }
      return e
  }
  ,
  to.apply(this, arguments)
}
var yr;
(function(e) {
  e.Pop = "POP",
  e.Push = "PUSH",
  e.Replace = "REPLACE"
}
)(yr || (yr = {}));
const t1 = "popstate";
function pR(e) {
  e === void 0 && (e = {});
  function t(r, i) {
      let {pathname: s, search: a, hash: o} = r.location;
      return wh("", {
          pathname: s,
          search: a,
          hash: o
      }, i.state && i.state.usr || null, i.state && i.state.key || "default")
  }
  function n(r, i) {
      return typeof i == "string" ? i : zl(i)
  }
  return mR(t, n, null, e)
}
function He(e, t) {
  if (e === !1 || e === null || typeof e > "u")
      throw new Error(t)
}
function Ny(e, t) {
  if (!e) {
      typeof console < "u" && console.warn(t);
      try {
          throw new Error(t)
      } catch {}
  }
}
function hR() {
  return Math.random().toString(36).substr(2, 8)
}
function n1(e, t) {
  return {
      usr: e.state,
      key: e.key,
      idx: t
  }
}
function wh(e, t, n, r) {
  return n === void 0 && (n = null),
  to({
      pathname: typeof e == "string" ? e : e.pathname,
      search: "",
      hash: ""
  }, typeof t == "string" ? Ds(t) : t, {
      state: n,
      key: t && t.key || r || hR()
  })
}
function zl(e) {
  let {pathname: t="/", search: n="", hash: r=""} = e;
  return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n),
  r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r),
  t
}
function Ds(e) {
  let t = {};
  if (e) {
      let n = e.indexOf("#");
      n >= 0 && (t.hash = e.substr(n),
      e = e.substr(0, n));
      let r = e.indexOf("?");
      r >= 0 && (t.search = e.substr(r),
      e = e.substr(0, r)),
      e && (t.pathname = e)
  }
  return t
}
function mR(e, t, n, r) {
  r === void 0 && (r = {});
  let {window: i=document.defaultView, v5Compat: s=!1} = r
    , a = i.history
    , o = yr.Pop
    , u = null
    , l = c();
  l == null && (l = 0,
  a.replaceState(to({}, a.state, {
      idx: l
  }), ""));
  function c() {
      return (a.state || {
          idx: null
      }).idx
  }
  function f() {
      o = yr.Pop;
      let b = c()
        , w = b == null ? null : b - l;
      l = b,
      u && u({
          action: o,
          location: v.location,
          delta: w
      })
  }
  function d(b, w) {
      o = yr.Push;
      let h = wh(v.location, b, w);
      n && n(h, b),
      l = c() + 1;
      let g = n1(h, l)
        , x = v.createHref(h);
      try {
          a.pushState(g, "", x)
      } catch (S) {
          if (S instanceof DOMException && S.name === "DataCloneError")
              throw S;
          i.location.assign(x)
      }
      s && u && u({
          action: o,
          location: v.location,
          delta: 1
      })
  }
  function y(b, w) {
      o = yr.Replace;
      let h = wh(v.location, b, w);
      n && n(h, b),
      l = c();
      let g = n1(h, l)
        , x = v.createHref(h);
      a.replaceState(g, "", x),
      s && u && u({
          action: o,
          location: v.location,
          delta: 0
      })
  }
  function m(b) {
      let w = i.location.origin !== "null" ? i.location.origin : i.location.href
        , h = typeof b == "string" ? b : zl(b);
      return He(w, "No window.location.(origin|href) available to create URL for href: " + h),
      new URL(h,w)
  }
  let v = {
      get action() {
          return o
      },
      get location() {
          return e(i, a)
      },
      listen(b) {
          if (u)
              throw new Error("A history only accepts one active listener");
          return i.addEventListener(t1, f),
          u = b,
          () => {
              i.removeEventListener(t1, f),
              u = null
          }
      },
      createHref(b) {
          return t(i, b)
      },
      createURL: m,
      encodeLocation(b) {
          let w = m(b);
          return {
              pathname: w.pathname,
              search: w.search,
              hash: w.hash
          }
      },
      push: d,
      replace: y,
      go(b) {
          return a.go(b)
      }
  };
  return v
}
var r1;
(function(e) {
  e.data = "data",
  e.deferred = "deferred",
  e.redirect = "redirect",
  e.error = "error"
}
)(r1 || (r1 = {}));
function yR(e, t, n) {
  n === void 0 && (n = "/");
  let r = typeof t == "string" ? Ds(t) : t
    , i = jy(r.pathname || "/", n);
  if (i == null)
      return null;
  let s = oS(e);
  gR(s);
  let a = null;
  for (let o = 0; a == null && o < s.length; ++o)
      a = PR(s[o], kR(i));
  return a
}
function oS(e, t, n, r) {
  t === void 0 && (t = []),
  n === void 0 && (n = []),
  r === void 0 && (r = "");
  let i = (s, a, o) => {
      let u = {
          relativePath: o === void 0 ? s.path || "" : o,
          caseSensitive: s.caseSensitive === !0,
          childrenIndex: a,
          route: s
      };
      u.relativePath.startsWith("/") && (He(u.relativePath.startsWith(r), 'Absolute route path "' + u.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
      u.relativePath = u.relativePath.slice(r.length));
      let l = kr([r, u.relativePath])
        , c = n.concat(u);
      s.children && s.children.length > 0 && (He(s.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + l + '".')),
      oS(s.children, t, c, l)),
      !(s.path == null && !s.index) && t.push({
          path: l,
          score: CR(l, s.index),
          routesMeta: c
      })
  }
  ;
  return e.forEach( (s, a) => {
      var o;
      if (s.path === "" || !((o = s.path) != null && o.includes("?")))
          i(s, a);
      else
          for (let u of uS(s.path))
              i(s, a, u)
  }
  ),
  t
}
function uS(e) {
  let t = e.split("/");
  if (t.length === 0)
      return [];
  let[n,...r] = t
    , i = n.endsWith("?")
    , s = n.replace(/\?$/, "");
  if (r.length === 0)
      return i ? [s, ""] : [s];
  let a = uS(r.join("/"))
    , o = [];
  return o.push(...a.map(u => u === "" ? s : [s, u].join("/"))),
  i && o.push(...a),
  o.map(u => e.startsWith("/") && u === "" ? "/" : u)
}
function gR(e) {
  e.sort( (t, n) => t.score !== n.score ? n.score - t.score : _R(t.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex)))
}
const vR = /^:\w+$/
, wR = 3
, bR = 2
, xR = 1
, ER = 10
, SR = -2
, i1 = e => e === "*";
function CR(e, t) {
  let n = e.split("/")
    , r = n.length;
  return n.some(i1) && (r += SR),
  t && (r += bR),
  n.filter(i => !i1(i)).reduce( (i, s) => i + (vR.test(s) ? wR : s === "" ? xR : ER), r)
}
function _R(e, t) {
  return e.length === t.length && e.slice(0, -1).every( (r, i) => r === t[i]) ? e[e.length - 1] - t[t.length - 1] : 0
}
function PR(e, t) {
  let {routesMeta: n} = e
    , r = {}
    , i = "/"
    , s = [];
  for (let a = 0; a < n.length; ++a) {
      let o = n[a]
        , u = a === n.length - 1
        , l = i === "/" ? t : t.slice(i.length) || "/"
        , c = TR({
          path: o.relativePath,
          caseSensitive: o.caseSensitive,
          end: u
      }, l);
      if (!c)
          return null;
      Object.assign(r, c.params);
      let f = o.route;
      s.push({
          params: r,
          pathname: kr([i, c.pathname]),
          pathnameBase: RR(kr([i, c.pathnameBase])),
          route: f
      }),
      c.pathnameBase !== "/" && (i = kr([i, c.pathnameBase]))
  }
  return s
}
function TR(e, t) {
  typeof e == "string" && (e = {
      path: e,
      caseSensitive: !1,
      end: !0
  });
  let[n,r] = OR(e.path, e.caseSensitive, e.end)
    , i = t.match(n);
  if (!i)
      return null;
  let s = i[0]
    , a = s.replace(/(.)\/+$/, "$1")
    , o = i.slice(1);
  return {
      params: r.reduce( (l, c, f) => {
          let {paramName: d, isOptional: y} = c;
          if (d === "*") {
              let v = o[f] || "";
              a = s.slice(0, s.length - v.length).replace(/(.)\/+$/, "$1")
          }
          const m = o[f];
          return y && !m ? l[d] = void 0 : l[d] = DR(m || "", d),
          l
      }
      , {}),
      pathname: s,
      pathnameBase: a,
      pattern: e
  }
}
function OR(e, t, n) {
  t === void 0 && (t = !1),
  n === void 0 && (n = !0),
  Ny(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
  let r = []
    , i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:(\w+)(\?)?/g, (a, o, u) => (r.push({
      paramName: o,
      isOptional: u != null
  }),
  u ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return e.endsWith("*") ? (r.push({
      paramName: "*"
  }),
  i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"),
  [new RegExp(i,t ? void 0 : "i"), r]
}
function kR(e) {
  try {
      return decodeURI(e)
  } catch (t) {
      return Ny(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")),
      e
  }
}
function DR(e, t) {
  try {
      return decodeURIComponent(e)
  } catch (n) {
      return Ny(!1, 'The value for the URL param "' + t + '" will not be decoded because' + (' the string "' + e + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + n + ").")),
      e
  }
}
function jy(e, t) {
  if (t === "/")
      return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
      return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length
    , r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/"
}
function IR(e, t) {
  t === void 0 && (t = "/");
  let {pathname: n, search: r="", hash: i=""} = typeof e == "string" ? Ds(e) : e;
  return {
      pathname: n ? n.startsWith("/") ? n : AR(n, t) : t,
      search: NR(r),
      hash: jR(i)
  }
}
function AR(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach(i => {
      i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i)
  }
  ),
  n.length > 1 ? n.join("/") : "/"
}
function pd(e, t, n, r) {
  return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function $R(e) {
  return e.filter( (t, n) => n === 0 || t.route.path && t.route.path.length > 0)
}
function lS(e, t) {
  let n = $R(e);
  return t ? n.map( (r, i) => i === e.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase)
}
function cS(e, t, n, r) {
  r === void 0 && (r = !1);
  let i;
  typeof e == "string" ? i = Ds(e) : (i = to({}, e),
  He(!i.pathname || !i.pathname.includes("?"), pd("?", "pathname", "search", i)),
  He(!i.pathname || !i.pathname.includes("#"), pd("#", "pathname", "hash", i)),
  He(!i.search || !i.search.includes("#"), pd("#", "search", "hash", i)));
  let s = e === "" || i.pathname === "", a = s ? "/" : i.pathname, o;
  if (a == null)
      o = n;
  else {
      let f = t.length - 1;
      if (!r && a.startsWith("..")) {
          let d = a.split("/");
          for (; d[0] === ".."; )
              d.shift(),
              f -= 1;
          i.pathname = d.join("/")
      }
      o = f >= 0 ? t[f] : "/"
  }
  let u = IR(i, o)
    , l = a && a !== "/" && a.endsWith("/")
    , c = (s || a === ".") && n.endsWith("/");
  return !u.pathname.endsWith("/") && (l || c) && (u.pathname += "/"),
  u
}
const kr = e => e.join("/").replace(/\/\/+/g, "/")
, RR = e => e.replace(/\/+$/, "").replace(/^\/*/, "/")
, NR = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e
, jR = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;
function MR(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data"in e
}
const fS = ["post", "put", "patch", "delete"];
new Set(fS);
const LR = ["get", ...fS];
new Set(LR);
/**
* React Router v6.21.1
*
* Copyright (c) Remix Software Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE.md file in the root directory of this source tree.
*
* @license MIT
*/
function no() {
  return no = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
      }
      return e
  }
  ,
  no.apply(this, arguments)
}
const My = _.createContext(null)
, FR = _.createContext(null)
, Ei = _.createContext(null)
, uf = _.createContext(null)
, qr = _.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
})
, dS = _.createContext(null);
function UR(e, t) {
  let {relative: n} = t === void 0 ? {} : t;
  Do() || He(!1);
  let {basename: r, navigator: i} = _.useContext(Ei)
    , {hash: s, pathname: a, search: o} = hS(e, {
      relative: n
  })
    , u = a;
  return r !== "/" && (u = a === "/" ? r : kr([r, a])),
  i.createHref({
      pathname: u,
      search: o,
      hash: s
  })
}
function Do() {
  return _.useContext(uf) != null
}
function vn() {
  return Do() || He(!1),
  _.useContext(uf).location
}
function pS(e) {
  _.useContext(Ei).static || _.useLayoutEffect(e)
}
function Is() {
  let {isDataRoute: e} = _.useContext(qr);
  return e ? tN() : zR()
}
function zR() {
  Do() || He(!1);
  let e = _.useContext(My)
    , {basename: t, future: n, navigator: r} = _.useContext(Ei)
    , {matches: i} = _.useContext(qr)
    , {pathname: s} = vn()
    , a = JSON.stringify(lS(i, n.v7_relativeSplatPath))
    , o = _.useRef(!1);
  return pS( () => {
      o.current = !0
  }
  ),
  _.useCallback(function(l, c) {
      if (c === void 0 && (c = {}),
      !o.current)
          return;
      if (typeof l == "number") {
          r.go(l);
          return
      }
      let f = cS(l, JSON.parse(a), s, c.relative === "path");
      e == null && t !== "/" && (f.pathname = f.pathname === "/" ? t : kr([t, f.pathname])),
      (c.replace ? r.replace : r.push)(f, c.state, c)
  }, [t, r, a, s, e])
}
const BR = _.createContext(null);
function WR(e) {
  let t = _.useContext(qr).outlet;
  return t && _.createElement(BR.Provider, {
      value: e
  }, t)
}
function hS(e, t) {
  let {relative: n} = t === void 0 ? {} : t
    , {future: r} = _.useContext(Ei)
    , {matches: i} = _.useContext(qr)
    , {pathname: s} = vn()
    , a = JSON.stringify(lS(i, r.v7_relativeSplatPath));
  return _.useMemo( () => cS(e, JSON.parse(a), s, n === "path"), [e, a, s, n])
}
function HR(e, t) {
  return qR(e, t)
}
function qR(e, t, n, r) {
  Do() || He(!1);
  let {navigator: i} = _.useContext(Ei)
    , {matches: s} = _.useContext(qr)
    , a = s[s.length - 1]
    , o = a ? a.params : {};
  a && a.pathname;
  let u = a ? a.pathnameBase : "/";
  a && a.route;
  let l = vn(), c;
  if (t) {
      var f;
      let b = typeof t == "string" ? Ds(t) : t;
      u === "/" || (f = b.pathname) != null && f.startsWith(u) || He(!1),
      c = b
  } else
      c = l;
  let d = c.pathname || "/"
    , y = u === "/" ? d : d.slice(u.length) || "/"
    , m = yR(e, {
      pathname: y
  })
    , v = YR(m && m.map(b => Object.assign({}, b, {
      params: Object.assign({}, o, b.params),
      pathname: kr([u, i.encodeLocation ? i.encodeLocation(b.pathname).pathname : b.pathname]),
      pathnameBase: b.pathnameBase === "/" ? u : kr([u, i.encodeLocation ? i.encodeLocation(b.pathnameBase).pathname : b.pathnameBase])
  })), s, n, r);
  return t && v ? _.createElement(uf.Provider, {
      value: {
          location: no({
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default"
          }, c),
          navigationType: yr.Pop
      }
  }, v) : v
}
function VR() {
  let e = eN()
    , t = MR(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e)
    , n = e instanceof Error ? e.stack : null
    , i = {
      padding: "0.5rem",
      backgroundColor: "rgba(200,200,200, 0.5)"
  }
    , s = null;
  return _.createElement(_.Fragment, null, _.createElement("h2", null, "Unexpected Application Error!"), _.createElement("h3", {
      style: {
          fontStyle: "italic"
      }
  }, t), n ? _.createElement("pre", {
      style: i
  }, n) : null, s)
}
const KR = _.createElement(VR, null);
class GR extends _.Component {
  constructor(t) {
      super(t),
      this.state = {
          location: t.location,
          revalidation: t.revalidation,
          error: t.error
      }
  }
  static getDerivedStateFromError(t) {
      return {
          error: t
      }
  }
  static getDerivedStateFromProps(t, n) {
      return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? {
          error: t.error,
          location: t.location,
          revalidation: t.revalidation
      } : {
          error: t.error !== void 0 ? t.error : n.error,
          location: n.location,
          revalidation: t.revalidation || n.revalidation
      }
  }
  componentDidCatch(t, n) {
      console.error("React Router caught the following error during render", t, n)
  }
  render() {
      return this.state.error !== void 0 ? _.createElement(qr.Provider, {
          value: this.props.routeContext
      }, _.createElement(dS.Provider, {
          value: this.state.error,
          children: this.props.component
      })) : this.props.children
  }
}
function QR(e) {
  let {routeContext: t, match: n, children: r} = e
    , i = _.useContext(My);
  return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id),
  _.createElement(qr.Provider, {
      value: t
  }, r)
}
function YR(e, t, n, r) {
  var i;
  if (t === void 0 && (t = []),
  n === void 0 && (n = null),
  r === void 0 && (r = null),
  e == null) {
      var s;
      if ((s = n) != null && s.errors)
          e = n.matches;
      else
          return null
  }
  let a = e
    , o = (i = n) == null ? void 0 : i.errors;
  if (o != null) {
      let c = a.findIndex(f => f.route.id && (o == null ? void 0 : o[f.route.id]));
      c >= 0 || He(!1),
      a = a.slice(0, Math.min(a.length, c + 1))
  }
  let u = !1
    , l = -1;
  if (n && r && r.v7_partialHydration)
      for (let c = 0; c < a.length; c++) {
          let f = a[c];
          if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (l = c),
          f.route.id) {
              let {loaderData: d, errors: y} = n
                , m = f.route.loader && d[f.route.id] === void 0 && (!y || y[f.route.id] === void 0);
              if (f.route.lazy || m) {
                  u = !0,
                  l >= 0 ? a = a.slice(0, l + 1) : a = [a[0]];
                  break
              }
          }
      }
  return a.reduceRight( (c, f, d) => {
      let y, m = !1, v = null, b = null;
      n && (y = o && f.route.id ? o[f.route.id] : void 0,
      v = f.route.errorElement || KR,
      u && (l < 0 && d === 0 ? (nN("route-fallback", !1),
      m = !0,
      b = null) : l === d && (m = !0,
      b = f.route.hydrateFallbackElement || null)));
      let w = t.concat(a.slice(0, d + 1))
        , h = () => {
          let g;
          return y ? g = v : m ? g = b : f.route.Component ? g = _.createElement(f.route.Component, null) : f.route.element ? g = f.route.element : g = c,
          _.createElement(QR, {
              match: f,
              routeContext: {
                  outlet: c,
                  matches: w,
                  isDataRoute: n != null
              },
              children: g
          })
      }
      ;
      return n && (f.route.ErrorBoundary || f.route.errorElement || d === 0) ? _.createElement(GR, {
          location: n.location,
          revalidation: n.revalidation,
          component: v,
          error: y,
          children: h(),
          routeContext: {
              outlet: null,
              matches: w,
              isDataRoute: !0
          }
      }) : h()
  }
  , null)
}
var mS = function(e) {
  return e.UseBlocker = "useBlocker",
  e.UseRevalidator = "useRevalidator",
  e.UseNavigateStable = "useNavigate",
  e
}(mS || {})
, Bl = function(e) {
  return e.UseBlocker = "useBlocker",
  e.UseLoaderData = "useLoaderData",
  e.UseActionData = "useActionData",
  e.UseRouteError = "useRouteError",
  e.UseNavigation = "useNavigation",
  e.UseRouteLoaderData = "useRouteLoaderData",
  e.UseMatches = "useMatches",
  e.UseRevalidator = "useRevalidator",
  e.UseNavigateStable = "useNavigate",
  e.UseRouteId = "useRouteId",
  e
}(Bl || {});
function XR(e) {
  let t = _.useContext(My);
  return t || He(!1),
  t
}
function JR(e) {
  let t = _.useContext(FR);
  return t || He(!1),
  t
}
function ZR(e) {
  let t = _.useContext(qr);
  return t || He(!1),
  t
}
function yS(e) {
  let t = ZR()
    , n = t.matches[t.matches.length - 1];
  return n.route.id || He(!1),
  n.route.id
}
function eN() {
  var e;
  let t = _.useContext(dS)
    , n = JR(Bl.UseRouteError)
    , r = yS(Bl.UseRouteError);
  return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r]
}
function tN() {
  let {router: e} = XR(mS.UseNavigateStable)
    , t = yS(Bl.UseNavigateStable)
    , n = _.useRef(!1);
  return pS( () => {
      n.current = !0
  }
  ),
  _.useCallback(function(i, s) {
      s === void 0 && (s = {}),
      n.current && (typeof i == "number" ? e.navigate(i) : e.navigate(i, no({
          fromRouteId: t
      }, s)))
  }, [e, t])
}
const s1 = {};
function nN(e, t, n) {
  !t && !s1[e] && (s1[e] = !0)
}
function gS(e) {
  return WR(e.context)
}
function _t(e) {
  He(!1)
}
function rN(e) {
  let {basename: t="/", children: n=null, location: r, navigationType: i=yr.Pop, navigator: s, static: a=!1, future: o} = e;
  Do() && He(!1);
  let u = t.replace(/^\/*/, "/")
    , l = _.useMemo( () => ({
      basename: u,
      navigator: s,
      static: a,
      future: no({
          v7_relativeSplatPath: !1
      }, o)
  }), [u, o, s, a]);
  typeof r == "string" && (r = Ds(r));
  let {pathname: c="/", search: f="", hash: d="", state: y=null, key: m="default"} = r
    , v = _.useMemo( () => {
      let b = jy(c, u);
      return b == null ? null : {
          location: {
              pathname: b,
              search: f,
              hash: d,
              state: y,
              key: m
          },
          navigationType: i
      }
  }
  , [u, c, f, d, y, m, i]);
  return v == null ? null : _.createElement(Ei.Provider, {
      value: l
  }, _.createElement(uf.Provider, {
      children: n,
      value: v
  }))
}
function vS(e) {
  let {children: t, location: n} = e;
  return HR(bh(t), n)
}
new Promise( () => {}
);
function bh(e, t) {
  t === void 0 && (t = []);
  let n = [];
  return _.Children.forEach(e, (r, i) => {
      if (!_.isValidElement(r))
          return;
      let s = [...t, i];
      if (r.type === _.Fragment) {
          n.push.apply(n, bh(r.props.children, s));
          return
      }
      r.type !== _t && He(!1),
      !r.props.index || !r.props.children || He(!1);
      let a = {
          id: r.props.id || s.join("-"),
          caseSensitive: r.props.caseSensitive,
          element: r.props.element,
          Component: r.props.Component,
          index: r.props.index,
          path: r.props.path,
          loader: r.props.loader,
          action: r.props.action,
          errorElement: r.props.errorElement,
          ErrorBoundary: r.props.ErrorBoundary,
          hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null,
          shouldRevalidate: r.props.shouldRevalidate,
          handle: r.props.handle,
          lazy: r.props.lazy
      };
      r.props.children && (a.children = bh(r.props.children, s)),
      n.push(a)
  }
  ),
  n
}
/**
* React Router DOM v6.21.1
*
* Copyright (c) Remix Software Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE.md file in the root directory of this source tree.
*
* @license MIT
*/
function xh() {
  return xh = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
      }
      return e
  }
  ,
  xh.apply(this, arguments)
}
function iN(e, t) {
  if (e == null)
      return {};
  var n = {}, r = Object.keys(e), i, s;
  for (s = 0; s < r.length; s++)
      i = r[s],
      !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n
}
function sN(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
}
function aN(e, t) {
  return e.button === 0 && (!t || t === "_self") && !sN(e)
}
const oN = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"]
, uN = "startTransition"
, a1 = P6[uN];
function lN(e) {
  let {basename: t, children: n, future: r, window: i} = e
    , s = _.useRef();
  s.current == null && (s.current = pR({
      window: i,
      v5Compat: !0
  }));
  let a = s.current
    , [o,u] = _.useState({
      action: a.action,
      location: a.location
  })
    , {v7_startTransition: l} = r || {}
    , c = _.useCallback(f => {
      l && a1 ? a1( () => u(f)) : u(f)
  }
  , [u, l]);
  return _.useLayoutEffect( () => a.listen(c), [a, c]),
  _.createElement(rN, {
      basename: t,
      children: n,
      location: o.location,
      navigationType: o.action,
      navigator: a,
      future: r
  })
}
const cN = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
, fN = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
, Si = _.forwardRef(function(t, n) {
  let {onClick: r, relative: i, reloadDocument: s, replace: a, state: o, target: u, to: l, preventScrollReset: c, unstable_viewTransition: f} = t, d = iN(t, oN), {basename: y} = _.useContext(Ei), m, v = !1;
  if (typeof l == "string" && fN.test(l) && (m = l,
  cN))
      try {
          let g = new URL(window.location.href)
            , x = l.startsWith("//") ? new URL(g.protocol + l) : new URL(l)
            , S = jy(x.pathname, y);
          x.origin === g.origin && S != null ? l = S + x.search + x.hash : v = !0
      } catch {}
  let b = UR(l, {
      relative: i
  })
    , w = dN(l, {
      replace: a,
      state: o,
      target: u,
      preventScrollReset: c,
      relative: i,
      unstable_viewTransition: f
  });
  function h(g) {
      r && r(g),
      g.defaultPrevented || w(g)
  }
  return _.createElement("a", xh({}, d, {
      href: m || b,
      onClick: v || s ? r : h,
      ref: n,
      target: u
  }))
});
var o1;
(function(e) {
  e.UseScrollRestoration = "useScrollRestoration",
  e.UseSubmit = "useSubmit",
  e.UseSubmitFetcher = "useSubmitFetcher",
  e.UseFetcher = "useFetcher",
  e.useViewTransitionState = "useViewTransitionState"
}
)(o1 || (o1 = {}));
var u1;
(function(e) {
  e.UseFetcher = "useFetcher",
  e.UseFetchers = "useFetchers",
  e.UseScrollRestoration = "useScrollRestoration"
}
)(u1 || (u1 = {}));
function dN(e, t) {
  let {target: n, replace: r, state: i, preventScrollReset: s, relative: a, unstable_viewTransition: o} = t === void 0 ? {} : t
    , u = Is()
    , l = vn()
    , c = hS(e, {
      relative: a
  });
  return _.useCallback(f => {
      if (aN(f, n)) {
          f.preventDefault();
          let d = r !== void 0 ? r : zl(l) === zl(c);
          u(e, {
              replace: d,
              state: i,
              preventScrollReset: s,
              relative: a,
              unstable_viewTransition: o
          })
      }
  }
  , [l, u, c, r, i, n, e, s, a, o])
}
function pN() {
  const {pathname: e} = vn();
  return _.useEffect( () => {
      window.scrollTo(0, 0)
  }
  , [e]),
  null
}
const hN = _.createContext(null)
, mN = typeof document < "u"
, wS = mN ? _.useLayoutEffect : _.useEffect
, yN = _.createContext({});
function gN(e) {
  const t = _.useRef(null);
  return t.current === null && (t.current = e()),
  t.current
}
const vN = e => e;
class l1 {
  constructor() {
      this.order = [],
      this.scheduled = new Set
  }
  add(t) {
      if (!this.scheduled.has(t))
          return this.scheduled.add(t),
          this.order.push(t),
          !0
  }
  remove(t) {
      const n = this.order.indexOf(t);
      n !== -1 && (this.order.splice(n, 1),
      this.scheduled.delete(t))
  }
  clear() {
      this.order.length = 0,
      this.scheduled.clear()
  }
}
function wN(e) {
  let t = new l1
    , n = new l1
    , r = 0
    , i = !1
    , s = !1;
  const a = new WeakSet
    , o = {
      schedule: (u, l=!1, c=!1) => {
          const f = c && i
            , d = f ? t : n;
          return l && a.add(u),
          d.add(u) && f && i && (r = t.order.length),
          u
      }
      ,
      cancel: u => {
          n.remove(u),
          a.delete(u)
      }
      ,
      process: u => {
          if (i) {
              s = !0;
              return
          }
          if (i = !0,
          [t,n] = [n, t],
          n.clear(),
          r = t.order.length,
          r)
              for (let l = 0; l < r; l++) {
                  const c = t.order[l];
                  c(u),
                  a.has(c) && (o.schedule(c),
                  e())
              }
          i = !1,
          s && (s = !1,
          o.process(u))
      }
  };
  return o
}
const hu = ["prepare", "read", "update", "preRender", "render", "postRender"]
, bN = 40;
function xN(e, t) {
  let n = !1
    , r = !0;
  const i = {
      delta: 0,
      timestamp: 0,
      isProcessing: !1
  }
    , s = hu.reduce( (f, d) => (f[d] = wN( () => n = !0),
  f), {})
    , a = f => s[f].process(i)
    , o = () => {
      const f = performance.now();
      n = !1,
      i.delta = r ? 1e3 / 60 : Math.max(Math.min(f - i.timestamp, bN), 1),
      i.timestamp = f,
      i.isProcessing = !0,
      hu.forEach(a),
      i.isProcessing = !1,
      n && t && (r = !1,
      e(o))
  }
    , u = () => {
      n = !0,
      r = !0,
      i.isProcessing || e(o)
  }
  ;
  return {
      schedule: hu.reduce( (f, d) => {
          const y = s[d];
          return f[d] = (m, v=!1, b=!1) => (n || u(),
          y.schedule(m, v, b)),
          f
      }
      , {}),
      cancel: f => hu.forEach(d => s[d].cancel(f)),
      state: i,
      steps: s
  }
}
const {schedule: EN, cancel: n7, state: r7, steps: i7} = xN(typeof requestAnimationFrame < "u" ? requestAnimationFrame : vN, !0);
function bS() {
  const e = _.useRef(!1);
  return wS( () => (e.current = !0,
  () => {
      e.current = !1
  }
  ), []),
  e
}
function SN() {
  const e = bS()
    , [t,n] = _.useState(0)
    , r = _.useCallback( () => {
      e.current && n(t + 1)
  }
  , [t]);
  return [_.useCallback( () => EN.postRender(r), [r]), t]
}
class CN extends _.Component {
  getSnapshotBeforeUpdate(t) {
      const n = this.props.childRef.current;
      if (n && t.isPresent && !this.props.isPresent) {
          const r = this.props.sizeRef.current;
          r.height = n.offsetHeight || 0,
          r.width = n.offsetWidth || 0,
          r.top = n.offsetTop,
          r.left = n.offsetLeft
      }
      return null
  }
  componentDidUpdate() {}
  render() {
      return this.props.children
  }
}
function _N({children: e, isPresent: t}) {
  const n = _.useId()
    , r = _.useRef(null)
    , i = _.useRef({
      width: 0,
      height: 0,
      top: 0,
      left: 0
  });
  return _.useInsertionEffect( () => {
      const {width: s, height: a, top: o, left: u} = i.current;
      if (t || !r.current || !s || !a)
          return;
      r.current.dataset.motionPopId = n;
      const l = document.createElement("style");
      return document.head.appendChild(l),
      l.sheet && l.sheet.insertRule(`
        [data-motion-pop-id="${n}"] {
          position: absolute !important;
          width: ${s}px !important;
          height: ${a}px !important;
          top: ${o}px !important;
          left: ${u}px !important;
        }
      `),
      () => {
          document.head.removeChild(l)
      }
  }
  , [t]),
  _.createElement(CN, {
      isPresent: t,
      childRef: r,
      sizeRef: i
  }, _.cloneElement(e, {
      ref: r
  }))
}
const hd = ({children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: s, mode: a}) => {
  const o = gN(PN)
    , u = _.useId()
    , l = _.useMemo( () => ({
      id: u,
      initial: t,
      isPresent: n,
      custom: i,
      onExitComplete: c => {
          o.set(c, !0);
          for (const f of o.values())
              if (!f)
                  return;
          r && r()
      }
      ,
      register: c => (o.set(c, !1),
      () => o.delete(c))
  }), s ? void 0 : [n]);
  return _.useMemo( () => {
      o.forEach( (c, f) => o.set(f, !1))
  }
  , [n]),
  _.useEffect( () => {
      !n && !o.size && r && r()
  }
  , [n]),
  a === "popLayout" && (e = _.createElement(_N, {
      isPresent: n
  }, e)),
  _.createElement(hN.Provider, {
      value: l
  }, e)
}
;
function PN() {
  return new Map
}
function TN(e) {
  return _.useEffect( () => () => e(), [])
}
const Zr = e => e.key || "";
function ON(e, t) {
  e.forEach(n => {
      const r = Zr(n);
      t.set(r, n)
  }
  )
}
function kN(e) {
  const t = [];
  return _.Children.forEach(e, n => {
      _.isValidElement(n) && t.push(n)
  }
  ),
  t
}
const DN = ({children: e, custom: t, initial: n=!0, onExitComplete: r, exitBeforeEnter: i, presenceAffectsLayout: s=!0, mode: a="sync"}) => {
  const o = _.useContext(yN).forceRender || SN()[0]
    , u = bS()
    , l = kN(e);
  let c = l;
  const f = _.useRef(new Map).current
    , d = _.useRef(c)
    , y = _.useRef(new Map).current
    , m = _.useRef(!0);
  if (wS( () => {
      m.current = !1,
      ON(l, y),
      d.current = c
  }
  ),
  TN( () => {
      m.current = !0,
      y.clear(),
      f.clear()
  }
  ),
  m.current)
      return _.createElement(_.Fragment, null, c.map(h => _.createElement(hd, {
          key: Zr(h),
          isPresent: !0,
          initial: n ? void 0 : !1,
          presenceAffectsLayout: s,
          mode: a
      }, h)));
  c = [...c];
  const v = d.current.map(Zr)
    , b = l.map(Zr)
    , w = v.length;
  for (let h = 0; h < w; h++) {
      const g = v[h];
      b.indexOf(g) === -1 && !f.has(g) && f.set(g, void 0)
  }
  return a === "wait" && f.size && (c = []),
  f.forEach( (h, g) => {
      if (b.indexOf(g) !== -1)
          return;
      const x = y.get(g);
      if (!x)
          return;
      const S = v.indexOf(g);
      let E = h;
      if (!E) {
          const p = () => {
              f.delete(g);
              const C = Array.from(y.keys()).filter(T => !b.includes(T));
              if (C.forEach(T => y.delete(T)),
              d.current = l.filter(T => {
                  const O = Zr(T);
                  return O === g || C.includes(O)
              }
              ),
              !f.size) {
                  if (u.current === !1)
                      return;
                  o(),
                  r && r()
              }
          }
          ;
          E = _.createElement(hd, {
              key: Zr(x),
              isPresent: !1,
              onExitComplete: p,
              custom: t,
              presenceAffectsLayout: s,
              mode: a
          }, x),
          f.set(g, E)
      }
      c.splice(S, 0, E)
  }
  ),
  c = c.map(h => {
      const g = h.key;
      return f.has(g) ? h : _.createElement(hd, {
          key: Zr(h),
          isPresent: !0,
          presenceAffectsLayout: s,
          mode: a
      }, h)
  }
  ),
  _.createElement(_.Fragment, null, f.size ? c : c.map(h => _.cloneElement(h)))
}
;
var $e = {}
, Ly = {}
, Io = {}
, Ao = {}
, xS = "Expected a function"
, c1 = NaN
, IN = "[object Symbol]"
, AN = /^\s+|\s+$/g
, $N = /^[-+]0x[0-9a-f]+$/i
, RN = /^0b[01]+$/i
, NN = /^0o[0-7]+$/i
, jN = parseInt
, MN = typeof Mn == "object" && Mn && Mn.Object === Object && Mn
, LN = typeof self == "object" && self && self.Object === Object && self
, FN = MN || LN || Function("return this")()
, UN = Object.prototype
, zN = UN.toString
, BN = Math.max
, WN = Math.min
, md = function() {
  return FN.Date.now()
};
function HN(e, t, n) {
  var r, i, s, a, o, u, l = 0, c = !1, f = !1, d = !0;
  if (typeof e != "function")
      throw new TypeError(xS);
  t = f1(t) || 0,
  Wl(n) && (c = !!n.leading,
  f = "maxWait"in n,
  s = f ? BN(f1(n.maxWait) || 0, t) : s,
  d = "trailing"in n ? !!n.trailing : d);
  function y(E) {
      var p = r
        , C = i;
      return r = i = void 0,
      l = E,
      a = e.apply(C, p),
      a
  }
  function m(E) {
      return l = E,
      o = setTimeout(w, t),
      c ? y(E) : a
  }
  function v(E) {
      var p = E - u
        , C = E - l
        , T = t - p;
      return f ? WN(T, s - C) : T
  }
  function b(E) {
      var p = E - u
        , C = E - l;
      return u === void 0 || p >= t || p < 0 || f && C >= s
  }
  function w() {
      var E = md();
      if (b(E))
          return h(E);
      o = setTimeout(w, v(E))
  }
  function h(E) {
      return o = void 0,
      d && r ? y(E) : (r = i = void 0,
      a)
  }
  function g() {
      o !== void 0 && clearTimeout(o),
      l = 0,
      r = u = i = o = void 0
  }
  function x() {
      return o === void 0 ? a : h(md())
  }
  function S() {
      var E = md()
        , p = b(E);
      if (r = arguments,
      i = this,
      u = E,
      p) {
          if (o === void 0)
              return m(u);
          if (f)
              return o = setTimeout(w, t),
              y(u)
      }
      return o === void 0 && (o = setTimeout(w, t)),
      a
  }
  return S.cancel = g,
  S.flush = x,
  S
}
function qN(e, t, n) {
  var r = !0
    , i = !0;
  if (typeof e != "function")
      throw new TypeError(xS);
  return Wl(n) && (r = "leading"in n ? !!n.leading : r,
  i = "trailing"in n ? !!n.trailing : i),
  HN(e, t, {
      leading: r,
      maxWait: t,
      trailing: i
  })
}
function Wl(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function")
}
function VN(e) {
  return !!e && typeof e == "object"
}
function KN(e) {
  return typeof e == "symbol" || VN(e) && zN.call(e) == IN
}
function f1(e) {
  if (typeof e == "number")
      return e;
  if (KN(e))
      return c1;
  if (Wl(e)) {
      var t = typeof e.valueOf == "function" ? e.valueOf() : e;
      e = Wl(t) ? t + "" : t
  }
  if (typeof e != "string")
      return e === 0 ? e : +e;
  e = e.replace(AN, "");
  var n = RN.test(e);
  return n || NN.test(e) ? jN(e.slice(2), n ? 2 : 8) : $N.test(e) ? c1 : +e
}
var GN = qN
, $o = {};
Object.defineProperty($o, "__esModule", {
  value: !0
});
$o.addPassiveEventListener = function(t, n, r) {
  var i = r.name;
  i || (i = n,
  console.warn("Listener must be a named function.")),
  qu.has(n) || qu.set(n, new Set);
  var s = qu.get(n);
  if (!s.has(i)) {
      var a = function() {
          var o = !1;
          try {
              var u = Object.defineProperty({}, "passive", {
                  get: function() {
                      o = !0
                  }
              });
              window.addEventListener("test", null, u)
          } catch {}
          return o
      }();
      t.addEventListener(n, r, a ? {
          passive: !0
      } : !1),
      s.add(i)
  }
}
;
$o.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r),
  qu.get(n).delete(r.name || n)
}
;
var qu = new Map;
Object.defineProperty(Ao, "__esModule", {
  value: !0
});
var QN = GN
, YN = JN(QN)
, XN = $o;
function JN(e) {
  return e && e.__esModule ? e : {
      default: e
  }
}
var ZN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0,
  YN.default)(t, n)
}
, Se = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
      if (t) {
          var r = ZN(function(i) {
              Se.scrollHandler(t)
          }, n);
          Se.scrollSpyContainers.push(t),
          (0,
          XN.addPassiveEventListener)(t, "scroll", r)
      }
  },
  isMounted: function(t) {
      return Se.scrollSpyContainers.indexOf(t) !== -1
  },
  currentPositionX: function(t) {
      if (t === document) {
          var n = window.pageYOffset !== void 0
            , r = (document.compatMode || "") === "CSS1Compat";
          return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft
      } else
          return t.scrollLeft
  },
  currentPositionY: function(t) {
      if (t === document) {
          var n = window.pageXOffset !== void 0
            , r = (document.compatMode || "") === "CSS1Compat";
          return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop
      } else
          return t.scrollTop
  },
  scrollHandler: function(t) {
      var n = Se.scrollSpyContainers[Se.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
      n.forEach(function(r) {
          return r(Se.currentPositionX(t), Se.currentPositionY(t))
      })
  },
  addStateHandler: function(t) {
      Se.spySetState.push(t)
  },
  addSpyHandler: function(t, n) {
      var r = Se.scrollSpyContainers[Se.scrollSpyContainers.indexOf(n)];
      r.spyCallbacks || (r.spyCallbacks = []),
      r.spyCallbacks.push(t),
      t(Se.currentPositionX(n), Se.currentPositionY(n))
  },
  updateStates: function() {
      Se.spySetState.forEach(function(t) {
          return t()
      })
  },
  unmount: function(t, n) {
      Se.scrollSpyContainers.forEach(function(r) {
          return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1)
      }),
      Se.spySetState && Se.spySetState.length && Se.spySetState.indexOf(t) > -1 && Se.spySetState.splice(Se.spySetState.indexOf(t), 1),
      document.removeEventListener("scroll", Se.scrollHandler)
  },
  update: function() {
      return Se.scrollSpyContainers.forEach(function(t) {
          return Se.scrollHandler(t)
      })
  }
};
Ao.default = Se;
var As = {}
, Ro = {};
Object.defineProperty(Ro, "__esModule", {
  value: !0
});
var ej = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t
    , i = r ? "#" + r : ""
    , s = window && window.location
    , a = i ? s.pathname + s.search + i : s.pathname + s.search;
  n ? history.pushState(history.state, "", a) : history.replaceState(history.state, "", a)
}
, tj = function() {
  return window.location.hash.replace(/^#/, "")
}
, nj = function(t) {
  return function(n) {
      return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16)
  }
}
, rj = function(t) {
  return getComputedStyle(t).position !== "static"
}
, yd = function(t, n) {
  for (var r = t.offsetTop, i = t.offsetParent; i && !n(i); )
      r += i.offsetTop,
      i = i.offsetParent;
  return {
      offsetTop: r,
      offsetParent: i
  }
}
, ij = function(t, n, r) {
  if (r)
      return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
      return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (rj(t)) {
      if (n.offsetParent !== t) {
          var i = function(c) {
              return c === t || c === document
          }
            , s = yd(n, i)
            , a = s.offsetTop
            , o = s.offsetParent;
          if (o !== t)
              throw new Error("Seems containerElement is not an ancestor of the Element");
          return a
      }
      return n.offsetTop
  }
  if (n.offsetParent === t.offsetParent)
      return n.offsetTop - t.offsetTop;
  var u = function(c) {
      return c === document
  };
  return yd(n, u).offsetTop - yd(t, u).offsetTop
};
Ro.default = {
  updateHash: ej,
  getHash: tj,
  filterElementInContainer: nj,
  scrollOffset: ij
};
var lf = {}
, Fy = {};
Object.defineProperty(Fy, "__esModule", {
  value: !0
});
Fy.default = {
  defaultEasing: function(t) {
      return t < .5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2
  },
  linear: function(t) {
      return t
  },
  easeInQuad: function(t) {
      return t * t
  },
  easeOutQuad: function(t) {
      return t * (2 - t)
  },
  easeInOutQuad: function(t) {
      return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t
  },
  easeInCubic: function(t) {
      return t * t * t
  },
  easeOutCubic: function(t) {
      return --t * t * t + 1
  },
  easeInOutCubic: function(t) {
      return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
  },
  easeInQuart: function(t) {
      return t * t * t * t
  },
  easeOutQuart: function(t) {
      return 1 - --t * t * t * t
  },
  easeInOutQuart: function(t) {
      return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
  },
  easeInQuint: function(t) {
      return t * t * t * t * t
  },
  easeOutQuint: function(t) {
      return 1 + --t * t * t * t * t
  },
  easeInOutQuint: function(t) {
      return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t
  }
};
var Uy = {};
Object.defineProperty(Uy, "__esModule", {
  value: !0
});
var sj = $o
, aj = ["mousedown", "mousewheel", "touchmove", "keydown"];
Uy.default = {
  subscribe: function(t) {
      return typeof document < "u" && aj.forEach(function(n) {
          return (0,
          sj.addPassiveEventListener)(document, n, t)
      })
  }
};
var No = {};
Object.defineProperty(No, "__esModule", {
  value: !0
});
var Eh = {
  registered: {},
  scrollEvent: {
      register: function(t, n) {
          Eh.registered[t] = n
      },
      remove: function(t) {
          Eh.registered[t] = null
      }
  }
};
No.default = Eh;
Object.defineProperty(lf, "__esModule", {
  value: !0
});
var oj = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
          Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
  }
  return e
}
, uj = Ro;
cf(uj);
var lj = Fy
, d1 = cf(lj)
, cj = Uy
, fj = cf(cj)
, dj = No
, En = cf(dj);
function cf(e) {
  return e && e.__esModule ? e : {
      default: e
  }
}
var ES = function(t) {
  return d1.default[t.smooth] || d1.default.defaultEasing
}
, pj = function(t) {
  return typeof t == "function" ? t : function() {
      return t
  }
}
, hj = function() {
  if (typeof window < "u")
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame
}
, Sh = function() {
  return hj() || function(e, t, n) {
      window.setTimeout(e, n || 1e3 / 60, new Date().getTime())
  }
}()
, SS = function() {
  return {
      currentPosition: 0,
      startPosition: 0,
      targetPosition: 0,
      progress: 0,
      duration: 0,
      cancel: !1,
      target: null,
      containerElement: null,
      to: null,
      start: null,
      delta: null,
      percent: null,
      delayTimeout: null
  }
}
, CS = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
      return n.scrollLeft;
  var r = window.pageXOffset !== void 0
    , i = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : i ? document.documentElement.scrollLeft : document.body.scrollLeft
}
, _S = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
      return n.scrollTop;
  var r = window.pageXOffset !== void 0
    , i = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : i ? document.documentElement.scrollTop : document.body.scrollTop
}
, mj = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
      return n.scrollWidth - n.offsetWidth;
  var r = document.body
    , i = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, i.clientWidth, i.scrollWidth, i.offsetWidth)
}
, yj = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
      return n.scrollHeight - n.offsetHeight;
  var r = document.body
    , i = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, i.clientHeight, i.scrollHeight, i.offsetHeight)
}
, gj = function e(t, n, r) {
  var i = n.data;
  if (!n.ignoreCancelEvents && i.cancel) {
      En.default.registered.end && En.default.registered.end(i.to, i.target, i.currentPositionY);
      return
  }
  if (i.delta = Math.round(i.targetPosition - i.startPosition),
  i.start === null && (i.start = r),
  i.progress = r - i.start,
  i.percent = i.progress >= i.duration ? 1 : t(i.progress / i.duration),
  i.currentPosition = i.startPosition + Math.ceil(i.delta * i.percent),
  i.containerElement && i.containerElement !== document && i.containerElement !== document.body ? n.horizontal ? i.containerElement.scrollLeft = i.currentPosition : i.containerElement.scrollTop = i.currentPosition : n.horizontal ? window.scrollTo(i.currentPosition, 0) : window.scrollTo(0, i.currentPosition),
  i.percent < 1) {
      var s = e.bind(null, t, n);
      Sh.call(window, s);
      return
  }
  En.default.registered.end && En.default.registered.end(i.to, i.target, i.currentPosition)
}
, zy = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null
}
, jo = function(t, n, r, i) {
  n.data = n.data || SS(),
  window.clearTimeout(n.data.delayTimeout);
  var s = function() {
      n.data.cancel = !0
  };
  if (fj.default.subscribe(s),
  zy(n),
  n.data.start = null,
  n.data.cancel = !1,
  n.data.startPosition = n.horizontal ? CS(n) : _S(n),
  n.data.targetPosition = n.absolute ? t : t + n.data.startPosition,
  n.data.startPosition === n.data.targetPosition) {
      En.default.registered.end && En.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
      return
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition),
  n.data.duration = pj(n.duration)(n.data.delta),
  n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration),
  n.data.to = r,
  n.data.target = i;
  var a = ES(n)
    , o = gj.bind(null, a, n);
  if (n && n.delay > 0) {
      n.data.delayTimeout = window.setTimeout(function() {
          En.default.registered.begin && En.default.registered.begin(n.data.to, n.data.target),
          Sh.call(window, o)
      }, n.delay);
      return
  }
  En.default.registered.begin && En.default.registered.begin(n.data.to, n.data.target),
  Sh.call(window, o)
}
, ff = function(t) {
  return t = oj({}, t),
  t.data = t.data || SS(),
  t.absolute = !0,
  t
}
, vj = function(t) {
  jo(0, ff(t))
}
, wj = function(t, n) {
  jo(t, ff(n))
}
, bj = function(t) {
  t = ff(t),
  zy(t),
  jo(t.horizontal ? mj(t) : yj(t), t)
}
, xj = function(t, n) {
  n = ff(n),
  zy(n);
  var r = n.horizontal ? CS(n) : _S(n);
  jo(t + r, n)
};
lf.default = {
  animateTopScroll: jo,
  getAnimationType: ES,
  scrollToTop: vj,
  scrollToBottom: bj,
  scrollTo: wj,
  scrollMore: xj
};
Object.defineProperty(As, "__esModule", {
  value: !0
});
var Ej = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
          Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
  }
  return e
}
, Sj = Ro
, Cj = By(Sj)
, _j = lf
, Pj = By(_j)
, Tj = No
, mu = By(Tj);
function By(e) {
  return e && e.__esModule ? e : {
      default: e
  }
}
var yu = {}
, p1 = void 0;
As.default = {
  unmount: function() {
      yu = {}
  },
  register: function(t, n) {
      yu[t] = n
  },
  unregister: function(t) {
      delete yu[t]
  },
  get: function(t) {
      return yu[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0]
  },
  setActiveLink: function(t) {
      return p1 = t
  },
  getActiveLink: function() {
      return p1
  },
  scrollTo: function(t, n) {
      var r = this.get(t);
      if (!r) {
          console.warn("target Element not found");
          return
      }
      n = Ej({}, n, {
          absolute: !1
      });
      var i = n.containerId
        , s = n.container
        , a = void 0;
      i ? a = document.getElementById(i) : s && s.nodeType ? a = s : a = document,
      n.absolute = !0;
      var o = n.horizontal
        , u = Cj.default.scrollOffset(a, r, o) + (n.offset || 0);
      if (!n.smooth) {
          mu.default.registered.begin && mu.default.registered.begin(t, r),
          a === document ? n.horizontal ? window.scrollTo(u, 0) : window.scrollTo(0, u) : a.scrollTop = u,
          mu.default.registered.end && mu.default.registered.end(t, r);
          return
      }
      Pj.default.animateTopScroll(u, n, t, r)
  }
};
var df = {};
Object.defineProperty(df, "__esModule", {
  value: !0
});
var Oj = Ro
, gd = kj(Oj);
function kj(e) {
  return e && e.__esModule ? e : {
      default: e
  }
}
var Dj = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
      this.scroller = t,
      this.handleHashChange = this.handleHashChange.bind(this),
      window.addEventListener("hashchange", this.handleHashChange),
      this.initStateFromHash(),
      this.mountFlag = !0
  },
  mapContainer: function(t, n) {
      this.containers[t] = n
  },
  isMounted: function() {
      return this.mountFlag
  },
  isInitialized: function() {
      return this.initialized
  },
  initStateFromHash: function() {
      var t = this
        , n = this.getHash();
      n ? window.setTimeout(function() {
          t.scrollTo(n, !0),
          t.initialized = !0
      }, 10) : this.initialized = !0
  },
  scrollTo: function(t, n) {
      var r = this.scroller
        , i = r.get(t);
      if (i && (n || t !== r.getActiveLink())) {
          var s = this.containers[t] || document;
          r.scrollTo(t, {
              container: s
          })
      }
  },
  getHash: function() {
      return gd.default.getHash()
  },
  changeHash: function(t, n) {
      this.isInitialized() && gd.default.getHash() !== t && gd.default.updateHash(t, n)
  },
  handleHashChange: function() {
      this.scrollTo(this.getHash())
  },
  unmount: function() {
      this.scroller = null,
      this.containers = null,
      window.removeEventListener("hashchange", this.handleHashChange)
  }
};
df.default = Dj;
Object.defineProperty(Io, "__esModule", {
  value: !0
});
var gu = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
          Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
  }
  return e
}
, Ij = function() {
  function e(t, n) {
      for (var r = 0; r < n.length; r++) {
          var i = n[r];
          i.enumerable = i.enumerable || !1,
          i.configurable = !0,
          "value"in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i)
      }
  }
  return function(t, n, r) {
      return n && e(t.prototype, n),
      r && e(t, r),
      t
  }
}()
, Aj = _
, h1 = Mo(Aj)
, $j = Ao
, vu = Mo($j)
, Rj = As
, Nj = Mo(Rj)
, jj = Oo
, xe = Mo(jj)
, Mj = df
, ir = Mo(Mj);
function Mo(e) {
  return e && e.__esModule ? e : {
      default: e
  }
}
function Lj(e, t) {
  if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function")
}
function Fj(e, t) {
  if (!e)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e
}
function Uj(e, t) {
  if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, {
      constructor: {
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0
      }
  }),
  t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
}
var m1 = {
  to: xe.default.string.isRequired,
  containerId: xe.default.string,
  container: xe.default.object,
  activeClass: xe.default.string,
  activeStyle: xe.default.object,
  spy: xe.default.bool,
  horizontal: xe.default.bool,
  smooth: xe.default.oneOfType([xe.default.bool, xe.default.string]),
  offset: xe.default.number,
  delay: xe.default.number,
  isDynamic: xe.default.bool,
  onClick: xe.default.func,
  duration: xe.default.oneOfType([xe.default.number, xe.default.func]),
  absolute: xe.default.bool,
  onSetActive: xe.default.func,
  onSetInactive: xe.default.func,
  ignoreCancelEvents: xe.default.bool,
  hashSpy: xe.default.bool,
  saveHashHistory: xe.default.bool,
  spyThrottle: xe.default.number
};
Io.default = function(e, t) {
  var n = t || Nj.default
    , r = function(s) {
      Uj(a, s);
      function a(o) {
          Lj(this, a);
          var u = Fj(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, o));
          return i.call(u),
          u.state = {
              active: !1
          },
          u
      }
      return Ij(a, [{
          key: "getScrollSpyContainer",
          value: function() {
              var u = this.props.containerId
                , l = this.props.container;
              return u && !l ? document.getElementById(u) : l && l.nodeType ? l : document
          }
      }, {
          key: "componentDidMount",
          value: function() {
              if (this.props.spy || this.props.hashSpy) {
                  var u = this.getScrollSpyContainer();
                  vu.default.isMounted(u) || vu.default.mount(u, this.props.spyThrottle),
                  this.props.hashSpy && (ir.default.isMounted() || ir.default.mount(n),
                  ir.default.mapContainer(this.props.to, u)),
                  vu.default.addSpyHandler(this.spyHandler, u),
                  this.setState({
                      container: u
                  })
              }
          }
      }, {
          key: "componentWillUnmount",
          value: function() {
              vu.default.unmount(this.stateHandler, this.spyHandler)
          }
      }, {
          key: "render",
          value: function() {
              var u = "";
              this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
              var l = {};
              this.state && this.state.active ? l = gu({}, this.props.style, this.props.activeStyle) : l = gu({}, this.props.style);
              var c = gu({}, this.props);
              for (var f in m1)
                  c.hasOwnProperty(f) && delete c[f];
              return c.className = u,
              c.style = l,
              c.onClick = this.handleClick,
              h1.default.createElement(e, c)
          }
      }]),
      a
  }(h1.default.PureComponent)
    , i = function() {
      var a = this;
      this.scrollTo = function(o, u) {
          n.scrollTo(o, gu({}, a.state, u))
      }
      ,
      this.handleClick = function(o) {
          a.props.onClick && a.props.onClick(o),
          o.stopPropagation && o.stopPropagation(),
          o.preventDefault && o.preventDefault(),
          a.scrollTo(a.props.to, a.props)
      }
      ,
      this.spyHandler = function(o, u) {
          var l = a.getScrollSpyContainer();
          if (!(ir.default.isMounted() && !ir.default.isInitialized())) {
              var c = a.props.horizontal
                , f = a.props.to
                , d = null
                , y = void 0
                , m = void 0;
              if (c) {
                  var v = 0
                    , b = 0
                    , w = 0;
                  if (l.getBoundingClientRect) {
                      var h = l.getBoundingClientRect();
                      w = h.left
                  }
                  if (!d || a.props.isDynamic) {
                      if (d = n.get(f),
                      !d)
                          return;
                      var g = d.getBoundingClientRect();
                      v = g.left - w + o,
                      b = v + g.width
                  }
                  var x = o - a.props.offset;
                  y = x >= Math.floor(v) && x < Math.floor(b),
                  m = x < Math.floor(v) || x >= Math.floor(b)
              } else {
                  var S = 0
                    , E = 0
                    , p = 0;
                  if (l.getBoundingClientRect) {
                      var C = l.getBoundingClientRect();
                      p = C.top
                  }
                  if (!d || a.props.isDynamic) {
                      if (d = n.get(f),
                      !d)
                          return;
                      var T = d.getBoundingClientRect();
                      S = T.top - p + u,
                      E = S + T.height
                  }
                  var O = u - a.props.offset;
                  y = O >= Math.floor(S) && O < Math.floor(E),
                  m = O < Math.floor(S) || O >= Math.floor(E)
              }
              var R = n.getActiveLink();
              if (m) {
                  if (f === R && n.setActiveLink(void 0),
                  a.props.hashSpy && ir.default.getHash() === f) {
                      var j = a.props.saveHashHistory
                        , L = j === void 0 ? !1 : j;
                      ir.default.changeHash("", L)
                  }
                  a.props.spy && a.state.active && (a.setState({
                      active: !1
                  }),
                  a.props.onSetInactive && a.props.onSetInactive(f, d))
              }
              if (y && (R !== f || a.state.active === !1)) {
                  n.setActiveLink(f);
                  var M = a.props.saveHashHistory
                    , P = M === void 0 ? !1 : M;
                  a.props.hashSpy && ir.default.changeHash(f, P),
                  a.props.spy && (a.setState({
                      active: !0
                  }),
                  a.props.onSetActive && a.props.onSetActive(f, d))
              }
          }
      }
  };
  return r.propTypes = m1,
  r.defaultProps = {
      offset: 0
  },
  r
}
;
Object.defineProperty(Ly, "__esModule", {
  value: !0
});
var zj = _
, y1 = PS(zj)
, Bj = Io
, Wj = PS(Bj);
function PS(e) {
  return e && e.__esModule ? e : {
      default: e
  }
}
function Hj(e, t) {
  if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function")
}
function g1(e, t) {
  if (!e)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e
}
function qj(e, t) {
  if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, {
      constructor: {
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0
      }
  }),
  t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
}
var Vj = function(e) {
  qj(t, e);
  function t() {
      var n, r, i, s;
      Hj(this, t);
      for (var a = arguments.length, o = Array(a), u = 0; u < a; u++)
          o[u] = arguments[u];
      return s = (r = (i = g1(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(o))),
      i),
      i.render = function() {
          return y1.default.createElement("a", i.props, i.props.children)
      }
      ,
      r),
      g1(i, s)
  }
  return t
}(y1.default.Component);
Ly.default = (0,
Wj.default)(Vj);
var Wy = {};
Object.defineProperty(Wy, "__esModule", {
  value: !0
});
var Kj = function() {
  function e(t, n) {
      for (var r = 0; r < n.length; r++) {
          var i = n[r];
          i.enumerable = i.enumerable || !1,
          i.configurable = !0,
          "value"in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i)
      }
  }
  return function(t, n, r) {
      return n && e(t.prototype, n),
      r && e(t, r),
      t
  }
}()
, Gj = _
, v1 = TS(Gj)
, Qj = Io
, Yj = TS(Qj);
function TS(e) {
  return e && e.__esModule ? e : {
      default: e
  }
}
function Xj(e, t) {
  if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function")
}
function Jj(e, t) {
  if (!e)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e
}
function Zj(e, t) {
  if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, {
      constructor: {
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0
      }
  }),
  t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
}
var eM = function(e) {
  Zj(t, e);
  function t() {
      return Xj(this, t),
      Jj(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments))
  }
  return Kj(t, [{
      key: "render",
      value: function() {
          return v1.default.createElement("button", this.props, this.props.children)
      }
  }]),
  t
}(v1.default.Component);
Wy.default = (0,
Yj.default)(eM);
var Hy = {}
, pf = {};
Object.defineProperty(pf, "__esModule", {
  value: !0
});
var tM = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
          Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
  }
  return e
}
, nM = function() {
  function e(t, n) {
      for (var r = 0; r < n.length; r++) {
          var i = n[r];
          i.enumerable = i.enumerable || !1,
          i.configurable = !0,
          "value"in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i)
      }
  }
  return function(t, n, r) {
      return n && e(t.prototype, n),
      r && e(t, r),
      t
  }
}()
, rM = _
, w1 = hf(rM)
, iM = Cm;
hf(iM);
var sM = As
, b1 = hf(sM)
, aM = Oo
, x1 = hf(aM);
function hf(e) {
  return e && e.__esModule ? e : {
      default: e
  }
}
function oM(e, t) {
  if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function")
}
function uM(e, t) {
  if (!e)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e
}
function lM(e, t) {
  if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, {
      constructor: {
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0
      }
  }),
  t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
}
pf.default = function(e) {
  var t = function(n) {
      lM(r, n);
      function r(i) {
          oM(this, r);
          var s = uM(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, i));
          return s.childBindings = {
              domNode: null
          },
          s
      }
      return nM(r, [{
          key: "componentDidMount",
          value: function() {
              if (typeof window > "u")
                  return !1;
              this.registerElems(this.props.name)
          }
      }, {
          key: "componentDidUpdate",
          value: function(s) {
              this.props.name !== s.name && this.registerElems(this.props.name)
          }
      }, {
          key: "componentWillUnmount",
          value: function() {
              if (typeof window > "u")
                  return !1;
              b1.default.unregister(this.props.name)
          }
      }, {
          key: "registerElems",
          value: function(s) {
              b1.default.register(s, this.childBindings.domNode)
          }
      }, {
          key: "render",
          value: function() {
              return w1.default.createElement(e, tM({}, this.props, {
                  parentBindings: this.childBindings
              }))
          }
      }]),
      r
  }(w1.default.Component);
  return t.propTypes = {
      name: x1.default.string,
      id: x1.default.string
  },
  t
}
;
Object.defineProperty(Hy, "__esModule", {
  value: !0
});
var E1 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
          Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
  }
  return e
}
, cM = function() {
  function e(t, n) {
      for (var r = 0; r < n.length; r++) {
          var i = n[r];
          i.enumerable = i.enumerable || !1,
          i.configurable = !0,
          "value"in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i)
      }
  }
  return function(t, n, r) {
      return n && e(t.prototype, n),
      r && e(t, r),
      t
  }
}()
, fM = _
, S1 = qy(fM)
, dM = pf
, pM = qy(dM)
, hM = Oo
, C1 = qy(hM);
function qy(e) {
  return e && e.__esModule ? e : {
      default: e
  }
}
function mM(e, t) {
  if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function")
}
function yM(e, t) {
  if (!e)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e
}
function gM(e, t) {
  if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, {
      constructor: {
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0
      }
  }),
  t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
}
var OS = function(e) {
  gM(t, e);
  function t() {
      return mM(this, t),
      yM(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments))
  }
  return cM(t, [{
      key: "render",
      value: function() {
          var r = this
            , i = E1({}, this.props);
          return delete i.name,
          i.parentBindings && delete i.parentBindings,
          S1.default.createElement("div", E1({}, i, {
              ref: function(a) {
                  r.props.parentBindings.domNode = a
              }
          }), this.props.children)
      }
  }]),
  t
}(S1.default.Component);
OS.propTypes = {
  name: C1.default.string,
  id: C1.default.string
};
Hy.default = (0,
pM.default)(OS);
var vd = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
          Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
  }
  return e
}
, _1 = function() {
  function e(t, n) {
      for (var r = 0; r < n.length; r++) {
          var i = n[r];
          i.enumerable = i.enumerable || !1,
          i.configurable = !0,
          "value"in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i)
      }
  }
  return function(t, n, r) {
      return n && e(t.prototype, n),
      r && e(t, r),
      t
  }
}();
function P1(e, t) {
  if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function")
}
function T1(e, t) {
  if (!e)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e
}
function O1(e, t) {
  if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, {
      constructor: {
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0
      }
  }),
  t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
}
var wu = _
, Yr = Ao
, wd = As
, Ce = Oo
, sr = df
, k1 = {
  to: Ce.string.isRequired,
  containerId: Ce.string,
  container: Ce.object,
  activeClass: Ce.string,
  spy: Ce.bool,
  smooth: Ce.oneOfType([Ce.bool, Ce.string]),
  offset: Ce.number,
  delay: Ce.number,
  isDynamic: Ce.bool,
  onClick: Ce.func,
  duration: Ce.oneOfType([Ce.number, Ce.func]),
  absolute: Ce.bool,
  onSetActive: Ce.func,
  onSetInactive: Ce.func,
  ignoreCancelEvents: Ce.bool,
  hashSpy: Ce.bool,
  spyThrottle: Ce.number
}
, vM = {
  Scroll: function(t, n) {
      console.warn("Helpers.Scroll is deprecated since v1.7.0");
      var r = n || wd
        , i = function(a) {
          O1(o, a);
          function o(u) {
              P1(this, o);
              var l = T1(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, u));
              return s.call(l),
              l.state = {
                  active: !1
              },
              l
          }
          return _1(o, [{
              key: "getScrollSpyContainer",
              value: function() {
                  var l = this.props.containerId
                    , c = this.props.container;
                  return l ? document.getElementById(l) : c && c.nodeType ? c : document
              }
          }, {
              key: "componentDidMount",
              value: function() {
                  if (this.props.spy || this.props.hashSpy) {
                      var l = this.getScrollSpyContainer();
                      Yr.isMounted(l) || Yr.mount(l, this.props.spyThrottle),
                      this.props.hashSpy && (sr.isMounted() || sr.mount(r),
                      sr.mapContainer(this.props.to, l)),
                      this.props.spy && Yr.addStateHandler(this.stateHandler),
                      Yr.addSpyHandler(this.spyHandler, l),
                      this.setState({
                          container: l
                      })
                  }
              }
          }, {
              key: "componentWillUnmount",
              value: function() {
                  Yr.unmount(this.stateHandler, this.spyHandler)
              }
          }, {
              key: "render",
              value: function() {
                  var l = "";
                  this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
                  var c = vd({}, this.props);
                  for (var f in k1)
                      c.hasOwnProperty(f) && delete c[f];
                  return c.className = l,
                  c.onClick = this.handleClick,
                  wu.createElement(t, c)
              }
          }]),
          o
      }(wu.Component)
        , s = function() {
          var o = this;
          this.scrollTo = function(u, l) {
              r.scrollTo(u, vd({}, o.state, l))
          }
          ,
          this.handleClick = function(u) {
              o.props.onClick && o.props.onClick(u),
              u.stopPropagation && u.stopPropagation(),
              u.preventDefault && u.preventDefault(),
              o.scrollTo(o.props.to, o.props)
          }
          ,
          this.stateHandler = function() {
              r.getActiveLink() !== o.props.to && (o.state !== null && o.state.active && o.props.onSetInactive && o.props.onSetInactive(),
              o.setState({
                  active: !1
              }))
          }
          ,
          this.spyHandler = function(u) {
              var l = o.getScrollSpyContainer();
              if (!(sr.isMounted() && !sr.isInitialized())) {
                  var c = o.props.to
                    , f = null
                    , d = 0
                    , y = 0
                    , m = 0;
                  if (l.getBoundingClientRect) {
                      var v = l.getBoundingClientRect();
                      m = v.top
                  }
                  if (!f || o.props.isDynamic) {
                      if (f = r.get(c),
                      !f)
                          return;
                      var b = f.getBoundingClientRect();
                      d = b.top - m + u,
                      y = d + b.height
                  }
                  var w = u - o.props.offset
                    , h = w >= Math.floor(d) && w < Math.floor(y)
                    , g = w < Math.floor(d) || w >= Math.floor(y)
                    , x = r.getActiveLink();
                  if (g)
                      return c === x && r.setActiveLink(void 0),
                      o.props.hashSpy && sr.getHash() === c && sr.changeHash(),
                      o.props.spy && o.state.active && (o.setState({
                          active: !1
                      }),
                      o.props.onSetInactive && o.props.onSetInactive()),
                      Yr.updateStates();
                  if (h && x !== c)
                      return r.setActiveLink(c),
                      o.props.hashSpy && sr.changeHash(c),
                      o.props.spy && (o.setState({
                          active: !0
                      }),
                      o.props.onSetActive && o.props.onSetActive(c)),
                      Yr.updateStates()
              }
          }
      };
      return i.propTypes = k1,
      i.defaultProps = {
          offset: 0
      },
      i
  },
  Element: function(t) {
      console.warn("Helpers.Element is deprecated since v1.7.0");
      var n = function(r) {
          O1(i, r);
          function i(s) {
              P1(this, i);
              var a = T1(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this, s));
              return a.childBindings = {
                  domNode: null
              },
              a
          }
          return _1(i, [{
              key: "componentDidMount",
              value: function() {
                  if (typeof window > "u")
                      return !1;
                  this.registerElems(this.props.name)
              }
          }, {
              key: "componentDidUpdate",
              value: function(a) {
                  this.props.name !== a.name && this.registerElems(this.props.name)
              }
          }, {
              key: "componentWillUnmount",
              value: function() {
                  if (typeof window > "u")
                      return !1;
                  wd.unregister(this.props.name)
              }
          }, {
              key: "registerElems",
              value: function(a) {
                  wd.register(a, this.childBindings.domNode)
              }
          }, {
              key: "render",
              value: function() {
                  return wu.createElement(t, vd({}, this.props, {
                      parentBindings: this.childBindings
                  }))
              }
          }]),
          i
      }(wu.Component);
      return n.propTypes = {
          name: Ce.string,
          id: Ce.string
      },
      n
  }
}
, wM = vM;
Object.defineProperty($e, "__esModule", {
  value: !0
});
$e.Helpers = $e.ScrollElement = $e.ScrollLink = mf = $e.animateScroll = $e.scrollSpy = $e.Events = Lo = $e.scroller = $e.Element = $e.Button = FS = $e.Link = void 0;
var bM = Ly
, kS = In(bM)
, xM = Wy
, DS = In(xM)
, EM = Hy
, IS = In(EM)
, SM = As
, AS = In(SM)
, CM = No
, $S = In(CM)
, _M = Ao
, RS = In(_M)
, PM = lf
, NS = In(PM)
, TM = Io
, jS = In(TM)
, OM = pf
, MS = In(OM)
, kM = wM
, LS = In(kM);
function In(e) {
  return e && e.__esModule ? e : {
      default: e
  }
}
var FS = $e.Link = kS.default;
$e.Button = DS.default;
$e.Element = IS.default;
var Lo = $e.scroller = AS.default;
$e.Events = $S.default;
$e.scrollSpy = RS.default;
var mf = $e.animateScroll = NS.default;
$e.ScrollLink = jS.default;
$e.ScrollElement = MS.default;
$e.Helpers = LS.default;
$e.default = {
  Link: kS.default,
  Button: DS.default,
  Element: IS.default,
  scroller: AS.default,
  Events: $S.default,
  scrollSpy: RS.default,
  animateScroll: NS.default,
  ScrollLink: jS.default,
  ScrollElement: MS.default,
  Helpers: LS.default
};
var US = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}
, D1 = We.createContext && We.createContext(US)
, Dr = function() {
  return Dr = Object.assign || function(e) {
      for (var t, n = 1, r = arguments.length; n < r; n++) {
          t = arguments[n];
          for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
      }
      return e
  }
  ,
  Dr.apply(this, arguments)
}
, DM = function(e, t) {
  var n = {};
  for (var r in e)
      Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
      for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
          t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n
};
function zS(e) {
  return e && e.map(function(t, n) {
      return We.createElement(t.tag, Dr({
          key: n
      }, t.attr), zS(t.child))
  })
}
function $s(e) {
  return function(t) {
      return We.createElement(IM, Dr({
          attr: Dr({}, e.attr)
      }, t), zS(e.child))
  }
}
function IM(e) {
  var t = function(n) {
      var r = e.attr, i = e.size, s = e.title, a = DM(e, ["attr", "size", "title"]), o = i || n.size || "1em", u;
      return n.className && (u = n.className),
      e.className && (u = (u ? u + " " : "") + e.className),
      We.createElement("svg", Dr({
          stroke: "currentColor",
          fill: "currentColor",
          strokeWidth: "0"
      }, n.attr, r, a, {
          className: u,
          style: Dr(Dr({
              color: e.color || n.color
          }, n.style), e.style),
          height: o,
          width: o,
          xmlns: "http://www.w3.org/2000/svg"
      }), s && We.createElement("title", null, s), e.children)
  };
  return D1 !== void 0 ? We.createElement(D1.Consumer, null, function(n) {
      return t(n)
  }) : t(US)
}
function AM(e) {
  return $s({
      tag: "svg",
      attr: {
          viewBox: "0 0 448 512"
      },
      child: [{
          tag: "path",
          attr: {
              d: "M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"
          }
      }]
  })(e)
}
function $M(e) {
  return $s({
      tag: "svg",
      attr: {
          viewBox: "0 0 448 512"
      },
      child: [{
          tag: "path",
          attr: {
              d: "M446.7 98.6l-67.6 318.8c-5.1 22.5-18.4 28.1-37.3 17.5l-103-75.9-49.7 47.8c-5.5 5.5-10.1 10.1-20.7 10.1l7.4-104.9 190.9-172.5c8.3-7.4-1.8-11.5-12.9-4.1L117.8 284 16.2 252.2c-22.1-6.9-22.5-22.1 4.6-32.7L418.2 66.4c18.4-6.9 34.5 4.1 28.5 32.2z"
          }
      }]
  })(e)
}
function RM(e) {
  return $s({
      tag: "svg",
      attr: {
          viewBox: "0 0 512 512"
      },
      child: [{
          tag: "path",
          attr: {
              d: "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"
          }
      }]
  })(e)
}
function BS(e) {
  return $s({
      tag: "svg",
      attr: {
          viewBox: "0 0 448 512"
      },
      child: [{
          tag: "path",
          attr: {
              d: "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
          }
      }]
  })(e)
}
function WS(e) {
  return $s({
      tag: "svg",
      attr: {
          viewBox: "0 0 352 512"
      },
      child: [{
          tag: "path",
          attr: {
              d: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"
          }
      }]
  })(e)
}
function Ch() {
  return Ch = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];
          for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
      }
      return e
  }
  ,
  Ch.apply(this, arguments)
}
var NM = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
};
const jM = gi(NM);
var MM = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
function I1(e) {
  var t = {
      type: "tag",
      name: "",
      voidElement: !1,
      attrs: {},
      children: []
  }
    , n = e.match(/<\/?([^\s]+?)[/\s>]/);
  if (n && (t.name = n[1],
  (jM[n[1]] || e.charAt(e.length - 2) === "/") && (t.voidElement = !0),
  t.name.startsWith("!--"))) {
      var r = e.indexOf("-->");
      return {
          type: "comment",
          comment: r !== -1 ? e.slice(4, r) : ""
      }
  }
  for (var i = new RegExp(MM), s = null; (s = i.exec(e)) !== null; )
      if (s[0].trim())
          if (s[1]) {
              var a = s[1].trim()
                , o = [a, ""];
              a.indexOf("=") > -1 && (o = a.split("=")),
              t.attrs[o[0]] = o[1],
              i.lastIndex--
          } else
              s[2] && (t.attrs[s[2]] = s[3].trim().substring(1, s[3].length - 1));
  return t
}
var LM = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g
, FM = /^\s*$/
, UM = Object.create(null);
function HS(e, t) {
  switch (t.type) {
  case "text":
      return e + t.content;
  case "tag":
      return e += "<" + t.name + (t.attrs ? function(n) {
          var r = [];
          for (var i in n)
              r.push(i + '="' + n[i] + '"');
          return r.length ? " " + r.join(" ") : ""
      }(t.attrs) : "") + (t.voidElement ? "/>" : ">"),
      t.voidElement ? e : e + t.children.reduce(HS, "") + "</" + t.name + ">";
  case "comment":
      return e + "<!--" + t.comment + "-->"
  }
}
var zM = {
  parse: function(e, t) {
      t || (t = {}),
      t.components || (t.components = UM);
      var n, r = [], i = [], s = -1, a = !1;
      if (e.indexOf("<") !== 0) {
          var o = e.indexOf("<");
          r.push({
              type: "text",
              content: o === -1 ? e : e.substring(0, o)
          })
      }
      return e.replace(LM, function(u, l) {
          if (a) {
              if (u !== "</" + n.name + ">")
                  return;
              a = !1
          }
          var c, f = u.charAt(1) !== "/", d = u.startsWith("<!--"), y = l + u.length, m = e.charAt(y);
          if (d) {
              var v = I1(u);
              return s < 0 ? (r.push(v),
              r) : ((c = i[s]).children.push(v),
              r)
          }
          if (f && (s++,
          (n = I1(u)).type === "tag" && t.components[n.name] && (n.type = "component",
          a = !0),
          n.voidElement || a || !m || m === "<" || n.children.push({
              type: "text",
              content: e.slice(y, e.indexOf("<", y))
          }),
          s === 0 && r.push(n),
          (c = i[s - 1]) && c.children.push(n),
          i[s] = n),
          (!f || n.voidElement) && (s > -1 && (n.voidElement || n.name === u.slice(2, -1)) && (s--,
          n = s === -1 ? r : i[s]),
          !a && m !== "<" && m)) {
              c = s === -1 ? r : i[s].children;
              var b = e.indexOf("<", y)
                , w = e.slice(y, b === -1 ? void 0 : b);
              FM.test(w) && (w = " "),
              (b > -1 && s + c.length >= 0 || w !== " ") && c.push({
                  type: "text",
                  content: w
              })
          }
      }),
      r
  },
  stringify: function(e) {
      return e.reduce(function(t, n) {
          return t + HS("", n)
      }, "")
  }
};
function Vu() {
  if (console && console.warn) {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
          t[n] = arguments[n];
      typeof t[0] == "string" && (t[0] = `react-i18next:: ${t[0]}`),
      console.warn(...t)
  }
}
const A1 = {};
function Hl() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
  typeof t[0] == "string" && A1[t[0]] || (typeof t[0] == "string" && (A1[t[0]] = new Date),
  Vu(...t))
}
const qS = (e, t) => () => {
  if (e.isInitialized)
      t();
  else {
      const n = () => {
          setTimeout( () => {
              e.off("initialized", n)
          }
          , 0),
          t()
      }
      ;
      e.on("initialized", n)
  }
}
;
function $1(e, t, n) {
  e.loadNamespaces(t, qS(e, n))
}
function R1(e, t, n, r) {
  typeof n == "string" && (n = [n]),
  n.forEach(i => {
      e.options.ns.indexOf(i) < 0 && e.options.ns.push(i)
  }
  ),
  e.loadLanguages(t, qS(e, r))
}
function BM(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const r = t.languages[0]
    , i = t.options ? t.options.fallbackLng : !1
    , s = t.languages[t.languages.length - 1];
  if (r.toLowerCase() === "cimode")
      return !0;
  const a = (o, u) => {
      const l = t.services.backendConnector.state[`${o}|${u}`];
      return l === -1 || l === 2
  }
  ;
  return n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && t.services.backendConnector.backend && t.isLanguageChangingTo && !a(t.isLanguageChangingTo, e) ? !1 : !!(t.hasResourceBundle(r, e) || !t.services.backendConnector.backend || t.options.resources && !t.options.partialBundledLanguages || a(r, e) && (!i || a(s, e)))
}
function WM(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return !t.languages || !t.languages.length ? (Hl("i18n.languages were undefined or empty", t.languages),
  !0) : t.options.ignoreJSONStructure !== void 0 ? t.hasLoadedNamespace(e, {
      lng: n.lng,
      precheck: (i, s) => {
          if (n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && i.services.backendConnector.backend && i.isLanguageChangingTo && !s(i.isLanguageChangingTo, e))
              return !1
      }
  }) : BM(e, t, n)
}
const HM = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g
, qM = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/"
}
, VM = e => qM[e]
, KM = e => e.replace(HM, VM);
let _h = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: KM
};
function GM() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  _h = {
      ..._h,
      ...e
  }
}
function VS() {
  return _h
}
let KS;
function QM(e) {
  KS = e
}
function Vy() {
  return KS
}
function bd(e, t) {
  if (!e)
      return !1;
  const n = e.props ? e.props.children : e.children;
  return t ? n.length > 0 : !!n
}
function xd(e) {
  if (!e)
      return [];
  const t = e.props ? e.props.children : e.children;
  return e.props && e.props.i18nIsDynamicList ? Qi(t) : t
}
function YM(e) {
  return Object.prototype.toString.call(e) !== "[object Array]" ? !1 : e.every(t => _.isValidElement(t))
}
function Qi(e) {
  return Array.isArray(e) ? e : [e]
}
function XM(e, t) {
  const n = {
      ...t
  };
  return n.props = Object.assign(e.props, t.props),
  n
}
function GS(e, t) {
  if (!e)
      return "";
  let n = "";
  const r = Qi(e)
    , i = t.transSupportBasicHtmlNodes && t.transKeepBasicHtmlNodesFor ? t.transKeepBasicHtmlNodesFor : [];
  return r.forEach( (s, a) => {
      if (typeof s == "string")
          n += `${s}`;
      else if (_.isValidElement(s)) {
          const o = Object.keys(s.props).length
            , u = i.indexOf(s.type) > -1
            , l = s.props.children;
          if (!l && u && o === 0)
              n += `<${s.type}/>`;
          else if (!l && (!u || o !== 0))
              n += `<${a}></${a}>`;
          else if (s.props.i18nIsDynamicList)
              n += `<${a}></${a}>`;
          else if (u && o === 1 && typeof l == "string")
              n += `<${s.type}>${l}</${s.type}>`;
          else {
              const c = GS(l, t);
              n += `<${a}>${c}</${a}>`
          }
      } else if (s === null)
          Vu("Trans: the passed in value is invalid - seems you passed in a null child.");
      else if (typeof s == "object") {
          const {format: o, ...u} = s
            , l = Object.keys(u);
          if (l.length === 1) {
              const c = o ? `${l[0]}, ${o}` : l[0];
              n += `{{${c}}}`
          } else
              Vu("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", s)
      } else
          Vu("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", s)
  }
  ),
  n
}
function JM(e, t, n, r, i, s) {
  if (t === "")
      return [];
  const a = r.transKeepBasicHtmlNodesFor || []
    , o = t && new RegExp(a.map(b => `<${b}`).join("|")).test(t);
  if (!e && !o && !s)
      return [t];
  const u = {};
  function l(b) {
      Qi(b).forEach(h => {
          typeof h != "string" && (bd(h) ? l(xd(h)) : typeof h == "object" && !_.isValidElement(h) && Object.assign(u, h))
      }
      )
  }
  l(e);
  const c = zM.parse(`<0>${t}</0>`)
    , f = {
      ...u,
      ...i
  };
  function d(b, w, h) {
      const g = xd(b)
        , x = m(g, w.children, h);
      return YM(g) && x.length === 0 || b.props && b.props.i18nIsDynamicList ? g : x
  }
  function y(b, w, h, g, x) {
      b.dummy ? (b.children = w,
      h.push(_.cloneElement(b, {
          key: g
      }, x ? void 0 : w))) : h.push(..._.Children.map([b], S => {
          const E = {
              ...S.props
          };
          return delete E.i18nIsDynamicList,
          We.createElement(S.type, Ch({}, E, {
              key: g,
              ref: S.ref
          }, x ? {} : {
              children: w
          }))
      }
      ))
  }
  function m(b, w, h) {
      const g = Qi(b);
      return Qi(w).reduce( (S, E, p) => {
          const C = E.children && E.children[0] && E.children[0].content && n.services.interpolator.interpolate(E.children[0].content, f, n.language);
          if (E.type === "tag") {
              let T = g[parseInt(E.name, 10)];
              h.length === 1 && !T && (T = h[0][E.name]),
              T || (T = {});
              const O = Object.keys(E.attrs).length !== 0 ? XM({
                  props: E.attrs
              }, T) : T
                , R = _.isValidElement(O)
                , j = R && bd(E, !0) && !E.voidElement
                , L = o && typeof O == "object" && O.dummy && !R
                , M = typeof e == "object" && e !== null && Object.hasOwnProperty.call(e, E.name);
              if (typeof O == "string") {
                  const P = n.services.interpolator.interpolate(O, f, n.language);
                  S.push(P)
              } else if (bd(O) || j) {
                  const P = d(O, E, h);
                  y(O, P, S, p)
              } else if (L) {
                  const P = m(g, E.children, h);
                  y(O, P, S, p)
              } else if (Number.isNaN(parseFloat(E.name)))
                  if (M) {
                      const P = d(O, E, h);
                      y(O, P, S, p, E.voidElement)
                  } else if (r.transSupportBasicHtmlNodes && a.indexOf(E.name) > -1)
                      if (E.voidElement)
                          S.push(_.createElement(E.name, {
                              key: `${E.name}-${p}`
                          }));
                      else {
                          const P = m(g, E.children, h);
                          S.push(_.createElement(E.name, {
                              key: `${E.name}-${p}`
                          }, P))
                      }
                  else if (E.voidElement)
                      S.push(`<${E.name} />`);
                  else {
                      const P = m(g, E.children, h);
                      S.push(`<${E.name}>${P}</${E.name}>`)
                  }
              else if (typeof O == "object" && !R) {
                  const P = E.children[0] ? C : null;
                  P && S.push(P)
              } else
                  y(O, C, S, p, E.children.length !== 1 || !C)
          } else if (E.type === "text") {
              const T = r.transWrapTextNodes
                , O = s ? r.unescape(n.services.interpolator.interpolate(E.content, f, n.language)) : n.services.interpolator.interpolate(E.content, f, n.language);
              T ? S.push(_.createElement(T, {
                  key: `${E.name}-${p}`
              }, O)) : S.push(O)
          }
          return S
      }
      , [])
  }
  const v = m([{
      dummy: !0,
      children: e || []
  }], c, Qi(e || []));
  return xd(v[0])
}
function ZM(e) {
  let {children: t, count: n, parent: r, i18nKey: i, context: s, tOptions: a={}, values: o, defaults: u, components: l, ns: c, i18n: f, t: d, shouldUnescape: y, ...m} = e;
  const v = f || Vy();
  if (!v)
      return Hl("You will need to pass in an i18next instance by using i18nextReactModule"),
      t;
  const b = d || v.t.bind(v) || (j => j);
  s && (a.context = s);
  const w = {
      ...VS(),
      ...v.options && v.options.react
  };
  let h = c || b.ns || v.options && v.options.defaultNS;
  h = typeof h == "string" ? [h] : h || ["translation"];
  const g = GS(t, w)
    , x = u || g || w.transEmptyNodeValue || i
    , {hashTransKey: S} = w
    , E = i || (S ? S(g || x) : g || x);
  v.options && v.options.interpolation && v.options.interpolation.defaultVariables && (o = o && Object.keys(o).length > 0 ? {
      ...o,
      ...v.options.interpolation.defaultVariables
  } : {
      ...v.options.interpolation.defaultVariables
  });
  const p = o ? a.interpolation : {
      interpolation: {
          ...a.interpolation,
          prefix: "#$?",
          suffix: "?$#"
      }
  }
    , C = {
      ...a,
      count: n,
      ...o,
      ...p,
      defaultValue: x,
      ns: h
  }
    , T = E ? b(E, C) : x;
  l && Object.keys(l).forEach(j => {
      const L = l[j];
      if (typeof L.type == "function" || !L.props || !L.props.children || T.indexOf(`${j}/>`) < 0 && T.indexOf(`${j} />`) < 0)
          return;
      function M() {
          return We.createElement(We.Fragment, null, L)
      }
      l[j] = We.createElement(M, null)
  }
  );
  const O = JM(l || t, T, v, w, C, y)
    , R = r !== void 0 ? r : w.defaultTransParent;
  return R ? _.createElement(R, m, O) : O
}
const eL = {
  type: "3rdParty",
  init(e) {
      GM(e.options.react),
      QM(e)
  }
}
, QS = _.createContext();
class tL {
  constructor() {
      this.usedNamespaces = {}
  }
  addUsedNamespaces(t) {
      t.forEach(n => {
          this.usedNamespaces[n] || (this.usedNamespaces[n] = !0)
      }
      )
  }
  getUsedNamespaces() {
      return Object.keys(this.usedNamespaces)
  }
}
function nL(e) {
  let {children: t, count: n, parent: r, i18nKey: i, context: s, tOptions: a={}, values: o, defaults: u, components: l, ns: c, i18n: f, t: d, shouldUnescape: y, ...m} = e;
  const {i18n: v, defaultNS: b} = _.useContext(QS) || {}
    , w = f || v || Vy()
    , h = d || w && w.t.bind(w);
  return ZM({
      children: t,
      count: n,
      parent: r,
      i18nKey: i,
      context: s,
      tOptions: a,
      values: o,
      defaults: u,
      components: l,
      ns: c || h && h.ns || b || w && w.options && w.options.defaultNS,
      i18n: w,
      t: d,
      shouldUnescape: y,
      ...m
  })
}
const rL = (e, t) => {
  const n = _.useRef();
  return _.useEffect( () => {
      n.current = t ? n.current : e
  }
  , [e, t]),
  n.current
}
;
function Ci(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {i18n: n} = t
    , {i18n: r, defaultNS: i} = _.useContext(QS) || {}
    , s = n || r || Vy();
  if (s && !s.reportNamespaces && (s.reportNamespaces = new tL),
  !s) {
      Hl("You will need to pass in an i18next instance by using initReactI18next");
      const g = (S, E) => typeof E == "string" ? E : E && typeof E == "object" && typeof E.defaultValue == "string" ? E.defaultValue : Array.isArray(S) ? S[S.length - 1] : S
        , x = [g, {}, !1];
      return x.t = g,
      x.i18n = {},
      x.ready = !1,
      x
  }
  s.options.react && s.options.react.wait !== void 0 && Hl("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const a = {
      ...VS(),
      ...s.options.react,
      ...t
  }
    , {useSuspense: o, keyPrefix: u} = a;
  let l = e || i || s.options && s.options.defaultNS;
  l = typeof l == "string" ? [l] : l || ["translation"],
  s.reportNamespaces.addUsedNamespaces && s.reportNamespaces.addUsedNamespaces(l);
  const c = (s.isInitialized || s.initializedStoreOnce) && l.every(g => WM(g, s, a));
  function f() {
      return s.getFixedT(t.lng || null, a.nsMode === "fallback" ? l : l[0], u)
  }
  const [d,y] = _.useState(f);
  let m = l.join();
  t.lng && (m = `${t.lng}${m}`);
  const v = rL(m)
    , b = _.useRef(!0);
  _.useEffect( () => {
      const {bindI18n: g, bindI18nStore: x} = a;
      b.current = !0,
      !c && !o && (t.lng ? R1(s, t.lng, l, () => {
          b.current && y(f)
      }
      ) : $1(s, l, () => {
          b.current && y(f)
      }
      )),
      c && v && v !== m && b.current && y(f);
      function S() {
          b.current && y(f)
      }
      return g && s && s.on(g, S),
      x && s && s.store.on(x, S),
      () => {
          b.current = !1,
          g && s && g.split(" ").forEach(E => s.off(E, S)),
          x && s && x.split(" ").forEach(E => s.store.off(E, S))
      }
  }
  , [s, m]);
  const w = _.useRef(!0);
  _.useEffect( () => {
      b.current && !w.current && y(f),
      w.current = !1
  }
  , [s, u]);
  const h = [d, s, c];
  if (h.t = d,
  h.i18n = s,
  h.ready = c,
  c || !c && !o)
      return h;
  throw new Promise(g => {
      t.lng ? R1(s, t.lng, l, () => g()) : $1(s, l, () => g())
  }
  )
}
const iL = q.nav`
background: ${ ({scrollNav: e}) => e ? "#053821" : "transparent"};
height: 100px;
margin-top: -100px;
display: flex;
justify-content: center;
align-items: center;
font-size: 1rem;
position: sticky;
top: 0;
z-index: 80;
transition: 0.3s all ease;
border-bottom: 1px solid #fcefde;
backdrop-filter: blur(${ ({scrollNav: e}) => e ? "0" : "3px"});

@media screen and (max-width: 960px) {
  transition: 0.4s all ease;
}
`
, sL = q.div`
display: flex;
justify-content: space-between;
height: 100px;
z-index: 1;
width: 100%;
padding: 0 24px;
max-width: 1440px;
`
, aL = q(Si)`
color: #fff;
justify-self: flex-start;
cursor: pointer;
font-size: 1.5rem;
display: flex;
align-items: center;
margin-left: 0;
font-weight: bold;
text-decoration: none;
`
, oL = q.img`
max-width: 300px;
width: 100%;
height: auto;

@media screen and (max-width: 768px) {
  max-width: 230px;
}

@media screen and (max-width: 480px) {
  max-width: 180px;
}

@media screen and (max-width: 320px) {
  max-width: 140px;
}

@media screen and (max-width: 280px) {
  max-width: 100px;
}
`
, uL = q.div`
display: none;

@media screen and (max-width: 1100px) {
  display: flex;
  font-size: 1.8rem;
  cursor: pointer;
  color: #fff;
}
`
, lL = q.ul`
display: flex;
align-items: center;
list-style: none;
text-align: center;
margin-right: 24px;

@media screen and (max-width: 1100px) {
  display: none;
}
`
, Ed = q.li`
height: 100px;
`
, cL = q.a`
color: #fff;
display: flex;
align-items: center;
text-decoration: none;
padding: 0 1.2rem;
height: 100%;
font-size: 16px;
transition: all 0.2s ease-in-out;
white-space: nowrap;

@media screen and (max-width: 1400px) {
  font-size: 14px;
}

&.active {
  border-bottom: 4px solid #fcefde;
}

&:hover {
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}
`
, N1 = q(Si)`
color: #fff;
display: flex;
align-items: center;
text-decoration: none;
padding: 0 1.2rem;
height: 100%;
font-size: 16px;
transition: all 0.2s ease-in-out;
white-space: nowrap;

@media screen and (max-width: 1400px) {
  font-size: 14px;
}

&.active {
  border-bottom: 4px solid #fcefde;
}

&:hover {
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}
`
, fL = q.div`
color: #fff;
display: flex;
align-items: center;
`
, dL = q.button`
padding: 2.5px 20px;
color: #81451e;
font-weight: bold;
white-space: nowrap;
transition: all 0.2s ease-in-out;
font-size: 16px;
background: transparent;
border: 10px solid;
border-image: url("/images/nav/navButton.svg") 12 fill;

:disabled {
  opacity: 0.3;
}

&:hover:not([disabled]) {
  cursor: pointer;
  transform: scale(1.05);
  transition: all 0.2s ease-in-out;
  box-shadow: -10px 10px 0px -4px rgba(0, 0, 0, 0.6);
}

@media screen and (max-width: 1100px) {
  display: none;
}
`
, pL = q.div`
display: flex;
position: relative;
align-items: center;
padding: 0.6rem 0.5rem;
margin-right: 15px;
cursor: pointer;
transition: all 0.2s ease-in-out;

@media screen and (max-width: 1100px) {
  margin-right: 5px;
}
`
, hL = q.div`
display: flex;
flex-direction: row;
align-items: center;
gap: 0.3rem;
`
, mL = q.img`
width: 25px;
height: auto;

@media screen and (max-width: 1100px) {
  width: 18px;
}
`
, j1 = q.img`
height: auto;
width: 35px;

@media screen and (max-width: 1100px) {
  width: 25px;
}

@media screen and (max-width: 480px) {
  width: 20px;
}
`
, yL = q.div`
background: #fff;
position: absolute;
width: 100%;
top: 50px;
left: 0;
cursor: pointer;
transition: all 0.2s ease-in-out;

@media screen and (max-width: 1100px) {
  top: 45px;
}
`
, gL = q.div`
display: flex;
align-items: center;
padding: 0.5rem 1rem;
justify-content: center;
align-items: center;

&:hover {
  background: #cccc;
}
`
, gr = {
  en: {
      title: "English",
      image: "/images/flags/english.webp"
  },
  fr: {
      title: "French",
      image: "/images/flags/french.webp"
  },
  es: {
      title: "Spanish",
      image: "/images/flags/spanish.webp"
  },
  de: {
      title: "German",
      image: "/images/flags/german.webp"
  },
  it: {
      title: "Italian",
      image: "/images/flags/italian.webp"
  },
  kr: {
      title: "Korean",
      image: "/images/flags/korean.webp"
  },
  ru: {
      title: "Russian",
      image: "/images/flags/russian.webp"
  },
  nl: {
      title: "Dutch",
      image: "/images/flags/dutch.webp"
  },
  zh: {
      title: "Chinese",
      image: "/images/flags/chinese.webp"
  },
  tr: {
      title: "Turkish",
      image: "/images/flags/turkish.webp"
  },
  pt: {
      title: "Portuguese",
      image: "/images/flags/portuguese.webp"
  },
  vi: {
      title: "Vietnamese ",
      image: "/images/flags/vietnam.webp"
  }
}
, vL = 1
, wL = ["diamond", "gold", "silver", "bronze"]
, bL = ["#b9f2ff", "#FFD700", "#C0C0C0", "#CD7F32"]
, xL = "https://nftstorage.link/ipfs"
, EL = {
  "nft-diamond-address": "0xA004493E7791155C09748A2E70d26bF8E4E41E45",
  "nft-diamond-address-testnet": "0xCC50cb0Cda3fF77E98226Adb5E974B9281AFc036",
  metadata: "bafybeicti64zdft7pl3wqedmf3awgxxhnti2whpsk53uyc4tvywe5x7gki",
  thumbnail: "bafybeih4rcxfa3fyb57rpsr3mnvro7xbvwg4e3ine4fbx6lizf7od7ksk4"
}
, SL = {
  "nft-gold-address": "0x97a2B3e2f595f23bbfcAa35626F24EA0b7070FCB",
  "nft-gold-address-testnet": "0xdA2b9E8f34F6EDABd23b9c8B86daf8fA817edbB3",
  metadata: "bafybeibofe45ofudtuidfsmbpyh62t7bcvdfntptuzzb4pbdb3a3ydhzbu",
  thumbnail: "bafybeict5b5wdoqoq6g3il5k2kht3kio7b2soz2b5w557ck3ic5vocy34y"
}
, CL = {
  "nft-silver-address": "0x886403FF7B1f84BF44aB473C887DC679Bee52778",
  "nft-silver-address-testnet": "0xf9d6Ac57Cc7dC2259eaCfd2Db3355dB45fe1EB2A",
  metadata: "bafybeihczykk7hk5gaw4ucshyyipxkceovtvod2mf7lsgpkbp5ovqnxzhq",
  thumbnail: "bafybeidwufanh7shuduiryza52gc2dvtgbnd6uiyi5kk6xkuuq7garicza"
}
, _L = {
  "nft-bronze-address": "0x0Cfcd18ab2A99F37E7657e9E9b5B6018db63c362",
  "nft-bronze-address-testnet": "0x968fB54E694243A01c0E61D0635F40fF891030cc",
  metadata: "bafybeifscsy4ypty23c6g5mzpsnho2gdfzgdhfpyyvpifwbef4nsbogduu",
  thumbnail: "bafybeihzjtjpgqheuwdjd5g3usjjczjuaxumslscbk6bzhz3znfoi7erji"
}
, _i = {
  chainId: vL,
  types: wL,
  colors: bL,
  gateaway: xL,
  "coin-contract-address": "0x1161aB556bAA457994b1D6A6cCa3A7a6891009FD",
  "coin-contract-address-testnet": "0xb136f66CCC6D953D083fe0631bD57CBd8adeF4eF",
  "coin-stake-address": "0x9e6396e732f7E98a76403cDd3ef9c40286a42649",
  "coin-stake-address-testnet": "0xAC07DfCE6a996940e84Dc874cDE7f99E33ff665b",
  "nft-stake-address": "0x3d43290D2FB1BCcdAbE5899E0Aef51b2ab6De13a",
  "nft-stake-address-testnet": "0x81B0C05B540D2854d6886d450F237Ab4378fCF95",
  diamond: EL,
  gold: SL,
  silver: CL,
  bronze: _L
}
, PL = [{
  inputs: [{
      internalType: "string",
      name: "_name",
      type: "string"
  }, {
      internalType: "string",
      name: "_symbol",
      type: "string"
  }, {
      internalType: "uint256",
      name: "_amount",
      type: "uint256"
  }],
  stateMutability: "nonpayable",
  type: "constructor"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "owner",
      type: "address"
  }, {
      indexed: !0,
      internalType: "address",
      name: "spender",
      type: "address"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "value",
      type: "uint256"
  }],
  name: "Approval",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "previousOwner",
      type: "address"
  }, {
      indexed: !0,
      internalType: "address",
      name: "newOwner",
      type: "address"
  }],
  name: "OwnershipTransferred",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "from",
      type: "address"
  }, {
      indexed: !0,
      internalType: "address",
      name: "to",
      type: "address"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "value",
      type: "uint256"
  }],
  name: "Transfer",
  type: "event"
}, {
  inputs: [{
      internalType: "address",
      name: "owner",
      type: "address"
  }, {
      internalType: "address",
      name: "spender",
      type: "address"
  }],
  name: "allowance",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "spender",
      type: "address"
  }, {
      internalType: "uint256",
      name: "amount",
      type: "uint256"
  }],
  name: "approve",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "account",
      type: "address"
  }],
  name: "balanceOf",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "_amount",
      type: "uint256"
  }],
  name: "burn",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "decimals",
  outputs: [{
      internalType: "uint8",
      name: "",
      type: "uint8"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "spender",
      type: "address"
  }, {
      internalType: "uint256",
      name: "subtractedValue",
      type: "uint256"
  }],
  name: "decreaseAllowance",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "spender",
      type: "address"
  }, {
      internalType: "uint256",
      name: "addedValue",
      type: "uint256"
  }],
  name: "increaseAllowance",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "name",
  outputs: [{
      internalType: "string",
      name: "",
      type: "string"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "owner",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "renounceOwnership",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "symbol",
  outputs: [{
      internalType: "string",
      name: "",
      type: "string"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalSupply",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "to",
      type: "address"
  }, {
      internalType: "uint256",
      name: "amount",
      type: "uint256"
  }],
  name: "transfer",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "from",
      type: "address"
  }, {
      internalType: "address",
      name: "to",
      type: "address"
  }, {
      internalType: "uint256",
      name: "amount",
      type: "uint256"
  }],
  name: "transferFrom",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "newOwner",
      type: "address"
  }],
  name: "transferOwnership",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}]
, TL = [{
  inputs: [],
  stateMutability: "nonpayable",
  type: "constructor"
}, {
  inputs: [],
  name: "EnforcedPause",
  type: "error"
}, {
  inputs: [],
  name: "ExpectedPause",
  type: "error"
}, {
  inputs: [],
  name: "InvalidInitialization",
  type: "error"
}, {
  inputs: [],
  name: "NotInitializing",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "owner",
      type: "address"
  }],
  name: "OwnableInvalidOwner",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "account",
      type: "address"
  }],
  name: "OwnableUnauthorizedAccount",
  type: "error"
}, {
  inputs: [],
  name: "ReentrancyGuardReentrantCall",
  type: "error"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "uint64",
      name: "version",
      type: "uint64"
  }],
  name: "Initialized",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "previousOwner",
      type: "address"
  }, {
      indexed: !0,
      internalType: "address",
      name: "newOwner",
      type: "address"
  }],
  name: "OwnershipTransferred",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "address",
      name: "account",
      type: "address"
  }],
  name: "Paused",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "staker",
      type: "address"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "rewardAmount",
      type: "uint256"
  }],
  name: "RewardsClaimed",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "staker",
      type: "address"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "amount",
      type: "uint256"
  }],
  name: "TokensStaked",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "staker",
      type: "address"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "amount",
      type: "uint256"
  }],
  name: "TokensWithdrawn",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "address",
      name: "account",
      type: "address"
  }],
  name: "Unpaused",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "uint256",
      name: "oldAmount",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "newAmount",
      type: "uint256"
  }],
  name: "UpdatedLocktime",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "uint256",
      name: "oldAmount",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "newAmount",
      type: "uint256"
  }],
  name: "UpdatedMinStakeAmount",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "uint256[]",
      name: "oldNumerator",
      type: "uint256[]"
  }, {
      indexed: !1,
      internalType: "uint256[]",
      name: "newNumerator",
      type: "uint256[]"
  }, {
      indexed: !1,
      internalType: "uint256[]",
      name: "oldDenominator",
      type: "uint256[]"
  }, {
      indexed: !1,
      internalType: "uint256[]",
      name: "newDenominator",
      type: "uint256[]"
  }, {
      indexed: !1,
      internalType: "uint256[]",
      name: "oldRatioAmount",
      type: "uint256[]"
  }, {
      indexed: !1,
      internalType: "uint256[]",
      name: "newRatioAmount",
      type: "uint256[]"
  }],
  name: "UpdatedRewardRatio",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "uint256",
      name: "oldTimeUnit",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "newTimeUnit",
      type: "uint256"
  }],
  name: "UpdatedTimeUnit",
  type: "event"
}, {
  inputs: [],
  name: "claimRewards",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "_amount",
      type: "uint256"
  }],
  name: "depositRewardTokens",
  outputs: [],
  stateMutability: "payable",
  type: "function"
}, {
  inputs: [],
  name: "getCurrentStakerCount",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_staker",
      type: "address"
  }],
  name: "getLockedCoins",
  outputs: [{
      components: [{
          internalType: "uint256",
          name: "amountDeposited",
          type: "uint256"
      }, {
          internalType: "uint256",
          name: "lockedUntilTime",
          type: "uint256"
      }],
      internalType: "struct IStaking20.LockedDeposits[]",
      name: "_lockedCoins",
      type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getMinStakeAmount",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getRewardRatio",
  outputs: [{
      internalType: "uint256[]",
      name: "_numerator",
      type: "uint256[]"
  }, {
      internalType: "uint256[]",
      name: "_denominator",
      type: "uint256[]"
  }, {
      internalType: "uint256[]",
      name: "_rewardRatioAmount",
      type: "uint256[]"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getRewardTokenBalance",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_staker",
      type: "address"
  }],
  name: "getStakeInfo",
  outputs: [{
      internalType: "uint256",
      name: "_tokensStaked",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_rewards",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_totalRewards",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getTimeUnit",
  outputs: [{
      internalType: "uint80",
      name: "_timeUnit",
      type: "uint80"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getTotalCoinStaked",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getTotalRewardPaid",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getTotalStakerCount",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_tokenAddress",
      type: "address"
  }, {
      internalType: "uint80",
      name: "_timeUnit",
      type: "uint80"
  }, {
      internalType: "uint256[]",
      name: "_rewardRatioNumerator",
      type: "uint256[]"
  }, {
      internalType: "uint256[]",
      name: "_rewardRatioDenominator",
      type: "uint256[]"
  }, {
      internalType: "uint256[]",
      name: "_rewardRatioAmount",
      type: "uint256[]"
  }, {
      internalType: "uint256",
      name: "_minStakeAmount",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_locktime",
      type: "uint256"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "locktime",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "minStakeAmount",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "owner",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "paused",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "renounceOwnership",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "rewardTokenBalance",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "_newAmount",
      type: "uint256"
  }],
  name: "setLocktime",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "_newAmount",
      type: "uint256"
  }],
  name: "setMinStakeAmount",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256[]",
      name: "_numerator",
      type: "uint256[]"
  }, {
      internalType: "uint256[]",
      name: "_denominator",
      type: "uint256[]"
  }, {
      internalType: "uint256[]",
      name: "_rewardRatioAmount",
      type: "uint256[]"
  }],
  name: "setRewardRatio",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint80",
      name: "_timeUnit",
      type: "uint80"
  }],
  name: "setTimeUnit",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "_amount",
      type: "uint256"
  }],
  name: "stake",
  outputs: [],
  stateMutability: "payable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  name: "stakers",
  outputs: [{
      internalType: "uint128",
      name: "timeOfLastUpdate",
      type: "uint128"
  }, {
      internalType: "uint64",
      name: "conditionIdOflastUpdate",
      type: "uint64"
  }, {
      internalType: "uint256",
      name: "amountStaked",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "unclaimedRewards",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "totalEarnedRewards",
      type: "uint256"
  }, {
      internalType: "bool",
      name: "stakedBefore",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "stakersArray",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "stakingToken",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "stakingTokenBalance",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "stakingTokenDecimals",
  outputs: [{
      internalType: "uint16",
      name: "",
      type: "uint16"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalCoinStaked",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalRewardPaid",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalStakersCount",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "newOwner",
      type: "address"
  }],
  name: "transferOwnership",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "_amount",
      type: "uint256"
  }],
  name: "withdraw",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "_amount",
      type: "uint256"
  }],
  name: "withdrawRewardTokens",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}]
, OL = [{
  inputs: [],
  stateMutability: "nonpayable",
  type: "constructor"
}, {
  inputs: [],
  name: "EnforcedPause",
  type: "error"
}, {
  inputs: [],
  name: "ExpectedPause",
  type: "error"
}, {
  inputs: [],
  name: "InvalidInitialization",
  type: "error"
}, {
  inputs: [],
  name: "NotInitializing",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "owner",
      type: "address"
  }],
  name: "OwnableInvalidOwner",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "account",
      type: "address"
  }],
  name: "OwnableUnauthorizedAccount",
  type: "error"
}, {
  inputs: [],
  name: "ReentrancyGuardReentrantCall",
  type: "error"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "uint64",
      name: "version",
      type: "uint64"
  }],
  name: "Initialized",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "previousOwner",
      type: "address"
  }, {
      indexed: !0,
      internalType: "address",
      name: "newOwner",
      type: "address"
  }],
  name: "OwnershipTransferred",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "address",
      name: "account",
      type: "address"
  }],
  name: "Paused",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "staker",
      type: "address"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "rewardAmount",
      type: "uint256"
  }],
  name: "RewardsClaimed",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "staker",
      type: "address"
  }, {
      indexed: !0,
      internalType: "uint256[]",
      name: "tokenIds",
      type: "uint256[]"
  }],
  name: "TokensStaked",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "staker",
      type: "address"
  }, {
      indexed: !0,
      internalType: "uint256[]",
      name: "tokenIds",
      type: "uint256[]"
  }],
  name: "TokensWithdrawn",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "address",
      name: "account",
      type: "address"
  }],
  name: "Unpaused",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "uint256",
      name: "oldRewardsPerUnitTimeDiamond",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "newRewardsPerUnitTimeDiamond",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "oldRewardsPerUnitTimeGold",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "newRewardsPerUnitTimeGold",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "oldRewardsPerUnitTimeSilver",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "newRewardsPerUnitTimeSilver",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "oldRewardsPerUnitTimeBronze",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "newRewardsPerUnitTimeBronze",
      type: "uint256"
  }],
  name: "UpdatedRewardsPerUnitTime",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "uint256",
      name: "oldTimeUnit",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "newTimeUnit",
      type: "uint256"
  }],
  name: "UpdatedTimeUnit",
  type: "event"
}, {
  inputs: [],
  name: "chmpzToken",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "chmpzTokenDecimals",
  outputs: [{
      internalType: "uint16",
      name: "",
      type: "uint16"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "claimRewards",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "currentStakedBalance",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "_amount",
      type: "uint256"
  }],
  name: "depositRewardTokens",
  outputs: [],
  stateMutability: "payable",
  type: "function"
}, {
  inputs: [],
  name: "getCurrentStakedBalance",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getRewardTokenBalance",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getRewardsPerUnitTime",
  outputs: [{
      internalType: "uint256",
      name: "_rewardsPerUnitTimeDiamond",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_rewardsPerUnitTimeGold",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_rewardsPerUnitTimeSilver",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_rewardsPerUnitTimeBronze",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_staker",
      type: "address"
  }],
  name: "getStakeInfoBronze",
  outputs: [{
      internalType: "uint256[]",
      name: "_tokensStaked",
      type: "uint256[]"
  }, {
      internalType: "uint256",
      name: "_rewards",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_staker",
      type: "address"
  }],
  name: "getStakeInfoDiamond",
  outputs: [{
      internalType: "uint256[]",
      name: "_tokensStaked",
      type: "uint256[]"
  }, {
      internalType: "uint256",
      name: "_rewards",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_staker",
      type: "address"
  }],
  name: "getStakeInfoGold",
  outputs: [{
      internalType: "uint256[]",
      name: "_tokensStaked",
      type: "uint256[]"
  }, {
      internalType: "uint256",
      name: "_rewards",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_staker",
      type: "address"
  }],
  name: "getStakeInfoSilver",
  outputs: [{
      internalType: "uint256[]",
      name: "_tokensStaked",
      type: "uint256[]"
  }, {
      internalType: "uint256",
      name: "_rewards",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getTimeUnit",
  outputs: [{
      internalType: "uint256",
      name: "_timeUnit",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getTotalNftStaked",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getTotalRewardPaid",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_staker",
      type: "address"
  }],
  name: "getTotalRewardsForStaker",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getTotalStakerCount",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_staker",
      type: "address"
  }],
  name: "getUnclaimedTotalForStaker",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "indexedTokensBronze",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "indexedTokensDiamond",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "indexedTokensGold",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "indexedTokensSilver",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_chmpzToken",
      type: "address"
  }, {
      internalType: "address",
      name: "_stakingTokenDiamond",
      type: "address"
  }, {
      internalType: "address",
      name: "_stakingTokenGold",
      type: "address"
  }, {
      internalType: "address",
      name: "_stakingTokenSilver",
      type: "address"
  }, {
      internalType: "address",
      name: "_stakingTokenBronze",
      type: "address"
  }, {
      internalType: "uint256",
      name: "_rewardsPerUnitTimeDiamond",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_rewardsPerUnitTimeGold",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_rewardsPerUnitTimeSilver",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_rewardsPerUnitTimeBronze",
      type: "uint256"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "isIndexedBronze",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "isIndexedDiamond",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "isIndexedGold",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "isIndexedSilver",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }, {
      internalType: "address",
      name: "",
      type: "address"
  }, {
      internalType: "uint256",
      name: "",
      type: "uint256"
  }, {
      internalType: "bytes",
      name: "",
      type: "bytes"
  }],
  name: "onERC721Received",
  outputs: [{
      internalType: "bytes4",
      name: "",
      type: "bytes4"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "owner",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "paused",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "renounceOwnership",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "rewardTokenBalance",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "_rewardsPerUnitTimeDiamond",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_rewardsPerUnitTimeGold",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_rewardsPerUnitTimeSilver",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "_rewardsPerUnitTimeBronze",
      type: "uint256"
  }],
  name: "setRewardsPerUnitTime",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "_timeUnit",
      type: "uint256"
  }],
  name: "setTimeUnit",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256[]",
      name: "_tokenIds",
      type: "uint256[]"
  }],
  name: "stakeBronze",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256[]",
      name: "_tokenIds",
      type: "uint256[]"
  }],
  name: "stakeDiamond",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256[]",
      name: "_tokenIds",
      type: "uint256[]"
  }],
  name: "stakeGold",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256[]",
      name: "_tokenIds",
      type: "uint256[]"
  }],
  name: "stakeSilver",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "stakerAddressBronze",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "stakerAddressDiamond",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "stakerAddressGold",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  name: "stakerAddressSilver",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  name: "stakers",
  outputs: [{
      internalType: "uint64",
      name: "amountStakedDiamond",
      type: "uint64"
  }, {
      internalType: "uint64",
      name: "amountStakedGold",
      type: "uint64"
  }, {
      internalType: "uint64",
      name: "amountStakedSilver",
      type: "uint64"
  }, {
      internalType: "uint64",
      name: "amountStakedBronze",
      type: "uint64"
  }, {
      internalType: "uint64",
      name: "conditionIdOflastUpdate",
      type: "uint64"
  }, {
      internalType: "uint128",
      name: "timeOfLastUpdateDiamond",
      type: "uint128"
  }, {
      internalType: "uint128",
      name: "timeOfLastUpdateGold",
      type: "uint128"
  }, {
      internalType: "uint128",
      name: "timeOfLastUpdateSilver",
      type: "uint128"
  }, {
      internalType: "uint128",
      name: "timeOfLastUpdateBronze",
      type: "uint128"
  }, {
      internalType: "uint256",
      name: "unclaimedRewardsDiamond",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "unclaimedRewardsGold",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "unclaimedRewardsSilver",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "unclaimedRewardsBronze",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "totalEarnedRewards",
      type: "uint256"
  }, {
      internalType: "bool",
      name: "stakedBefore",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "stakingTokenBronze",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "stakingTokenDiamond",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "stakingTokenGold",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "stakingTokenSilver",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalNftStaked",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalRewardPaid",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalStakersCount",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "newOwner",
      type: "address"
  }],
  name: "transferOwnership",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256[]",
      name: "_tokenIds",
      type: "uint256[]"
  }],
  name: "withdrawBronze",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256[]",
      name: "_tokenIds",
      type: "uint256[]"
  }],
  name: "withdrawDiamond",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256[]",
      name: "_tokenIds",
      type: "uint256[]"
  }],
  name: "withdrawGold",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "_amount",
      type: "uint256"
  }],
  name: "withdrawRewardTokens",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256[]",
      name: "_tokenIds",
      type: "uint256[]"
  }],
  name: "withdrawSilver",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}]
, yf = [{
  inputs: [],
  stateMutability: "nonpayable",
  type: "constructor"
}, {
  inputs: [],
  name: "ERC721EnumerableForbiddenBatchMint",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "sender",
      type: "address"
  }, {
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }, {
      internalType: "address",
      name: "owner",
      type: "address"
  }],
  name: "ERC721IncorrectOwner",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "operator",
      type: "address"
  }, {
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "ERC721InsufficientApproval",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "approver",
      type: "address"
  }],
  name: "ERC721InvalidApprover",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "operator",
      type: "address"
  }],
  name: "ERC721InvalidOperator",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "owner",
      type: "address"
  }],
  name: "ERC721InvalidOwner",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "receiver",
      type: "address"
  }],
  name: "ERC721InvalidReceiver",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "sender",
      type: "address"
  }],
  name: "ERC721InvalidSender",
  type: "error"
}, {
  inputs: [{
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "ERC721NonexistentToken",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "owner",
      type: "address"
  }, {
      internalType: "uint256",
      name: "index",
      type: "uint256"
  }],
  name: "ERC721OutOfBoundsIndex",
  type: "error"
}, {
  inputs: [],
  name: "EnforcedPause",
  type: "error"
}, {
  inputs: [],
  name: "ExpectedPause",
  type: "error"
}, {
  inputs: [],
  name: "InvalidInitialization",
  type: "error"
}, {
  inputs: [],
  name: "NotInitializing",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "owner",
      type: "address"
  }],
  name: "OwnableInvalidOwner",
  type: "error"
}, {
  inputs: [{
      internalType: "address",
      name: "account",
      type: "address"
  }],
  name: "OwnableUnauthorizedAccount",
  type: "error"
}, {
  inputs: [],
  name: "ReentrancyGuardReentrantCall",
  type: "error"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "address[]",
      name: "userWallets",
      type: "address[]"
  }],
  name: "AddedToWhitelist",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "owner",
      type: "address"
  }, {
      indexed: !0,
      internalType: "address",
      name: "approved",
      type: "address"
  }, {
      indexed: !0,
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "Approval",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "owner",
      type: "address"
  }, {
      indexed: !0,
      internalType: "address",
      name: "operator",
      type: "address"
  }, {
      indexed: !1,
      internalType: "bool",
      name: "approved",
      type: "bool"
  }],
  name: "ApprovalForAll",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "uint256",
      name: "oldMaxSupply",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "newMaxSupply",
      type: "uint256"
  }],
  name: "ChangedMaxSupply",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "uint64",
      name: "version",
      type: "uint64"
  }],
  name: "Initialized",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "previousOwner",
      type: "address"
  }, {
      indexed: !0,
      internalType: "address",
      name: "newOwner",
      type: "address"
  }],
  name: "OwnershipTransferred",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "address",
      name: "account",
      type: "address"
  }],
  name: "Paused",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "uint256",
      name: "newEthPrice",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "uint256",
      name: "newChmpzPrice",
      type: "uint256"
  }],
  name: "PriceUpdated",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "address[]",
      name: "userWallets",
      type: "address[]"
  }],
  name: "RemovedFromWhitelist",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }, {
      indexed: !1,
      internalType: "address",
      name: "owner",
      type: "address"
  }],
  name: "TokenMinted",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !0,
      internalType: "address",
      name: "from",
      type: "address"
  }, {
      indexed: !0,
      internalType: "address",
      name: "to",
      type: "address"
  }, {
      indexed: !0,
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "Transfer",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "address",
      name: "account",
      type: "address"
  }],
  name: "Unpaused",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "string",
      name: "oldURI",
      type: "string"
  }, {
      indexed: !1,
      internalType: "string",
      name: "newURI",
      type: "string"
  }],
  name: "UriChanged",
  type: "event"
}, {
  anonymous: !1,
  inputs: [{
      indexed: !1,
      internalType: "bool",
      name: "currentStatus",
      type: "bool"
  }],
  name: "WhitelistToggled",
  type: "event"
}, {
  inputs: [{
      internalType: "address",
      name: "contract1",
      type: "address"
  }, {
      internalType: "address",
      name: "contract2",
      type: "address"
  }, {
      internalType: "address",
      name: "contract3",
      type: "address"
  }],
  name: "addPassportAddresses",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address[]",
      name: "userWallets",
      type: "address[]"
  }],
  name: "addToWhitelist",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "to",
      type: "address"
  }, {
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "approve",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "owner",
      type: "address"
  }],
  name: "balanceOf",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "newCoinAddress",
      type: "address"
  }],
  name: "changeCoinContract",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "newMaxStageForWhitelist",
      type: "uint256"
  }],
  name: "changeMaxStageForWhitelist",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "newMaxSupply",
      type: "uint256"
  }],
  name: "changeMaxSupply",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "newLimit",
      type: "uint256"
  }],
  name: "changeMintLimit",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "newPresaleAddress",
      type: "address"
  }],
  name: "changePresaleContract",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "newTeamSupply",
      type: "uint256"
  }],
  name: "changeTeamSupply",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "getAllMintedTokens",
  outputs: [{
      internalType: "uint256[]",
      name: "",
      type: "uint256[]"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "getApproved",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getBaseURI",
  outputs: [{
      internalType: "string",
      name: "",
      type: "string"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getCHMPZPrice",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getETHPrice",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getMaxSupply",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getMintLimit",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getTeamSupply",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getTotalBurnedCHMPZ",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getTotalSupply",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getUsableSupply",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_address",
      type: "address"
  }],
  name: "getUserMintCount",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getWhitelistStatus",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "string",
      name: "name_",
      type: "string"
  }, {
      internalType: "string",
      name: "symbol_",
      type: "string"
  }, {
      internalType: "string",
      name: "baseTokenURI_",
      type: "string"
  }, {
      internalType: "uint256",
      name: "maxTokenSupply_",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "teamSupply_",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "ethTokenPrice_",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "chmpzTokenPrice_",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "maxStageForWhitelist_",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "mintLimit_",
      type: "uint256"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "owner",
      type: "address"
  }, {
      internalType: "address",
      name: "operator",
      type: "address"
  }],
  name: "isApprovedForAll",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "_address",
      type: "address"
  }],
  name: "isWhitelisted",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "mintWithCHMPZ",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "mintWithETH",
  outputs: [],
  stateMutability: "payable",
  type: "function"
}, {
  inputs: [],
  name: "name",
  outputs: [{
      internalType: "string",
      name: "",
      type: "string"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "owner",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "toWallet",
      type: "address"
  }, {
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "ownerMint",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "ownerOf",
  outputs: [{
      internalType: "address",
      name: "",
      type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "paused",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address[]",
      name: "userWallets",
      type: "address[]"
  }],
  name: "removeFromWhitelist",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "renounceOwnership",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "from",
      type: "address"
  }, {
      internalType: "address",
      name: "to",
      type: "address"
  }, {
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "safeTransferFrom",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "from",
      type: "address"
  }, {
      internalType: "address",
      name: "to",
      type: "address"
  }, {
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }, {
      internalType: "bytes",
      name: "data",
      type: "bytes"
  }],
  name: "safeTransferFrom",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "operator",
      type: "address"
  }, {
      internalType: "bool",
      name: "approved",
      type: "bool"
  }],
  name: "setApprovalForAll",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "bytes4",
      name: "interfaceId",
      type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
      internalType: "bool",
      name: "",
      type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "symbol",
  outputs: [{
      internalType: "string",
      name: "",
      type: "string"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "toggleWhitelist",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "index",
      type: "uint256"
  }],
  name: "tokenByIndex",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "owner",
      type: "address"
  }, {
      internalType: "uint256",
      name: "index",
      type: "uint256"
  }],
  name: "tokenOfOwnerByIndex",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "tokenURI",
  outputs: [{
      internalType: "string",
      name: "",
      type: "string"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "totalSupply",
  outputs: [{
      internalType: "uint256",
      name: "",
      type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "from",
      type: "address"
  }, {
      internalType: "address",
      name: "to",
      type: "address"
  }, {
      internalType: "uint256",
      name: "tokenId",
      type: "uint256"
  }],
  name: "transferFrom",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "newOwner",
      type: "address"
  }],
  name: "transferOwnership",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "string",
      name: "newBaseTokenURI",
      type: "string"
  }],
  name: "updateBaseURI",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "uint256",
      name: "newEthPrice",
      type: "uint256"
  }, {
      internalType: "uint256",
      name: "newChmpzPrice",
      type: "uint256"
  }],
  name: "updateMintingPrice",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
      internalType: "address",
      name: "owner",
      type: "address"
  }],
  name: "walletOfOwner",
  outputs: [{
      internalType: "uint256[]",
      name: "",
      type: "uint256[]"
  }],
  stateMutability: "view",
  type: "function"
}]
, s7 = {
  address: _i["coin-contract-address"],
  abi: PL
}
, a7 = {
  address: _i.diamond["nft-diamond-address"],
  abi: yf
}
, o7 = {
  address: _i.gold["nft-gold-address"],
  abi: yf
}
, u7 = {
  address: _i.silver["nft-silver-address"],
  abi: yf
}
, l7 = {
  address: _i.bronze["nft-bronze-address"],
  abi: yf
}
, c7 = {
  address: _i["coin-stake-address"],
  abi: TL
}
, f7 = {
  address: _i["nft-stake-address"],
  abi: OL
}
, kL = {
  chmpzBalance: 0,
  tokenStaked: 0,
  rewards: 0,
  totalRewards: 0,
  lockedCoins: [[0, 0]],
  address: "0x0000000000000000000000000000000000000000",
  init: !1
}
, DL = {
  numerator: [0],
  denominator: [0],
  ratioAmount: [0],
  minStakeAmount: 0,
  rewardTokenBalance: 0,
  totalCoinStaked: 0,
  totalRewardPaid: 0,
  totalStakerCount: 0,
  paused: !1,
  timeUnit: 0,
  init: !1
}
, IL = {
  totalStakerCount: 0,
  totalRewardPaid: 0,
  totalNftCount: 0,
  rewardTokenBalance: 0,
  paused: !1,
  init: !1
}
, AL = {
  chmpzBalance: 0,
  rewards: 0,
  totalRewards: 0,
  ownedDiamond: [],
  ownedGold: [],
  ownedSilver: [],
  ownedBronze: [],
  stakedDiamond: [],
  stakedGold: [],
  stakedSilver: [],
  stakedBronze: [],
  diamondRewards: 0,
  goldRewards: 0,
  silverRewards: 0,
  bronzeRewards: 0,
  diamondAllowance: !1,
  goldAllowance: !1,
  silverAllowance: !1,
  bronzeAllowance: !1,
  address: "0x0000000000000000000000000000000000000000",
  init: !1
}
, YS = _.createContext({})
, $L = ({children: e}) => {
  const [t,n] = _.useState(!1)
    , [r,i] = _.useState(DL)
    , [s,a] = _.useState(IL)
    , [o,u] = _.useState(kL)
    , [l,c] = _.useState(AL)
    , f = _.useMemo( () => ({
      sidebarOpen: t,
      setSidebarOpen: n,
      coinStakeInfo: r,
      setCoinStakeInfo: i,
      userInfo: o,
      setUserInfo: u,
      nftStakeInfo: s,
      setNftStakeInfo: a,
      nftUserInfo: l,
      setnftUserInfo: c
  }), [t, r, o, s, l]);
  return D.jsx(YS.Provider, {
      value: f,
      children: e
  })
}
, gf = () => _.useContext(YS)
, XS = e => {
  const t = e.slice(-4);
  return `${e.slice(0, 4)}...${t}`
}
, RL = () => {
  const {t: e, i18n: t} = Ci()
    , n = _.useRef(null)
    , {open: r} = Mc()
    , {address: i, isConnected: s} = jc()
    , {sidebarOpen: a, setSidebarOpen: o} = gf()
    , u = vn()
    , l = Is()
    , [c,f] = _.useState(!1);
  _.useState("");
  const [d,y] = _.useState(!1)
    , m = () => {
      u.pathname !== "/coin" && l("/coin"),
      mf.scrollToTop()
  }
    , v = () => {
      window.scrollY >= 100 ? f(!0) : f(!1)
  }
    , b = () => {
      r()
  }
  ;
  _.useEffect( () => {
      window.addEventListener("scroll", v),
      document.addEventListener("click", h, !0)
  }
  , []);
  const w = S => {
      t.changeLanguage(S)
  }
    , h = S => {
      n.current && (n.current.contains(S.target) || y(!1))
  }
    , g = S => Lo.scrollTo(S, {
      smooth: !0,
      duration: 500,
      offset: -120
  })
    , x = S => {
      u.pathname !== "/coin" && l("/coin"),
      setTimeout( () => {
          g(S)
      }
      , [u.pathname === "/coin" ? 0 : 500])
  }
  ;
  return D.jsx(iL, {
      scrollNav: c,
      children: D.jsxs(sL, {
          children: [D.jsx(aL, {
              to: "/coin",
              onClick: m,
              children: D.jsx(oL, {
                  src: "/images/main/logo.webp",
                  alt: "Logo"
              })
          }), D.jsxs(lL, {
              children: [D.jsx(Ed, {
                  children: D.jsx(cL, {
                      onClick: () => x("howCoin"),
                      children: e("navbar.howItWorks")
                  })
              }), D.jsx(Ed, {
                  children: D.jsx(N1, {
                      to: "/coin/how",
                      children: e("navbar.howToStake")
                  })
              }), D.jsx(Ed, {
                  children: D.jsx(N1, {
                      to: "/coin/calculator",
                      children: e("navbar.calculator")
                  })
              })]
          }), D.jsxs(fL, {
              children: [D.jsxs(pL, {
                  onClick: () => y(!d),
                  ref: n,
                  children: [D.jsxs(hL, {
                      children: [Object.keys(gr).map(S => t.language === S ? D.jsx(j1, {
                          src: gr[S].image
                      }, S) : null), D.jsx(mL, {
                          src: "/images/flags/dropdown.svg"
                      })]
                  }), d && D.jsx(yL, {
                      children: Object.keys(gr).map(S => t.language !== S ? D.jsx(gL, {
                          onClick: () => w(S),
                          children: D.jsx(j1, {
                              src: gr[S].image
                          })
                      }, S) : null)
                  })]
              }), D.jsx(uL, {
                  onClick: () => o(!a),
                  children: D.jsx(BS, {})
              }), D.jsx(dL, {
                  onClick: () => b(),
                  children: s ? XS(i) : e("navbar.connectText")
              })]
          })]
      })
  })
}
, NL = q.aside`
position: fixed;
z-index: 999;
width: 100%;
height: 100%;
background: #09110b;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
top: 0;
left: 0;
transition: 0.3s ease-in-out;
opacity: ${ ({isOpen: e}) => e ? "100%" : "0"};
top: ${ ({isOpen: e}) => e ? "0" : "-100%"};
`
, jL = q(WS)`
color: #fff;
`
, ML = q.div`
position: absolute;
top: 1.2rem;
right: 1.5rem;
background: transparent;
font-size: 2rem;
cursor: pointer;
outline: none;
`
, LL = q.ul`
display: grid;
grid-template-columns: 1fr;
grid-template-rows: repeat(4, 80px);
text-align: center;

@media screen and (max-width: 768px) {
  grid-template-rows: repeat(4, 70px);
}

@media screen and (max-width: 480px) {
  grid-template-rows: repeat(4, 60px);
}
`
, FL = q.div`
margin-top: 25px;
margin-bottom: 25px;
`
, UL = q.div`
border: 10px solid transparent;
border-image: url("/images/nav/navButton.svg") 20 fill;
padding: 5px 20px;
color: #81451e;
font-weight: bold;
white-space: nowrap;
transition: all 0.2s ease-in-out;
font-size: 16px;
margin-left: auto;
margin-right: auto;
width: 100%;
text-align: center;

&:hover {
  cursor: pointer;
  transform: scale(1.05);
  transition: all 0.2s ease-in-out;
}
`;
q.div`
display: flex;
position: relative;
align-items: center;
padding: 0.6rem 0.5rem;
cursor: pointer;
transition: all 0.2s ease-in-out;
max-width: 80px;
margin-left: auto;
margin-right: auto;
margin-top: 10px;
margin-bottom: 10px;
`;
q.div`
display: flex;
flex-direction: row;
align-items: center;
width: 100%;
gap: 0.3rem;
`;
const zL = q.a`
display: flex;
align-items: center;
justify-content: center;
font-size: 1.2rem;
text-decoration: none;
list-style: none;
color: #fff;
cursor: pointer;
transition: 0.2s ease-in-out;

&:hover {
  transition: 0.2s ease-in-out;
  font-weight: bold;
}
`
, M1 = q(Si)`
display: flex;
align-items: center;
justify-content: center;
font-size: 1.2rem;
text-decoration: none;
list-style: none;
color: #fff;
cursor: pointer;
transition: 0.2s ease-in-out;

&:hover {
  transition: 0.2s ease-in-out;
  font-weight: bold;
}
`
, BL = () => {
  const {t: e} = Ci()
    , {open: t} = Mc()
    , {address: n, isConnected: r} = jc()
    , i = vn()
    , s = Is()
    , {sidebarOpen: a, setSidebarOpen: o} = gf()
    , [u,l] = _.useState("")
    , c = () => {
      o(!a)
  }
    , f = () => {
      c(),
      t()
  }
  ;
  _.useEffect( () => {
      if (n) {
          const m = n.slice(-4)
            , v = n.slice(0, 4);
          l(`${v}....${m}`)
      } else
          l("")
  }
  , [n]);
  const d = m => Lo.scrollTo(m, {
      smooth: !0,
      duration: 500,
      offset: -120
  })
    , y = m => {
      i.pathname !== "/coin" && s("/coin"),
      setTimeout( () => {
          d(m)
      }
      , [i.pathname === "/coin" ? 0 : 500])
  }
  ;
  return D.jsxs(NL, {
      isOpen: a,
      onClick: c,
      children: [D.jsx(ML, {
          onClick: c,
          children: D.jsx(jL, {})
      }), D.jsxs(LL, {
          children: [D.jsx(zL, {
              onClick: () => {
                  y("howCoin"),
                  c()
              }
              ,
              children: e("navbar.howItWorks")
          }), D.jsxs(M1, {
              to: "/coin/how",
              onClick: c,
              children: [e("navbar.howToStake"), " "]
          }), D.jsx(M1, {
              to: "/coin/calculator",
              onClick: c,
              children: e("navbar.calculator")
          }), D.jsx(FL, {
              children: D.jsx(UL, {
                  onClick: () => f(),
                  children: r ? u : e("navbar.connectText")
              })
          })]
      })]
  })
}
, WL = q.div`
background: ${ ({change: e}) => e ? "#3B3930" : "linear-gradient(180deg, rgba(5,86,48,1) 0%, rgba(59,57,48,1) 80%)"};
border-top: ${ ({change: e}) => e ? "none" : "1px solid #FCEFDE"};
transition: 1s all ease;
`
, L1 = q.div`
display: flex;
flex-direction: column;
width: 100%;
max-width: 1440px;
margin-left: auto;
margin-right: auto;
justify-content: space-between;
padding: 24px 24px;
padding-top: ${ ({padding: e}) => e ? "50px" : "0"};
padding-bottom: ${ ({padding: e}) => e ? "50px" : "0"};

@media screen and (max-width: 768px) {
  padding-top: ${ ({padding: e}) => e ? "40px" : "0"};
  padding-bottom: ${ ({padding: e}) => e ? "40px" : "0"};
}

@media screen and (max-width: 480px) {
  padding-top: ${ ({padding: e}) => e ? "30px" : "0"};
  padding-bottom: ${ ({padding: e}) => e ? "30px" : "0"};
}
`
, HL = q.div`
display: flex;
flex-direction: row;
gap: 50px;
width: 100%;

@media screen and (max-width: 768px) {
  flex-direction: column;
}
`
, qL = q.div`
display: flex;
justify-content: center;
align-items: center;
width: 100%;
flex-direction: ${ ({row: e}) => e ? "row" : "column"};
gap: ${ ({gap: e}) => e};
`
, VL = q.img`
width: 100%;
max-width: 300px;
height: auto;
cursor: pointer;

@media screen and (max-width: 768px) {
  max-width: 250px;
}

@media screen and (max-width: 480px) {
  max-width: 200px;
}
`
, KL = q.p`
font-size: 16px;
color: #e0d7cc;
font-weight: ${ ({bold: e}) => e ? "bold" : "400"};
text-align: center;
max-width: 1000px;

@media screen and (max-width: 1300px) {
  font-size: 14px;
}

@media screen and (max-width: 768px) {
  font-size: 12px;
}

@media screen and (max-width: 480px) {
  font-size: 11px;
}
`
, GL = q.div`
display: flex;
flex-direction: row;
gap: 20px;

@media screen and (max-width: 768px) {
  gap: 15px;
}

@media screen and (max-width: 480px) {
  gap: 10px;
}
`;
q.div`
display: flex;
flex-direction: column;
gap: 10px;
margin-left: auto;
margin-right: auto;
`;
const bu = q.button`
color: #81451e;
font-weight: bold;
white-space: nowrap;
transition: all 0.2s ease-in-out;
font-size: 16px;
background: transparent;
border: 5px solid;
border-image: url("/images/footer/iconBorder.svg") 12 fill;
aspect-ratio: 1 / 1;
display: flex;
justify-content: center;
align-items: center;
padding: 5px;

:disabled {
  opacity: 0.3;
}

&:hover:not([disabled]) {
  cursor: pointer;
  transform: scale(1.05);
  transition: all 0.2s ease-in-out;
  box-shadow: -10px 10px 0px -4px rgba(0, 0, 0, 0.6);
}

@media screen and (max-width: 480px) {
  padding: 2.5px;
}
`;
q.img`
width: 100%;
max-width: 50px;
min-width: 15px;
height: auto;

@media screen and (max-width: 768px) {
  min-width: 12.5px;
}

@media screen and (max-width: 480px) {
  min-width: 10px;
}
`;
q(FS)`
font-size: 16px;
color: #e0d7cc;
text-decoration: none;

&:hover {
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

@media screen and (max-width: 1300px) {
  font-size: 14px;
}

@media screen and (max-width: 768px) {
  font-size: 12px;
}

@media screen and (max-width: 480px) {
  font-size: 11px;
}
`;
q(Si)`
font-size: 16px;
color: #e0d7cc;
text-decoration: none;

&:hover {
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

@media screen and (max-width: 1300px) {
  font-size: 14px;
}

@media screen and (max-width: 768px) {
  font-size: 12px;
}

@media screen and (max-width: 480px) {
  font-size: 11px;
}
`;
const QL = q.p`
font-size: 14px;
color: rgba(224, 215, 204, 0.5);
margin-left: auto;
margin-right: auto;
padding: 25px;
text-align: center;

@media screen and (max-width: 768px) {
  font-size: 12px;
}

@media screen and (max-width: 480px) {
  font-size: 11px;
}
`
, YL = q.div`
width: 100%;
border-top: 1px solid #fcefde;
`;
q.a`
font-size: 16px;
color: #e0d7cc;
text-decoration: none;

&:hover {
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

@media screen and (max-width: 1300px) {
  font-size: 14px;
}

@media screen and (max-width: 768px) {
  font-size: 12px;
}

@media screen and (max-width: 480px) {
  font-size: 11px;
}
`;
function XL(e) {
  return $s({
      tag: "svg",
      attr: {
          viewBox: "0 0 24 24"
      },
      child: [{
          tag: "path",
          attr: {
              fill: "none",
              d: "M0 0h24v24H0z"
          }
      }, {
          tag: "path",
          attr: {
              d: "M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"
          }
      }]
  })(e)
}
const JS = () => {
  const {t: e} = Ci()
    , t = vn()
    , n = Is()
    , r = () => {
      t.pathname !== "/" && n("/"),
      mf.scrollToTop()
  }
    , i = s => {
      const a = window.open(s, "_blank", "noopener,noreferrer");
      a && (a.opener = null)
  }
  ;
  return D.jsxs(WL, {
      children: [D.jsx(L1, {
          padding: !0,
          children: D.jsx(HL, {
              children: D.jsxs(qL, {
                  gap: "25px",
                  children: [D.jsx(VL, {
                      src: "/images/main/logo.webp",
                      onClick: r
                  }), D.jsx(KL, {
                      children: e("footer.desc")
                  }), D.jsxs(GL, {
                      children: [D.jsx(bu, {
                          onClick: () => {
                              i("https://twitter.com/RealChimpzee")
                          }
                          ,
                          children: D.jsx(RM, {})
                      }), D.jsx(bu, {
                          onClick: () => {
                              i("https://www.instagram.com/chimpzee.io/")
                          }
                          ,
                          children: D.jsx(AM, {})
                      }), D.jsx(bu, {
                          onClick: () => {
                              i("https://t.me/officialchimpzeetelegramgroup")
                          }
                          ,
                          children: D.jsx($M, {})
                      }), D.jsx(bu, {
                          onClick: () => {
                              i("https://www.chimpzee.io/contact")
                          }
                          ,
                          children: D.jsx(XL, {})
                      })]
                  })]
              })
          })
      }), D.jsx(YL, {}), D.jsx(L1, {
          children: D.jsxs(QL, {
              children: ["Copyright  ", new Date().getFullYear(), " Chimpzee. All rights reserved.", D.jsx("br", {}), "1st Floor, Ricardo Arias Street, Panama City, Panama, contact@chimpzee.io"]
          })
      })]
  })
}
, JL = () => D.jsxs(D.Fragment, {
  children: [D.jsx(RL, {}), D.jsx(BL, {}), D.jsx(gS, {}), D.jsx(JS, {})]
})
, ZL = q.nav`
background: ${ ({scrollNav: e}) => e ? "#053821" : "transparent"};
height: 100px;
margin-top: -100px;
display: flex;
justify-content: center;
align-items: center;
font-size: 1rem;
position: sticky;
top: 0;
z-index: 80;
transition: 0.3s all ease;
border-bottom: 1px solid #fcefde;
backdrop-filter: blur(${ ({scrollNav: e}) => e ? "0" : "3px"});

@media screen and (max-width: 960px) {
  transition: 0.4s all ease;
}
`
, eF = q.div`
display: flex;
justify-content: space-between;
height: 100px;
z-index: 1;
width: 100%;
padding: 0 24px;
max-width: 1440px;
`
, tF = q(Si)`
color: #fff;
justify-self: flex-start;
cursor: pointer;
font-size: 1.5rem;
display: flex;
align-items: center;
margin-left: 0;
font-weight: bold;
text-decoration: none;
`
, nF = q.img`
max-width: 300px;
width: 100%;
height: auto;

@media screen and (max-width: 768px) {
  max-width: 230px;
}

@media screen and (max-width: 480px) {
  max-width: 180px;
}

@media screen and (max-width: 320px) {
  max-width: 140px;
}

@media screen and (max-width: 280px) {
  max-width: 100px;
}
`
, rF = q.div`
display: none;

@media screen and (max-width: 1100px) {
  display: flex;
  font-size: 1.8rem;
  cursor: pointer;
  color: #fff;
}
`
, iF = q.ul`
display: flex;
align-items: center;
list-style: none;
text-align: center;
margin-right: 24px;

@media screen and (max-width: 1100px) {
  display: none;
}
`
, Sd = q.li`
height: 100px;
`
, sF = q.a`
color: #fff;
display: flex;
align-items: center;
text-decoration: none;
padding: 0 1.2rem;
height: 100%;
font-size: 16px;
transition: all 0.2s ease-in-out;
white-space: nowrap;

@media screen and (max-width: 1400px) {
  font-size: 14px;
}

&.active {
  border-bottom: 4px solid #fcefde;
}

&:hover {
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}
`
, F1 = q(Si)`
color: #fff;
display: flex;
align-items: center;
text-decoration: none;
padding: 0 1.2rem;
height: 100%;
font-size: 16px;
transition: all 0.2s ease-in-out;
white-space: nowrap;

@media screen and (max-width: 1400px) {
  font-size: 14px;
}

&.active {
  border-bottom: 4px solid #fcefde;
}

&:hover {
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}
`
, aF = q.div`
color: #fff;
display: flex;
align-items: center;
`
, oF = q.button`
padding: 2.5px 20px;
color: #81451e;
font-weight: bold;
white-space: nowrap;
transition: all 0.2s ease-in-out;
font-size: 16px;
background: transparent;
border: 10px solid;
border-image: url("/images/nav/navButton.svg") 12 fill;

:disabled {
  opacity: 0.3;
}

&:hover:not([disabled]) {
  cursor: pointer;
  transform: scale(1.05);
  transition: all 0.2s ease-in-out;
  box-shadow: -10px 10px 0px -4px rgba(0, 0, 0, 0.6);
}

@media screen and (max-width: 1100px) {
  display: none;
}
`
, uF = q.div`
display: flex;
position: relative;
align-items: center;
padding: 0.6rem 0.5rem;
margin-right: 15px;
cursor: pointer;
transition: all 0.2s ease-in-out;

@media screen and (max-width: 1100px) {
  margin-right: 5px;
}
`
, lF = q.div`
display: flex;
flex-direction: row;
align-items: center;
gap: 0.3rem;
`
, cF = q.img`
width: 25px;
height: auto;

@media screen and (max-width: 1100px) {
  width: 18px;
}
`
, U1 = q.img`
height: auto;
width: 35px;

@media screen and (max-width: 1100px) {
  width: 25px;
}

@media screen and (max-width: 480px) {
  width: 20px;
}
`
, fF = q.div`
background: #fff;
position: absolute;
width: 100%;
top: 50px;
left: 0;
cursor: pointer;
transition: all 0.2s ease-in-out;

@media screen and (max-width: 1100px) {
  top: 45px;
}
`
, dF = q.div`
display: flex;
align-items: center;
padding: 0.5rem 1rem;
justify-content: center;
align-items: center;

&:hover {
  background: #cccc;
}
`
, pF = () => {
  const {t: e, i18n: t} = Ci()
    , n = _.useRef(null)
    , {open: r} = Mc()
    , {address: i, isConnected: s} = jc()
    , {sidebarOpen: a, setSidebarOpen: o} = gf()
    , u = vn()
    , l = Is()
    , [c,f] = _.useState(!1);
  _.useState("");
  const [d,y] = _.useState(!1)
    , m = () => {
      u.pathname !== "/nft" && l("/nft"),
      mf.scrollToTop()
  }
    , v = () => {
      window.scrollY >= 100 ? f(!0) : f(!1)
  }
    , b = () => {
      r()
  }
  ;
  _.useEffect( () => {
      window.addEventListener("scroll", v),
      document.addEventListener("click", h, !0)
  }
  , []);
  const w = S => {
      t.changeLanguage(S)
  }
    , h = S => {
      n.current && (n.current.contains(S.target) || y(!1))
  }
    , g = S => Lo.scrollTo(S, {
      smooth: !0,
      duration: 500,
      offset: -120
  })
    , x = S => {
      u.pathname !== "/nft" && l("/nft"),
      setTimeout( () => {
          g(S)
      }
      , [u.pathname === "/nft" ? 0 : 500])
  }
  ;
  return D.jsx(ZL, {
      scrollNav: c,
      children: D.jsxs(eF, {
          children: [D.jsx(tF, {
              to: "/nft",
              onClick: m,
              children: D.jsx(nF, {
                  src: "/images/main/logo.webp",
                  alt: "Logo"
              })
          }), D.jsxs(iF, {
              children: [D.jsx(Sd, {
                  children: D.jsx(sF, {
                      onClick: () => x("howCoin"),
                      children: e("navbar.howItWorks")
                  })
              }), D.jsx(Sd, {
                  children: D.jsx(F1, {
                      to: "/nft/how",
                      children: e("navbar.howToStake")
                  })
              }), D.jsx(Sd, {
                  children: D.jsx(F1, {
                      to: "/nft/calculator",
                      children: e("navbar.calculator")
                  })
              })]
          }), D.jsxs(aF, {
              children: [D.jsxs(uF, {
                  onClick: () => y(!d),
                  ref: n,
                  children: [D.jsxs(lF, {
                      children: [Object.keys(gr).map(S => t.language === S ? D.jsx(U1, {
                          src: gr[S].image
                      }, S) : null), D.jsx(cF, {
                          src: "/images/flags/dropdown.svg"
                      })]
                  }), d && D.jsx(fF, {
                      children: Object.keys(gr).map(S => t.language !== S ? D.jsx(dF, {
                          onClick: () => w(S),
                          children: D.jsx(U1, {
                              src: gr[S].image
                          })
                      }, S) : null)
                  })]
              }), D.jsx(rF, {
                  onClick: () => o(!a),
                  children: D.jsx(BS, {})
              }), D.jsx(oF, {
                  onClick: () => b(),
                  children: s ? XS(i) : e("navbar.connectText")
              })]
          })]
      })
  })
}
, hF = q.aside`
position: fixed;
z-index: 999;
width: 100%;
height: 100%;
background: #09110b;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
top: 0;
left: 0;
transition: 0.3s ease-in-out;
opacity: ${ ({isOpen: e}) => e ? "100%" : "0"};
top: ${ ({isOpen: e}) => e ? "0" : "-100%"};
`
, mF = q(WS)`
color: #fff;
`
, yF = q.div`
position: absolute;
top: 1.2rem;
right: 1.5rem;
background: transparent;
font-size: 2rem;
cursor: pointer;
outline: none;
`
, gF = q.ul`
display: grid;
grid-template-columns: 1fr;
grid-template-rows: repeat(4, 80px);
text-align: center;

@media screen and (max-width: 768px) {
  grid-template-rows: repeat(4, 70px);
}

@media screen and (max-width: 480px) {
  grid-template-rows: repeat(4, 60px);
}
`
, vF = q.div`
margin-top: 25px;
margin-bottom: 25px;
`
, wF = q.div`
border: 10px solid transparent;
border-image: url("/images/nav/navButton.svg") 20 fill;
padding: 5px 20px;
color: #81451e;
font-weight: bold;
white-space: nowrap;
transition: all 0.2s ease-in-out;
font-size: 16px;
margin-left: auto;
margin-right: auto;
width: 100%;
text-align: center;

&:hover {
  cursor: pointer;
  transform: scale(1.05);
  transition: all 0.2s ease-in-out;
}
`;
q.div`
display: flex;
position: relative;
align-items: center;
padding: 0.6rem 0.5rem;
cursor: pointer;
transition: all 0.2s ease-in-out;
max-width: 80px;
margin-left: auto;
margin-right: auto;
margin-top: 10px;
margin-bottom: 10px;
`;
q.div`
display: flex;
flex-direction: row;
align-items: center;
width: 100%;
gap: 0.3rem;
`;
const bF = q.a`
display: flex;
align-items: center;
justify-content: center;
font-size: 1.2rem;
text-decoration: none;
list-style: none;
color: #fff;
cursor: pointer;
transition: 0.2s ease-in-out;

&:hover {
  transition: 0.2s ease-in-out;
  font-weight: bold;
}
`
, z1 = q(Si)`
display: flex;
align-items: center;
justify-content: center;
font-size: 1.2rem;
text-decoration: none;
list-style: none;
color: #fff;
cursor: pointer;
transition: 0.2s ease-in-out;

&:hover {
  transition: 0.2s ease-in-out;
  font-weight: bold;
}
`
, xF = () => {
  const {t: e} = Ci()
    , {open: t} = Mc()
    , {address: n, isConnected: r} = jc()
    , i = vn()
    , s = Is()
    , {sidebarOpen: a, setSidebarOpen: o} = gf()
    , [u,l] = _.useState("")
    , c = () => {
      o(!a)
  }
    , f = () => {
      c(),
      t()
  }
  ;
  _.useEffect( () => {
      if (n) {
          const m = n.slice(-4)
            , v = n.slice(0, 4);
          l(`${v}....${m}`)
      } else
          l("")
  }
  , [n]);
  const d = m => Lo.scrollTo(m, {
      smooth: !0,
      duration: 500,
      offset: -120
  })
    , y = m => {
      i.pathname !== "/nft" && s("/nft"),
      setTimeout( () => {
          d(m)
      }
      , [i.pathname === "/nft" ? 0 : 500])
  }
  ;
  return D.jsxs(hF, {
      isOpen: a,
      onClick: c,
      children: [D.jsx(yF, {
          onClick: c,
          children: D.jsx(mF, {})
      }), D.jsxs(gF, {
          children: [D.jsx(bF, {
              onClick: () => {
                  y("howCoin"),
                  c()
              }
              ,
              children: e("navbar.howItWorks")
          }), D.jsxs(z1, {
              to: "/nft/how",
              onClick: c,
              children: [e("navbar.howToStake"), " "]
          }), D.jsx(z1, {
              to: "/nft/calculator",
              onClick: c,
              children: e("navbar.calculator")
          }), D.jsx(vF, {
              children: D.jsx(wF, {
                  onClick: () => f(),
                  children: r ? u : e("navbar.connectText")
              })
          })]
      })]
  })
}
, EF = () => D.jsxs(D.Fragment, {
  children: [D.jsx(pF, {}), D.jsx(xF, {}), D.jsx(gS, {}), D.jsx(JS, {})]
})
, SF = _.lazy( () => sn( () => import("./homePage-DKfpsCOH.js"), __vite__mapDeps([6, 7])))
, CF = _.lazy( () => sn( () => import("./coinPage-63hLAocb.js"), __vite__mapDeps([8, 9, 5, 1, 10, 7, 11, 12])))
, _F = _.lazy( () => sn( () => import("./nftPage-S85uj0_8.js"), __vite__mapDeps([13, 9, 5, 1, 11, 12, 7])))
, PF = _.lazy( () => sn( () => import("./notFoundPage-q1u3iSrS.js"), __vite__mapDeps([14, 7])))
, TF = _.lazy( () => sn( () => import("./coinCalculatorPage-iiEAYnHf.js"), __vite__mapDeps([15, 10, 9, 5, 1, 12, 7])))
, OF = _.lazy( () => sn( () => import("./nftCalculatorPage-WjYO7Mnp.js"), __vite__mapDeps([16, 12, 7])))
, kF = _.lazy( () => sn( () => import("./coinHowPage-A-sbroE9.js"), __vite__mapDeps([17, 11, 7])))
, DF = _.lazy( () => sn( () => import("./nftHowPage-lR5__HNK.js"), __vite__mapDeps([18, 11, 7])))
, IF = () => {
  const e = vn();
  return D.jsx(_.Suspense, {
      fallback: D.jsx(vh, {}),
      children: D.jsx(DN, {
          mode: "wait",
          children: D.jsxs(vS, {
              location: e,
              children: [D.jsx(_t, {
                  path: "/",
                  element: D.jsx(SF, {})
              }), D.jsx(_t, {
                  element: D.jsx(JL, {}),
                  children: D.jsxs(_t, {
                      path: "coin",
                      children: [D.jsx(_t, {
                          index: !0,
                          element: D.jsx(CF, {})
                      }), D.jsx(_t, {
                          path: "calculator",
                          element: D.jsx(TF, {})
                      }), D.jsx(_t, {
                          path: "how",
                          element: D.jsx(kF, {})
                      })]
                  })
              }), D.jsx(_t, {
                  element: D.jsx(EF, {}),
                  children: D.jsxs(_t, {
                      path: "nft",
                      children: [D.jsx(_t, {
                          index: !0,
                          element: D.jsx(_F, {})
                      }), D.jsx(_t, {
                          path: "calculator",
                          element: D.jsx(OF, {})
                      }), D.jsx(_t, {
                          path: "how",
                          element: D.jsx(DF, {})
                      })]
                  })
              }), D.jsx(_t, {
                  path: "*",
                  element: D.jsx(PF, {})
              })]
          }, e.pathname)
      })
  })
}
;
var AF = {
  VITE_PROJECT_ID: "f4686537b0b93c1046822fa05ee9cd6b",
  VITE_INFURA_KEY_TEST: "8060915499804bc1824877fa4a120d56",
  VITE_INFURA_KEY: "b6b73456fee04e7882dd2115e4116860",
  BASE_URL: "/",
  MODE: "production",
  DEV: !1,
  PROD: !0,
  SSR: !1
};
const Ky = [jx]
, ZS = "f4686537b0b93c1046822fa05ee9cd6b"
, {publicClient: $F} = _O(Ky, [Tk({
  apiKey: "b6b73456fee04e7882dd2115e4116860"
}), Ok()])
, e6 = ik({
  autoConnect: !0,
  connectors: sA({
      projectId: ZS,
      chains: Ky
  }),
  publicClient: $F
})
, RF = new iA(e6,Ky);
function NF() {
  const e = AF.NODE_ENV === "production";
  return D.jsx(GE, {
      currentVersion: f$.version,
      isEnabled: e,
      loadingComponent: D.jsx(vh, {}),
      children: D.jsxs(_.Suspense, {
          fallback: D.jsx(vh, {}),
          children: [D.jsxs(sk, {
              config: e6,
              children: [D.jsx(pN, {}), D.jsx(IF, {}), D.jsx(QA, {
                  position: "bottom-center",
                  reverseOrder: !1
              })]
          }), D.jsx(c8, {
              projectId: ZS,
              ethereumClient: RF,
              themeMode: "light",
              themeVariables: {
                  "--w3m-accent-color": "#066539",
                  "--w3m-accent-fill-color": "#fff",
                  "--w3m-background-color": "#066539",
                  "--w3m-color-fg-1": "#08070C",
                  "--w3m-color-fg-2": "#707070",
                  "--w3m-color-fg-3": "#707070",
                  "--w3m-color-bg-1": "#FCEFDE",
                  "--w3m-color-bg-2": "#c9bdac",
                  "--fcc-background": "#81451E",
                  "--fcc-label-color": "#81451E",
                  "--fcc-separator-size": "4px",
                  "--fcc-separator-color": "#D9C7BB"
              }
          })]
      })
  })
}
const jF = {
  type: "logger",
  log(e) {
      this.output("log", e)
  },
  warn(e) {
      this.output("warn", e)
  },
  error(e) {
      this.output("error", e)
  },
  output(e, t) {
      console && console[e] && console[e].apply(console, t)
  }
};
class ql {
  constructor(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.init(t, n)
  }
  init(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = n.prefix || "i18next:",
      this.logger = t || jF,
      this.options = n,
      this.debug = n.debug
  }
  log() {
      for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
          n[r] = arguments[r];
      return this.forward(n, "log", "", !0)
  }
  warn() {
      for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
          n[r] = arguments[r];
      return this.forward(n, "warn", "", !0)
  }
  error() {
      for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
          n[r] = arguments[r];
      return this.forward(n, "error", "")
  }
  deprecate() {
      for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
          n[r] = arguments[r];
      return this.forward(n, "warn", "WARNING DEPRECATED: ", !0)
  }
  forward(t, n, r, i) {
      return i && !this.debug ? null : (typeof t[0] == "string" && (t[0] = `${r}${this.prefix} ${t[0]}`),
      this.logger[n](t))
  }
  create(t) {
      return new ql(this.logger,{
          prefix: `${this.prefix}:${t}:`,
          ...this.options
      })
  }
  clone(t) {
      return t = t || this.options,
      t.prefix = t.prefix || this.prefix,
      new ql(this.logger,t)
  }
}
var Pn = new ql;
class vf {
  constructor() {
      this.observers = {}
  }
  on(t, n) {
      return t.split(" ").forEach(r => {
          this.observers[r] = this.observers[r] || [],
          this.observers[r].push(n)
      }
      ),
      this
  }
  off(t, n) {
      if (this.observers[t]) {
          if (!n) {
              delete this.observers[t];
              return
          }
          this.observers[t] = this.observers[t].filter(r => r !== n)
      }
  }
  emit(t) {
      for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
          r[i - 1] = arguments[i];
      this.observers[t] && [].concat(this.observers[t]).forEach(a => {
          a(...r)
      }
      ),
      this.observers["*"] && [].concat(this.observers["*"]).forEach(a => {
          a.apply(a, [t, ...r])
      }
      )
  }
}
function Gs() {
  let e, t;
  const n = new Promise( (r, i) => {
      e = r,
      t = i
  }
  );
  return n.resolve = e,
  n.reject = t,
  n
}
function B1(e) {
  return e == null ? "" : "" + e
}
function MF(e, t, n) {
  e.forEach(r => {
      t[r] && (n[r] = t[r])
  }
  )
}
function Gy(e, t, n) {
  function r(a) {
      return a && a.indexOf("###") > -1 ? a.replace(/###/g, ".") : a
  }
  function i() {
      return !e || typeof e == "string"
  }
  const s = typeof t != "string" ? [].concat(t) : t.split(".");
  for (; s.length > 1; ) {
      if (i())
          return {};
      const a = r(s.shift());
      !e[a] && n && (e[a] = new n),
      Object.prototype.hasOwnProperty.call(e, a) ? e = e[a] : e = {}
  }
  return i() ? {} : {
      obj: e,
      k: r(s.shift())
  }
}
function W1(e, t, n) {
  const {obj: r, k: i} = Gy(e, t, Object);
  r[i] = n
}
function LF(e, t, n, r) {
  const {obj: i, k: s} = Gy(e, t, Object);
  i[s] = i[s] || [],
  r && (i[s] = i[s].concat(n)),
  r || i[s].push(n)
}
function Vl(e, t) {
  const {obj: n, k: r} = Gy(e, t);
  if (n)
      return n[r]
}
function FF(e, t, n) {
  const r = Vl(e, n);
  return r !== void 0 ? r : Vl(t, n)
}
function t6(e, t, n) {
  for (const r in t)
      r !== "__proto__" && r !== "constructor" && (r in e ? typeof e[r] == "string" || e[r]instanceof String || typeof t[r] == "string" || t[r]instanceof String ? n && (e[r] = t[r]) : t6(e[r], t[r], n) : e[r] = t[r]);
  return e
}
function Di(e) {
  return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
}
var UF = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function zF(e) {
  return typeof e == "string" ? e.replace(/[&<>"'\/]/g, t => UF[t]) : e
}
const BF = [" ", ",", "?", "!", ";"];
function WF(e, t, n) {
  t = t || "",
  n = n || "";
  const r = BF.filter(a => t.indexOf(a) < 0 && n.indexOf(a) < 0);
  if (r.length === 0)
      return !0;
  const i = new RegExp(`(${r.map(a => a === "?" ? "\\?" : a).join("|")})`);
  let s = !i.test(e);
  if (!s) {
      const a = e.indexOf(n);
      a > 0 && !i.test(e.substring(0, a)) && (s = !0)
  }
  return s
}
function Kl(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!e)
      return;
  if (e[t])
      return e[t];
  const r = t.split(n);
  let i = e;
  for (let s = 0; s < r.length; ++s) {
      if (!i || typeof i[r[s]] == "string" && s + 1 < r.length)
          return;
      if (i[r[s]] === void 0) {
          let a = 2
            , o = r.slice(s, s + a).join(n)
            , u = i[o];
          for (; u === void 0 && r.length > s + a; )
              a++,
              o = r.slice(s, s + a).join(n),
              u = i[o];
          if (u === void 0)
              return;
          if (u === null)
              return null;
          if (t.endsWith(o)) {
              if (typeof u == "string")
                  return u;
              if (o && typeof u[o] == "string")
                  return u[o]
          }
          const l = r.slice(s + a).join(n);
          return l ? Kl(u, l, n) : void 0
      }
      i = i[r[s]]
  }
  return i
}
function Gl(e) {
  return e && e.indexOf("_") > 0 ? e.replace("_", "-") : e
}
class H1 extends vf {
  constructor(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          ns: ["translation"],
          defaultNS: "translation"
      };
      super(),
      this.data = t || {},
      this.options = n,
      this.options.keySeparator === void 0 && (this.options.keySeparator = "."),
      this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0)
  }
  addNamespaces(t) {
      this.options.ns.indexOf(t) < 0 && this.options.ns.push(t)
  }
  removeNamespaces(t) {
      const n = this.options.ns.indexOf(t);
      n > -1 && this.options.ns.splice(n, 1)
  }
  getResource(t, n, r) {
      let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const s = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator
        , a = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
      let o = [t, n];
      r && typeof r != "string" && (o = o.concat(r)),
      r && typeof r == "string" && (o = o.concat(s ? r.split(s) : r)),
      t.indexOf(".") > -1 && (o = t.split("."));
      const u = Vl(this.data, o);
      return u || !a || typeof r != "string" ? u : Kl(this.data && this.data[t] && this.data[t][n], r, s)
  }
  addResource(t, n, r, i) {
      let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
          silent: !1
      };
      const a = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator;
      let o = [t, n];
      r && (o = o.concat(a ? r.split(a) : r)),
      t.indexOf(".") > -1 && (o = t.split("."),
      i = n,
      n = o[1]),
      this.addNamespaces(n),
      W1(this.data, o, i),
      s.silent || this.emit("added", t, n, r, i)
  }
  addResources(t, n, r) {
      let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
          silent: !1
      };
      for (const s in r)
          (typeof r[s] == "string" || Object.prototype.toString.apply(r[s]) === "[object Array]") && this.addResource(t, n, s, r[s], {
              silent: !0
          });
      i.silent || this.emit("added", t, n, r)
  }
  addResourceBundle(t, n, r, i, s) {
      let a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
          silent: !1
      }
        , o = [t, n];
      t.indexOf(".") > -1 && (o = t.split("."),
      i = r,
      r = n,
      n = o[1]),
      this.addNamespaces(n);
      let u = Vl(this.data, o) || {};
      i ? t6(u, r, s) : u = {
          ...u,
          ...r
      },
      W1(this.data, o, u),
      a.silent || this.emit("added", t, n, r)
  }
  removeResourceBundle(t, n) {
      this.hasResourceBundle(t, n) && delete this.data[t][n],
      this.removeNamespaces(n),
      this.emit("removed", t, n)
  }
  hasResourceBundle(t, n) {
      return this.getResource(t, n) !== void 0
  }
  getResourceBundle(t, n) {
      return n || (n = this.options.defaultNS),
      this.options.compatibilityAPI === "v1" ? {
          ...this.getResource(t, n)
      } : this.getResource(t, n)
  }
  getDataByLanguage(t) {
      return this.data[t]
  }
  hasLanguageSomeTranslations(t) {
      const n = this.getDataByLanguage(t);
      return !!(n && Object.keys(n) || []).find(i => n[i] && Object.keys(n[i]).length > 0)
  }
  toJSON() {
      return this.data
  }
}
var n6 = {
  processors: {},
  addPostProcessor(e) {
      this.processors[e.name] = e
  },
  handle(e, t, n, r, i) {
      return e.forEach(s => {
          this.processors[s] && (t = this.processors[s].process(t, n, r, i))
      }
      ),
      t
  }
};
const q1 = {};
class Ql extends vf {
  constructor(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(),
      MF(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, this),
      this.options = n,
      this.options.keySeparator === void 0 && (this.options.keySeparator = "."),
      this.logger = Pn.create("translator")
  }
  changeLanguage(t) {
      t && (this.language = t)
  }
  exists(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          interpolation: {}
      };
      if (t == null)
          return !1;
      const r = this.resolve(t, n);
      return r && r.res !== void 0
  }
  extractFromKey(t, n) {
      let r = n.nsSeparator !== void 0 ? n.nsSeparator : this.options.nsSeparator;
      r === void 0 && (r = ":");
      const i = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator;
      let s = n.ns || this.options.defaultNS || [];
      const a = r && t.indexOf(r) > -1
        , o = !this.options.userDefinedKeySeparator && !n.keySeparator && !this.options.userDefinedNsSeparator && !n.nsSeparator && !WF(t, r, i);
      if (a && !o) {
          const u = t.match(this.interpolator.nestingRegexp);
          if (u && u.length > 0)
              return {
                  key: t,
                  namespaces: s
              };
          const l = t.split(r);
          (r !== i || r === i && this.options.ns.indexOf(l[0]) > -1) && (s = l.shift()),
          t = l.join(i)
      }
      return typeof s == "string" && (s = [s]),
      {
          key: t,
          namespaces: s
      }
  }
  translate(t, n, r) {
      if (typeof n != "object" && this.options.overloadTranslationOptionHandler && (n = this.options.overloadTranslationOptionHandler(arguments)),
      typeof n == "object" && (n = {
          ...n
      }),
      n || (n = {}),
      t == null)
          return "";
      Array.isArray(t) || (t = [String(t)]);
      const i = n.returnDetails !== void 0 ? n.returnDetails : this.options.returnDetails
        , s = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator
        , {key: a, namespaces: o} = this.extractFromKey(t[t.length - 1], n)
        , u = o[o.length - 1]
        , l = n.lng || this.language
        , c = n.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (l && l.toLowerCase() === "cimode") {
          if (c) {
              const x = n.nsSeparator || this.options.nsSeparator;
              return i ? {
                  res: `${u}${x}${a}`,
                  usedKey: a,
                  exactUsedKey: a,
                  usedLng: l,
                  usedNS: u,
                  usedParams: this.getUsedParamsDetails(n)
              } : `${u}${x}${a}`
          }
          return i ? {
              res: a,
              usedKey: a,
              exactUsedKey: a,
              usedLng: l,
              usedNS: u,
              usedParams: this.getUsedParamsDetails(n)
          } : a
      }
      const f = this.resolve(t, n);
      let d = f && f.res;
      const y = f && f.usedKey || a
        , m = f && f.exactUsedKey || a
        , v = Object.prototype.toString.apply(d)
        , b = ["[object Number]", "[object Function]", "[object RegExp]"]
        , w = n.joinArrays !== void 0 ? n.joinArrays : this.options.joinArrays
        , h = !this.i18nFormat || this.i18nFormat.handleAsObject;
      if (h && d && (typeof d != "string" && typeof d != "boolean" && typeof d != "number") && b.indexOf(v) < 0 && !(typeof w == "string" && v === "[object Array]")) {
          if (!n.returnObjects && !this.options.returnObjects) {
              this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
              const x = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(y, d, {
                  ...n,
                  ns: o
              }) : `key '${a} (${this.language})' returned an object instead of string.`;
              return i ? (f.res = x,
              f.usedParams = this.getUsedParamsDetails(n),
              f) : x
          }
          if (s) {
              const x = v === "[object Array]"
                , S = x ? [] : {}
                , E = x ? m : y;
              for (const p in d)
                  if (Object.prototype.hasOwnProperty.call(d, p)) {
                      const C = `${E}${s}${p}`;
                      S[p] = this.translate(C, {
                          ...n,
                          joinArrays: !1,
                          ns: o
                      }),
                      S[p] === C && (S[p] = d[p])
                  }
              d = S
          }
      } else if (h && typeof w == "string" && v === "[object Array]")
          d = d.join(w),
          d && (d = this.extendTranslation(d, t, n, r));
      else {
          let x = !1
            , S = !1;
          const E = n.count !== void 0 && typeof n.count != "string"
            , p = Ql.hasDefaultValue(n)
            , C = E ? this.pluralResolver.getSuffix(l, n.count, n) : ""
            , T = n.ordinal && E ? this.pluralResolver.getSuffix(l, n.count, {
              ordinal: !1
          }) : ""
            , O = n[`defaultValue${C}`] || n[`defaultValue${T}`] || n.defaultValue;
          !this.isValidLookup(d) && p && (x = !0,
          d = O),
          this.isValidLookup(d) || (S = !0,
          d = a);
          const j = (n.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && S ? void 0 : d
            , L = p && O !== d && this.options.updateMissing;
          if (S || x || L) {
              if (this.logger.log(L ? "updateKey" : "missingKey", l, u, a, L ? O : d),
              s) {
                  const $ = this.resolve(a, {
                      ...n,
                      keySeparator: !1
                  });
                  $ && $.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
              }
              let M = [];
              const P = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n.lng || this.language);
              if (this.options.saveMissingTo === "fallback" && P && P[0])
                  for (let $ = 0; $ < P.length; $++)
                      M.push(P[$]);
              else
                  this.options.saveMissingTo === "all" ? M = this.languageUtils.toResolveHierarchy(n.lng || this.language) : M.push(n.lng || this.language);
              const A = ($, I, W) => {
                  const B = p && W !== d ? W : j;
                  this.options.missingKeyHandler ? this.options.missingKeyHandler($, u, I, B, L, n) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing($, u, I, B, L, n),
                  this.emit("missingKey", $, u, I, d)
              }
              ;
              this.options.saveMissing && (this.options.saveMissingPlurals && E ? M.forEach($ => {
                  this.pluralResolver.getSuffixes($, n).forEach(I => {
                      A([$], a + I, n[`defaultValue${I}`] || O)
                  }
                  )
              }
              ) : A(M, a, O))
          }
          d = this.extendTranslation(d, t, n, f, r),
          S && d === a && this.options.appendNamespaceToMissingKey && (d = `${u}:${a}`),
          (S || x) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? d = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${u}:${a}` : a, x ? d : void 0) : d = this.options.parseMissingKeyHandler(d))
      }
      return i ? (f.res = d,
      f.usedParams = this.getUsedParamsDetails(n),
      f) : d
  }
  extendTranslation(t, n, r, i, s) {
      var a = this;
      if (this.i18nFormat && this.i18nFormat.parse)
          t = this.i18nFormat.parse(t, {
              ...this.options.interpolation.defaultVariables,
              ...r
          }, r.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
              resolved: i
          });
      else if (!r.skipInterpolation) {
          r.interpolation && this.interpolator.init({
              ...r,
              interpolation: {
                  ...this.options.interpolation,
                  ...r.interpolation
              }
          });
          const l = typeof t == "string" && (r && r.interpolation && r.interpolation.skipOnVariables !== void 0 ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
          let c;
          if (l) {
              const d = t.match(this.interpolator.nestingRegexp);
              c = d && d.length
          }
          let f = r.replace && typeof r.replace != "string" ? r.replace : r;
          if (this.options.interpolation.defaultVariables && (f = {
              ...this.options.interpolation.defaultVariables,
              ...f
          }),
          t = this.interpolator.interpolate(t, f, r.lng || this.language, r),
          l) {
              const d = t.match(this.interpolator.nestingRegexp)
                , y = d && d.length;
              c < y && (r.nest = !1)
          }
          !r.lng && this.options.compatibilityAPI !== "v1" && i && i.res && (r.lng = i.usedLng),
          r.nest !== !1 && (t = this.interpolator.nest(t, function() {
              for (var d = arguments.length, y = new Array(d), m = 0; m < d; m++)
                  y[m] = arguments[m];
              return s && s[0] === y[0] && !r.context ? (a.logger.warn(`It seems you are nesting recursively key: ${y[0]} in key: ${n[0]}`),
              null) : a.translate(...y, n)
          }, r)),
          r.interpolation && this.interpolator.reset()
      }
      const o = r.postProcess || this.options.postProcess
        , u = typeof o == "string" ? [o] : o;
      return t != null && u && u.length && r.applyPostProcessor !== !1 && (t = n6.handle(u, t, n, this.options && this.options.postProcessPassResolved ? {
          i18nResolved: {
              ...i,
              usedParams: this.getUsedParamsDetails(r)
          },
          ...r
      } : r, this)),
      t
  }
  resolve(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r, i, s, a, o;
      return typeof t == "string" && (t = [t]),
      t.forEach(u => {
          if (this.isValidLookup(r))
              return;
          const l = this.extractFromKey(u, n)
            , c = l.key;
          i = c;
          let f = l.namespaces;
          this.options.fallbackNS && (f = f.concat(this.options.fallbackNS));
          const d = n.count !== void 0 && typeof n.count != "string"
            , y = d && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi()
            , m = n.context !== void 0 && (typeof n.context == "string" || typeof n.context == "number") && n.context !== ""
            , v = n.lngs ? n.lngs : this.languageUtils.toResolveHierarchy(n.lng || this.language, n.fallbackLng);
          f.forEach(b => {
              this.isValidLookup(r) || (o = b,
              !q1[`${v[0]}-${b}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(o) && (q1[`${v[0]}-${b}`] = !0,
              this.logger.warn(`key "${i}" for languages "${v.join(", ")}" won't get resolved as namespace "${o}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),
              v.forEach(w => {
                  if (this.isValidLookup(r))
                      return;
                  a = w;
                  const h = [c];
                  if (this.i18nFormat && this.i18nFormat.addLookupKeys)
                      this.i18nFormat.addLookupKeys(h, c, w, b, n);
                  else {
                      let x;
                      d && (x = this.pluralResolver.getSuffix(w, n.count, n));
                      const S = `${this.options.pluralSeparator}zero`
                        , E = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                      if (d && (h.push(c + x),
                      n.ordinal && x.indexOf(E) === 0 && h.push(c + x.replace(E, this.options.pluralSeparator)),
                      y && h.push(c + S)),
                      m) {
                          const p = `${c}${this.options.contextSeparator}${n.context}`;
                          h.push(p),
                          d && (h.push(p + x),
                          n.ordinal && x.indexOf(E) === 0 && h.push(p + x.replace(E, this.options.pluralSeparator)),
                          y && h.push(p + S))
                      }
                  }
                  let g;
                  for (; g = h.pop(); )
                      this.isValidLookup(r) || (s = g,
                      r = this.getResource(w, b, g, n))
              }
              ))
          }
          )
      }
      ),
      {
          res: r,
          usedKey: i,
          exactUsedKey: s,
          usedLng: a,
          usedNS: o
      }
  }
  isValidLookup(t) {
      return t !== void 0 && !(!this.options.returnNull && t === null) && !(!this.options.returnEmptyString && t === "")
  }
  getResource(t, n, r) {
      let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(t, n, r, i) : this.resourceStore.getResource(t, n, r, i)
  }
  getUsedParamsDetails() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const n = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"]
        , r = t.replace && typeof t.replace != "string";
      let i = r ? t.replace : t;
      if (r && typeof t.count < "u" && (i.count = t.count),
      this.options.interpolation.defaultVariables && (i = {
          ...this.options.interpolation.defaultVariables,
          ...i
      }),
      !r) {
          i = {
              ...i
          };
          for (const s of n)
              delete i[s]
      }
      return i
  }
  static hasDefaultValue(t) {
      const n = "defaultValue";
      for (const r in t)
          if (Object.prototype.hasOwnProperty.call(t, r) && n === r.substring(0, n.length) && t[r] !== void 0)
              return !0;
      return !1
  }
}
function Cd(e) {
  return e.charAt(0).toUpperCase() + e.slice(1)
}
class V1 {
  constructor(t) {
      this.options = t,
      this.supportedLngs = this.options.supportedLngs || !1,
      this.logger = Pn.create("languageUtils")
  }
  getScriptPartFromCode(t) {
      if (t = Gl(t),
      !t || t.indexOf("-") < 0)
          return null;
      const n = t.split("-");
      return n.length === 2 || (n.pop(),
      n[n.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(n.join("-"))
  }
  getLanguagePartFromCode(t) {
      if (t = Gl(t),
      !t || t.indexOf("-") < 0)
          return t;
      const n = t.split("-");
      return this.formatLanguageCode(n[0])
  }
  formatLanguageCode(t) {
      if (typeof t == "string" && t.indexOf("-") > -1) {
          const n = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
          let r = t.split("-");
          return this.options.lowerCaseLng ? r = r.map(i => i.toLowerCase()) : r.length === 2 ? (r[0] = r[0].toLowerCase(),
          r[1] = r[1].toUpperCase(),
          n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = Cd(r[1].toLowerCase()))) : r.length === 3 && (r[0] = r[0].toLowerCase(),
          r[1].length === 2 && (r[1] = r[1].toUpperCase()),
          r[0] !== "sgn" && r[2].length === 2 && (r[2] = r[2].toUpperCase()),
          n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = Cd(r[1].toLowerCase())),
          n.indexOf(r[2].toLowerCase()) > -1 && (r[2] = Cd(r[2].toLowerCase()))),
          r.join("-")
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t
  }
  isSupportedCode(t) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)),
      !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1
  }
  getBestMatchFromCodes(t) {
      if (!t)
          return null;
      let n;
      return t.forEach(r => {
          if (n)
              return;
          const i = this.formatLanguageCode(r);
          (!this.options.supportedLngs || this.isSupportedCode(i)) && (n = i)
      }
      ),
      !n && this.options.supportedLngs && t.forEach(r => {
          if (n)
              return;
          const i = this.getLanguagePartFromCode(r);
          if (this.isSupportedCode(i))
              return n = i;
          n = this.options.supportedLngs.find(s => {
              if (s === i)
                  return s;
              if (!(s.indexOf("-") < 0 && i.indexOf("-") < 0) && s.indexOf(i) === 0)
                  return s
          }
          )
      }
      ),
      n || (n = this.getFallbackCodes(this.options.fallbackLng)[0]),
      n
  }
  getFallbackCodes(t, n) {
      if (!t)
          return [];
      if (typeof t == "function" && (t = t(n)),
      typeof t == "string" && (t = [t]),
      Object.prototype.toString.apply(t) === "[object Array]")
          return t;
      if (!n)
          return t.default || [];
      let r = t[n];
      return r || (r = t[this.getScriptPartFromCode(n)]),
      r || (r = t[this.formatLanguageCode(n)]),
      r || (r = t[this.getLanguagePartFromCode(n)]),
      r || (r = t.default),
      r || []
  }
  toResolveHierarchy(t, n) {
      const r = this.getFallbackCodes(n || this.options.fallbackLng || [], t)
        , i = []
        , s = a => {
          a && (this.isSupportedCode(a) ? i.push(a) : this.logger.warn(`rejecting language code not found in supportedLngs: ${a}`))
      }
      ;
      return typeof t == "string" && (t.indexOf("-") > -1 || t.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && s(this.formatLanguageCode(t)),
      this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && s(this.getScriptPartFromCode(t)),
      this.options.load !== "currentOnly" && s(this.getLanguagePartFromCode(t))) : typeof t == "string" && s(this.formatLanguageCode(t)),
      r.forEach(a => {
          i.indexOf(a) < 0 && s(this.formatLanguageCode(a))
      }
      ),
      i
  }
}
let HF = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}]
, qF = {
  1: function(e) {
      return +(e > 1)
  },
  2: function(e) {
      return +(e != 1)
  },
  3: function(e) {
      return 0
  },
  4: function(e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
  },
  5: function(e) {
      return e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5
  },
  6: function(e) {
      return e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2
  },
  7: function(e) {
      return e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
  },
  8: function(e) {
      return e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3
  },
  9: function(e) {
      return +(e >= 2)
  },
  10: function(e) {
      return e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4
  },
  11: function(e) {
      return e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3
  },
  12: function(e) {
      return +(e % 10 != 1 || e % 100 == 11)
  },
  13: function(e) {
      return +(e !== 0)
  },
  14: function(e) {
      return e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3
  },
  15: function(e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
  },
  16: function(e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2
  },
  17: function(e) {
      return e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1
  },
  18: function(e) {
      return e == 0 ? 0 : e == 1 ? 1 : 2
  },
  19: function(e) {
      return e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3
  },
  20: function(e) {
      return e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2
  },
  21: function(e) {
      return e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0
  },
  22: function(e) {
      return e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3
  }
};
const VF = ["v1", "v2", "v3"]
, KF = ["v4"]
, K1 = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function GF() {
  const e = {};
  return HF.forEach(t => {
      t.lngs.forEach(n => {
          e[n] = {
              numbers: t.nr,
              plurals: qF[t.fc]
          }
      }
      )
  }
  ),
  e
}
class QF {
  constructor(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.languageUtils = t,
      this.options = n,
      this.logger = Pn.create("pluralResolver"),
      (!this.options.compatibilityJSON || KF.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3",
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")),
      this.rules = GF()
  }
  addRule(t, n) {
      this.rules[t] = n
  }
  getRule(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
          try {
              return new Intl.PluralRules(Gl(t),{
                  type: n.ordinal ? "ordinal" : "cardinal"
              })
          } catch {
              return
          }
      return this.rules[t] || this.rules[this.languageUtils.getLanguagePartFromCode(t)]
  }
  needsPlural(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const r = this.getRule(t, n);
      return this.shouldUseIntlApi() ? r && r.resolvedOptions().pluralCategories.length > 1 : r && r.numbers.length > 1
  }
  getPluralFormsOfKey(t, n) {
      let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(t, r).map(i => `${n}${i}`)
  }
  getSuffixes(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const r = this.getRule(t, n);
      return r ? this.shouldUseIntlApi() ? r.resolvedOptions().pluralCategories.sort( (i, s) => K1[i] - K1[s]).map(i => `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : r.numbers.map(i => this.getSuffix(t, i, n)) : []
  }
  getSuffix(t, n) {
      let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const i = this.getRule(t, r);
      return i ? this.shouldUseIntlApi() ? `${this.options.prepend}${r.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(n)}` : this.getSuffixRetroCompatible(i, n) : (this.logger.warn(`no plural rule found for: ${t}`),
      "")
  }
  getSuffixRetroCompatible(t, n) {
      const r = t.noAbs ? t.plurals(n) : t.plurals(Math.abs(n));
      let i = t.numbers[r];
      this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 && (i === 2 ? i = "plural" : i === 1 && (i = ""));
      const s = () => this.options.prepend && i.toString() ? this.options.prepend + i.toString() : i.toString();
      return this.options.compatibilityJSON === "v1" ? i === 1 ? "" : typeof i == "number" ? `_plural_${i.toString()}` : s() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 ? s() : this.options.prepend && r.toString() ? this.options.prepend + r.toString() : r.toString()
  }
  shouldUseIntlApi() {
      return !VF.includes(this.options.compatibilityJSON)
  }
}
function G1(e, t, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "."
    , i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0
    , s = FF(e, t, n);
  return !s && i && typeof n == "string" && (s = Kl(e, n, r),
  s === void 0 && (s = Kl(t, n, r))),
  s
}
class YF {
  constructor() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.logger = Pn.create("interpolator"),
      this.options = t,
      this.format = t.interpolation && t.interpolation.format || (n => n),
      this.init(t)
  }
  init() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      t.interpolation || (t.interpolation = {
          escapeValue: !0
      });
      const n = t.interpolation;
      this.escape = n.escape !== void 0 ? n.escape : zF,
      this.escapeValue = n.escapeValue !== void 0 ? n.escapeValue : !0,
      this.useRawValueToEscape = n.useRawValueToEscape !== void 0 ? n.useRawValueToEscape : !1,
      this.prefix = n.prefix ? Di(n.prefix) : n.prefixEscaped || "{{",
      this.suffix = n.suffix ? Di(n.suffix) : n.suffixEscaped || "}}",
      this.formatSeparator = n.formatSeparator ? n.formatSeparator : n.formatSeparator || ",",
      this.unescapePrefix = n.unescapeSuffix ? "" : n.unescapePrefix || "-",
      this.unescapeSuffix = this.unescapePrefix ? "" : n.unescapeSuffix || "",
      this.nestingPrefix = n.nestingPrefix ? Di(n.nestingPrefix) : n.nestingPrefixEscaped || Di("$t("),
      this.nestingSuffix = n.nestingSuffix ? Di(n.nestingSuffix) : n.nestingSuffixEscaped || Di(")"),
      this.nestingOptionsSeparator = n.nestingOptionsSeparator ? n.nestingOptionsSeparator : n.nestingOptionsSeparator || ",",
      this.maxReplaces = n.maxReplaces ? n.maxReplaces : 1e3,
      this.alwaysFormat = n.alwaysFormat !== void 0 ? n.alwaysFormat : !1,
      this.resetRegExp()
  }
  reset() {
      this.options && this.init(this.options)
  }
  resetRegExp() {
      const t = `${this.prefix}(.+?)${this.suffix}`;
      this.regexp = new RegExp(t,"g");
      const n = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;
      this.regexpUnescape = new RegExp(n,"g");
      const r = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;
      this.nestingRegexp = new RegExp(r,"g")
  }
  interpolate(t, n, r, i) {
      let s, a, o;
      const u = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function l(m) {
          return m.replace(/\$/g, "$$$$")
      }
      const c = m => {
          if (m.indexOf(this.formatSeparator) < 0) {
              const h = G1(n, u, m, this.options.keySeparator, this.options.ignoreJSONStructure);
              return this.alwaysFormat ? this.format(h, void 0, r, {
                  ...i,
                  ...n,
                  interpolationkey: m
              }) : h
          }
          const v = m.split(this.formatSeparator)
            , b = v.shift().trim()
            , w = v.join(this.formatSeparator).trim();
          return this.format(G1(n, u, b, this.options.keySeparator, this.options.ignoreJSONStructure), w, r, {
              ...i,
              ...n,
              interpolationkey: b
          })
      }
      ;
      this.resetRegExp();
      const f = i && i.missingInterpolationHandler || this.options.missingInterpolationHandler
        , d = i && i.interpolation && i.interpolation.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      return [{
          regex: this.regexpUnescape,
          safeValue: m => l(m)
      }, {
          regex: this.regexp,
          safeValue: m => this.escapeValue ? l(this.escape(m)) : l(m)
      }].forEach(m => {
          for (o = 0; s = m.regex.exec(t); ) {
              const v = s[1].trim();
              if (a = c(v),
              a === void 0)
                  if (typeof f == "function") {
                      const w = f(t, s, i);
                      a = typeof w == "string" ? w : ""
                  } else if (i && Object.prototype.hasOwnProperty.call(i, v))
                      a = "";
                  else if (d) {
                      a = s[0];
                      continue
                  } else
                      this.logger.warn(`missed to pass in variable ${v} for interpolating ${t}`),
                      a = "";
              else
                  typeof a != "string" && !this.useRawValueToEscape && (a = B1(a));
              const b = m.safeValue(a);
              if (t = t.replace(s[0], b),
              d ? (m.regex.lastIndex += a.length,
              m.regex.lastIndex -= s[0].length) : m.regex.lastIndex = 0,
              o++,
              o >= this.maxReplaces)
                  break
          }
      }
      ),
      t
  }
  nest(t, n) {
      let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i, s, a;
      function o(u, l) {
          const c = this.nestingOptionsSeparator;
          if (u.indexOf(c) < 0)
              return u;
          const f = u.split(new RegExp(`${c}[ ]*{`));
          let d = `{${f[1]}`;
          u = f[0],
          d = this.interpolate(d, a);
          const y = d.match(/'/g)
            , m = d.match(/"/g);
          (y && y.length % 2 === 0 && !m || m.length % 2 !== 0) && (d = d.replace(/'/g, '"'));
          try {
              a = JSON.parse(d),
              l && (a = {
                  ...l,
                  ...a
              })
          } catch (v) {
              return this.logger.warn(`failed parsing options string in nesting for key ${u}`, v),
              `${u}${c}${d}`
          }
          return delete a.defaultValue,
          u
      }
      for (; i = this.nestingRegexp.exec(t); ) {
          let u = [];
          a = {
              ...r
          },
          a = a.replace && typeof a.replace != "string" ? a.replace : a,
          a.applyPostProcessor = !1,
          delete a.defaultValue;
          let l = !1;
          if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) {
              const c = i[1].split(this.formatSeparator).map(f => f.trim());
              i[1] = c.shift(),
              u = c,
              l = !0
          }
          if (s = n(o.call(this, i[1].trim(), a), a),
          s && i[0] === t && typeof s != "string")
              return s;
          typeof s != "string" && (s = B1(s)),
          s || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${t}`),
          s = ""),
          l && (s = u.reduce( (c, f) => this.format(c, f, r.lng, {
              ...r,
              interpolationkey: i[1].trim()
          }), s.trim())),
          t = t.replace(i[0], s),
          this.regexp.lastIndex = 0
      }
      return t
  }
}
function XF(e) {
  let t = e.toLowerCase().trim();
  const n = {};
  if (e.indexOf("(") > -1) {
      const r = e.split("(");
      t = r[0].toLowerCase().trim();
      const i = r[1].substring(0, r[1].length - 1);
      t === "currency" && i.indexOf(":") < 0 ? n.currency || (n.currency = i.trim()) : t === "relativetime" && i.indexOf(":") < 0 ? n.range || (n.range = i.trim()) : i.split(";").forEach(a => {
          if (!a)
              return;
          const [o,...u] = a.split(":")
            , l = u.join(":").trim().replace(/^'+|'+$/g, "");
          n[o.trim()] || (n[o.trim()] = l),
          l === "false" && (n[o.trim()] = !1),
          l === "true" && (n[o.trim()] = !0),
          isNaN(l) || (n[o.trim()] = parseInt(l, 10))
      }
      )
  }
  return {
      formatName: t,
      formatOptions: n
  }
}
function Ii(e) {
  const t = {};
  return function(r, i, s) {
      const a = i + JSON.stringify(s);
      let o = t[a];
      return o || (o = e(Gl(i), s),
      t[a] = o),
      o(r)
  }
}
class JF {
  constructor() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.logger = Pn.create("formatter"),
      this.options = t,
      this.formats = {
          number: Ii( (n, r) => {
              const i = new Intl.NumberFormat(n,{
                  ...r
              });
              return s => i.format(s)
          }
          ),
          currency: Ii( (n, r) => {
              const i = new Intl.NumberFormat(n,{
                  ...r,
                  style: "currency"
              });
              return s => i.format(s)
          }
          ),
          datetime: Ii( (n, r) => {
              const i = new Intl.DateTimeFormat(n,{
                  ...r
              });
              return s => i.format(s)
          }
          ),
          relativetime: Ii( (n, r) => {
              const i = new Intl.RelativeTimeFormat(n,{
                  ...r
              });
              return s => i.format(s, r.range || "day")
          }
          ),
          list: Ii( (n, r) => {
              const i = new Intl.ListFormat(n,{
                  ...r
              });
              return s => i.format(s)
          }
          )
      },
      this.init(t)
  }
  init(t) {
      const r = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          interpolation: {}
      }).interpolation;
      this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ","
  }
  add(t, n) {
      this.formats[t.toLowerCase().trim()] = n
  }
  addCached(t, n) {
      this.formats[t.toLowerCase().trim()] = Ii(n)
  }
  format(t, n, r) {
      let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return n.split(this.formatSeparator).reduce( (o, u) => {
          const {formatName: l, formatOptions: c} = XF(u);
          if (this.formats[l]) {
              let f = o;
              try {
                  const d = i && i.formatParams && i.formatParams[i.interpolationkey] || {}
                    , y = d.locale || d.lng || i.locale || i.lng || r;
                  f = this.formats[l](o, y, {
                      ...c,
                      ...i,
                      ...d
                  })
              } catch (d) {
                  this.logger.warn(d)
              }
              return f
          } else
              this.logger.warn(`there was no format function for ${l}`);
          return o
      }
      , t)
  }
}
function ZF(e, t) {
  e.pending[t] !== void 0 && (delete e.pending[t],
  e.pendingCount--)
}
class eU extends vf {
  constructor(t, n, r) {
      let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      super(),
      this.backend = t,
      this.store = n,
      this.services = r,
      this.languageUtils = r.languageUtils,
      this.options = i,
      this.logger = Pn.create("backendConnector"),
      this.waitingReads = [],
      this.maxParallelReads = i.maxParallelReads || 10,
      this.readingCalls = 0,
      this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5,
      this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350,
      this.state = {},
      this.queue = [],
      this.backend && this.backend.init && this.backend.init(r, i.backend, i)
  }
  queueLoad(t, n, r, i) {
      const s = {}
        , a = {}
        , o = {}
        , u = {};
      return t.forEach(l => {
          let c = !0;
          n.forEach(f => {
              const d = `${l}|${f}`;
              !r.reload && this.store.hasResourceBundle(l, f) ? this.state[d] = 2 : this.state[d] < 0 || (this.state[d] === 1 ? a[d] === void 0 && (a[d] = !0) : (this.state[d] = 1,
              c = !1,
              a[d] === void 0 && (a[d] = !0),
              s[d] === void 0 && (s[d] = !0),
              u[f] === void 0 && (u[f] = !0)))
          }
          ),
          c || (o[l] = !0)
      }
      ),
      (Object.keys(s).length || Object.keys(a).length) && this.queue.push({
          pending: a,
          pendingCount: Object.keys(a).length,
          loaded: {},
          errors: [],
          callback: i
      }),
      {
          toLoad: Object.keys(s),
          pending: Object.keys(a),
          toLoadLanguages: Object.keys(o),
          toLoadNamespaces: Object.keys(u)
      }
  }
  loaded(t, n, r) {
      const i = t.split("|")
        , s = i[0]
        , a = i[1];
      n && this.emit("failedLoading", s, a, n),
      r && this.store.addResourceBundle(s, a, r),
      this.state[t] = n ? -1 : 2;
      const o = {};
      this.queue.forEach(u => {
          LF(u.loaded, [s], a),
          ZF(u, t),
          n && u.errors.push(n),
          u.pendingCount === 0 && !u.done && (Object.keys(u.loaded).forEach(l => {
              o[l] || (o[l] = {});
              const c = u.loaded[l];
              c.length && c.forEach(f => {
                  o[l][f] === void 0 && (o[l][f] = !0)
              }
              )
          }
          ),
          u.done = !0,
          u.errors.length ? u.callback(u.errors) : u.callback())
      }
      ),
      this.emit("loaded", o),
      this.queue = this.queue.filter(u => !u.done)
  }
  read(t, n, r) {
      let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0
        , s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout
        , a = arguments.length > 5 ? arguments[5] : void 0;
      if (!t.length)
          return a(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
          this.waitingReads.push({
              lng: t,
              ns: n,
              fcName: r,
              tried: i,
              wait: s,
              callback: a
          });
          return
      }
      this.readingCalls++;
      const o = (l, c) => {
          if (this.readingCalls--,
          this.waitingReads.length > 0) {
              const f = this.waitingReads.shift();
              this.read(f.lng, f.ns, f.fcName, f.tried, f.wait, f.callback)
          }
          if (l && c && i < this.maxRetries) {
              setTimeout( () => {
                  this.read.call(this, t, n, r, i + 1, s * 2, a)
              }
              , s);
              return
          }
          a(l, c)
      }
        , u = this.backend[r].bind(this.backend);
      if (u.length === 2) {
          try {
              const l = u(t, n);
              l && typeof l.then == "function" ? l.then(c => o(null, c)).catch(o) : o(null, l)
          } catch (l) {
              o(l)
          }
          return
      }
      return u(t, n, o)
  }
  prepareLoading(t, n) {
      let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
        , i = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
          return this.logger.warn("No backend was added via i18next.use. Will not load resources."),
          i && i();
      typeof t == "string" && (t = this.languageUtils.toResolveHierarchy(t)),
      typeof n == "string" && (n = [n]);
      const s = this.queueLoad(t, n, r, i);
      if (!s.toLoad.length)
          return s.pending.length || i(),
          null;
      s.toLoad.forEach(a => {
          this.loadOne(a)
      }
      )
  }
  load(t, n, r) {
      this.prepareLoading(t, n, {}, r)
  }
  reload(t, n, r) {
      this.prepareLoading(t, n, {
          reload: !0
      }, r)
  }
  loadOne(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      const r = t.split("|")
        , i = r[0]
        , s = r[1];
      this.read(i, s, "read", void 0, void 0, (a, o) => {
          a && this.logger.warn(`${n}loading namespace ${s} for language ${i} failed`, a),
          !a && o && this.logger.log(`${n}loaded namespace ${s} for language ${i}`, o),
          this.loaded(t, a, o)
      }
      )
  }
  saveMissing(t, n, r, i, s) {
      let a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}
        , o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {}
      ;
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(n)) {
          this.logger.warn(`did not save key "${r}" as the namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          return
      }
      if (!(r == null || r === "")) {
          if (this.backend && this.backend.create) {
              const u = {
                  ...a,
                  isUpdate: s
              }
                , l = this.backend.create.bind(this.backend);
              if (l.length < 6)
                  try {
                      let c;
                      l.length === 5 ? c = l(t, n, r, i, u) : c = l(t, n, r, i),
                      c && typeof c.then == "function" ? c.then(f => o(null, f)).catch(o) : o(null, c)
                  } catch (c) {
                      o(c)
                  }
              else
                  l(t, n, r, i, o, u)
          }
          !t || !t[0] || this.store.addResource(t[0], n, r, i)
      }
  }
}
function Q1() {
  return {
      debug: !1,
      initImmediate: !0,
      ns: ["translation"],
      defaultNS: ["translation"],
      fallbackLng: ["dev"],
      fallbackNS: !1,
      supportedLngs: !1,
      nonExplicitSupportedLngs: !1,
      load: "all",
      preload: !1,
      simplifyPluralSuffix: !0,
      keySeparator: ".",
      nsSeparator: ":",
      pluralSeparator: "_",
      contextSeparator: "_",
      partialBundledLanguages: !1,
      saveMissing: !1,
      updateMissing: !1,
      saveMissingTo: "fallback",
      saveMissingPlurals: !0,
      missingKeyHandler: !1,
      missingInterpolationHandler: !1,
      postProcess: !1,
      postProcessPassResolved: !1,
      returnNull: !1,
      returnEmptyString: !0,
      returnObjects: !1,
      joinArrays: !1,
      returnedObjectHandler: !1,
      parseMissingKeyHandler: !1,
      appendNamespaceToMissingKey: !1,
      appendNamespaceToCIMode: !1,
      overloadTranslationOptionHandler: function(t) {
          let n = {};
          if (typeof t[1] == "object" && (n = t[1]),
          typeof t[1] == "string" && (n.defaultValue = t[1]),
          typeof t[2] == "string" && (n.tDescription = t[2]),
          typeof t[2] == "object" || typeof t[3] == "object") {
              const r = t[3] || t[2];
              Object.keys(r).forEach(i => {
                  n[i] = r[i]
              }
              )
          }
          return n
      },
      interpolation: {
          escapeValue: !0,
          format: (e, t, n, r) => e,
          prefix: "{{",
          suffix: "}}",
          formatSeparator: ",",
          unescapePrefix: "-",
          nestingPrefix: "$t(",
          nestingSuffix: ")",
          nestingOptionsSeparator: ",",
          maxReplaces: 1e3,
          skipOnVariables: !0
      }
  }
}
function Y1(e) {
  return typeof e.ns == "string" && (e.ns = [e.ns]),
  typeof e.fallbackLng == "string" && (e.fallbackLng = [e.fallbackLng]),
  typeof e.fallbackNS == "string" && (e.fallbackNS = [e.fallbackNS]),
  e.supportedLngs && e.supportedLngs.indexOf("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])),
  e
}
function xu() {}
function tU(e) {
  Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach(n => {
      typeof e[n] == "function" && (e[n] = e[n].bind(e))
  }
  )
}
class ro extends vf {
  constructor() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
        , n = arguments.length > 1 ? arguments[1] : void 0;
      if (super(),
      this.options = Y1(t),
      this.services = {},
      this.logger = Pn,
      this.modules = {
          external: []
      },
      tU(this),
      n && !this.isInitialized && !t.isClone) {
          if (!this.options.initImmediate)
              return this.init(t, n),
              this;
          setTimeout( () => {
              this.init(t, n)
          }
          , 0)
      }
  }
  init() {
      var t = this;
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
        , r = arguments.length > 1 ? arguments[1] : void 0;
      typeof n == "function" && (r = n,
      n = {}),
      !n.defaultNS && n.defaultNS !== !1 && n.ns && (typeof n.ns == "string" ? n.defaultNS = n.ns : n.ns.indexOf("translation") < 0 && (n.defaultNS = n.ns[0]));
      const i = Q1();
      this.options = {
          ...i,
          ...this.options,
          ...Y1(n)
      },
      this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
          ...i.interpolation,
          ...this.options.interpolation
      }),
      n.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = n.keySeparator),
      n.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = n.nsSeparator);
      function s(c) {
          return c ? typeof c == "function" ? new c : c : null
      }
      if (!this.options.isClone) {
          this.modules.logger ? Pn.init(s(this.modules.logger), this.options) : Pn.init(null, this.options);
          let c;
          this.modules.formatter ? c = this.modules.formatter : typeof Intl < "u" && (c = JF);
          const f = new V1(this.options);
          this.store = new H1(this.options.resources,this.options);
          const d = this.services;
          d.logger = Pn,
          d.resourceStore = this.store,
          d.languageUtils = f,
          d.pluralResolver = new QF(f,{
              prepend: this.options.pluralSeparator,
              compatibilityJSON: this.options.compatibilityJSON,
              simplifyPluralSuffix: this.options.simplifyPluralSuffix
          }),
          c && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (d.formatter = s(c),
          d.formatter.init(d, this.options),
          this.options.interpolation.format = d.formatter.format.bind(d.formatter)),
          d.interpolator = new YF(this.options),
          d.utils = {
              hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
          },
          d.backendConnector = new eU(s(this.modules.backend),d.resourceStore,d,this.options),
          d.backendConnector.on("*", function(y) {
              for (var m = arguments.length, v = new Array(m > 1 ? m - 1 : 0), b = 1; b < m; b++)
                  v[b - 1] = arguments[b];
              t.emit(y, ...v)
          }),
          this.modules.languageDetector && (d.languageDetector = s(this.modules.languageDetector),
          d.languageDetector.init && d.languageDetector.init(d, this.options.detection, this.options)),
          this.modules.i18nFormat && (d.i18nFormat = s(this.modules.i18nFormat),
          d.i18nFormat.init && d.i18nFormat.init(this)),
          this.translator = new Ql(this.services,this.options),
          this.translator.on("*", function(y) {
              for (var m = arguments.length, v = new Array(m > 1 ? m - 1 : 0), b = 1; b < m; b++)
                  v[b - 1] = arguments[b];
              t.emit(y, ...v)
          }),
          this.modules.external.forEach(y => {
              y.init && y.init(this)
          }
          )
      }
      if (this.format = this.options.interpolation.format,
      r || (r = xu),
      this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
          const c = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          c.length > 0 && c[0] !== "dev" && (this.options.lng = c[0])
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"),
      ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(c => {
          this[c] = function() {
              return t.store[c](...arguments)
          }
      }
      ),
      ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(c => {
          this[c] = function() {
              return t.store[c](...arguments),
              t
          }
      }
      );
      const u = Gs()
        , l = () => {
          const c = (f, d) => {
              this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"),
              this.isInitialized = !0,
              this.options.isClone || this.logger.log("initialized", this.options),
              this.emit("initialized", this.options),
              u.resolve(d),
              r(f, d)
          }
          ;
          if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
              return c(null, this.t.bind(this));
          this.changeLanguage(this.options.lng, c)
      }
      ;
      return this.options.resources || !this.options.initImmediate ? l() : setTimeout(l, 0),
      u
  }
  loadResources(t) {
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : xu;
      const i = typeof t == "string" ? t : this.language;
      if (typeof t == "function" && (r = t),
      !this.options.resources || this.options.partialBundledLanguages) {
          if (i && i.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
              return r();
          const s = []
            , a = o => {
              if (!o || o === "cimode")
                  return;
              this.services.languageUtils.toResolveHierarchy(o).forEach(l => {
                  l !== "cimode" && s.indexOf(l) < 0 && s.push(l)
              }
              )
          }
          ;
          i ? a(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(u => a(u)),
          this.options.preload && this.options.preload.forEach(o => a(o)),
          this.services.backendConnector.load(s, this.options.ns, o => {
              !o && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language),
              r(o)
          }
          )
      } else
          r(null)
  }
  reloadResources(t, n, r) {
      const i = Gs();
      return t || (t = this.languages),
      n || (n = this.options.ns),
      r || (r = xu),
      this.services.backendConnector.reload(t, n, s => {
          i.resolve(),
          r(s)
      }
      ),
      i
  }
  use(t) {
      if (!t)
          throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!t.type)
          throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return t.type === "backend" && (this.modules.backend = t),
      (t.type === "logger" || t.log && t.warn && t.error) && (this.modules.logger = t),
      t.type === "languageDetector" && (this.modules.languageDetector = t),
      t.type === "i18nFormat" && (this.modules.i18nFormat = t),
      t.type === "postProcessor" && n6.addPostProcessor(t),
      t.type === "formatter" && (this.modules.formatter = t),
      t.type === "3rdParty" && this.modules.external.push(t),
      this
  }
  setResolvedLanguage(t) {
      if (!(!t || !this.languages) && !(["cimode", "dev"].indexOf(t) > -1))
          for (let n = 0; n < this.languages.length; n++) {
              const r = this.languages[n];
              if (!(["cimode", "dev"].indexOf(r) > -1) && this.store.hasLanguageSomeTranslations(r)) {
                  this.resolvedLanguage = r;
                  break
              }
          }
  }
  changeLanguage(t, n) {
      var r = this;
      this.isLanguageChangingTo = t;
      const i = Gs();
      this.emit("languageChanging", t);
      const s = u => {
          this.language = u,
          this.languages = this.services.languageUtils.toResolveHierarchy(u),
          this.resolvedLanguage = void 0,
          this.setResolvedLanguage(u)
      }
        , a = (u, l) => {
          l ? (s(l),
          this.translator.changeLanguage(l),
          this.isLanguageChangingTo = void 0,
          this.emit("languageChanged", l),
          this.logger.log("languageChanged", l)) : this.isLanguageChangingTo = void 0,
          i.resolve(function() {
              return r.t(...arguments)
          }),
          n && n(u, function() {
              return r.t(...arguments)
          })
      }
        , o = u => {
          !t && !u && this.services.languageDetector && (u = []);
          const l = typeof u == "string" ? u : this.services.languageUtils.getBestMatchFromCodes(u);
          l && (this.language || s(l),
          this.translator.language || this.translator.changeLanguage(l),
          this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(l)),
          this.loadResources(l, c => {
              a(c, l)
          }
          )
      }
      ;
      return !t && this.services.languageDetector && !this.services.languageDetector.async ? o(this.services.languageDetector.detect()) : !t && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(o) : this.services.languageDetector.detect(o) : o(t),
      i
  }
  getFixedT(t, n, r) {
      var i = this;
      const s = function(a, o) {
          let u;
          if (typeof o != "object") {
              for (var l = arguments.length, c = new Array(l > 2 ? l - 2 : 0), f = 2; f < l; f++)
                  c[f - 2] = arguments[f];
              u = i.options.overloadTranslationOptionHandler([a, o].concat(c))
          } else
              u = {
                  ...o
              };
          u.lng = u.lng || s.lng,
          u.lngs = u.lngs || s.lngs,
          u.ns = u.ns || s.ns,
          u.keyPrefix = u.keyPrefix || r || s.keyPrefix;
          const d = i.options.keySeparator || ".";
          let y;
          return u.keyPrefix && Array.isArray(a) ? y = a.map(m => `${u.keyPrefix}${d}${m}`) : y = u.keyPrefix ? `${u.keyPrefix}${d}${a}` : a,
          i.t(y, u)
      };
      return typeof t == "string" ? s.lng = t : s.lngs = t,
      s.ns = n,
      s.keyPrefix = r,
      s
  }
  t() {
      return this.translator && this.translator.translate(...arguments)
  }
  exists() {
      return this.translator && this.translator.exists(...arguments)
  }
  setDefaultNamespace(t) {
      this.options.defaultNS = t
  }
  hasLoadedNamespace(t) {
      let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
          return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages),
          !1;
      if (!this.languages || !this.languages.length)
          return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages),
          !1;
      const r = n.lng || this.resolvedLanguage || this.languages[0]
        , i = this.options ? this.options.fallbackLng : !1
        , s = this.languages[this.languages.length - 1];
      if (r.toLowerCase() === "cimode")
          return !0;
      const a = (o, u) => {
          const l = this.services.backendConnector.state[`${o}|${u}`];
          return l === -1 || l === 2
      }
      ;
      if (n.precheck) {
          const o = n.precheck(this, a);
          if (o !== void 0)
              return o
      }
      return !!(this.hasResourceBundle(r, t) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || a(r, t) && (!i || a(s, t)))
  }
  loadNamespaces(t, n) {
      const r = Gs();
      return this.options.ns ? (typeof t == "string" && (t = [t]),
      t.forEach(i => {
          this.options.ns.indexOf(i) < 0 && this.options.ns.push(i)
      }
      ),
      this.loadResources(i => {
          r.resolve(),
          n && n(i)
      }
      ),
      r) : (n && n(),
      Promise.resolve())
  }
  loadLanguages(t, n) {
      const r = Gs();
      typeof t == "string" && (t = [t]);
      const i = this.options.preload || []
        , s = t.filter(a => i.indexOf(a) < 0);
      return s.length ? (this.options.preload = i.concat(s),
      this.loadResources(a => {
          r.resolve(),
          n && n(a)
      }
      ),
      r) : (n && n(),
      Promise.resolve())
  }
  dir(t) {
      if (t || (t = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)),
      !t)
          return "rtl";
      const n = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"]
        , r = this.services && this.services.languageUtils || new V1(Q1());
      return n.indexOf(r.getLanguagePartFromCode(t)) > -1 || t.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
  }
  static createInstance() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
        , n = arguments.length > 1 ? arguments[1] : void 0;
      return new ro(t,n)
  }
  cloneInstance() {
      let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
        , n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : xu;
      const r = t.forkResourceStore;
      r && delete t.forkResourceStore;
      const i = {
          ...this.options,
          ...t,
          isClone: !0
      }
        , s = new ro(i);
      return (t.debug !== void 0 || t.prefix !== void 0) && (s.logger = s.logger.clone(t)),
      ["store", "services", "language"].forEach(o => {
          s[o] = this[o]
      }
      ),
      s.services = {
          ...this.services
      },
      s.services.utils = {
          hasLoadedNamespace: s.hasLoadedNamespace.bind(s)
      },
      r && (s.store = new H1(this.store.data,i),
      s.services.resourceStore = s.store),
      s.translator = new Ql(s.services,i),
      s.translator.on("*", function(o) {
          for (var u = arguments.length, l = new Array(u > 1 ? u - 1 : 0), c = 1; c < u; c++)
              l[c - 1] = arguments[c];
          s.emit(o, ...l)
      }),
      s.init(i, n),
      s.translator.options = i,
      s.translator.backendConnector.services.utils = {
          hasLoadedNamespace: s.hasLoadedNamespace.bind(s)
      },
      s
  }
  toJSON() {
      return {
          options: this.options,
          store: this.store,
          language: this.language,
          languages: this.languages,
          resolvedLanguage: this.resolvedLanguage
      }
  }
}
const vt = ro.createInstance();
vt.createInstance = ro.createInstance;
vt.createInstance;
vt.dir;
vt.init;
vt.loadResources;
vt.reloadResources;
vt.use;
vt.changeLanguage;
vt.getFixedT;
const d7 = vt.t;
vt.exists;
vt.setDefaultNamespace;
vt.hasLoadedNamespace;
vt.loadNamespaces;
vt.loadLanguages;
function Ph(e) {
  "@babel/helpers - typeof";
  return Ph = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t
  }
  : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
  }
  ,
  Ph(e)
}
var r6 = []
, nU = r6.forEach
, rU = r6.slice;
function Th(e) {
  return nU.call(rU.call(arguments, 1), function(t) {
      if (t)
          for (var n in t)
              e[n] === void 0 && (e[n] = t[n])
  }),
  e
}
function i6() {
  return typeof XMLHttpRequest == "function" || (typeof XMLHttpRequest > "u" ? "undefined" : Ph(XMLHttpRequest)) === "object"
}
function iU(e) {
  return !!e && typeof e.then == "function"
}
function sU(e) {
  return iU(e) ? e : Promise.resolve(e)
}
var Oh = {
  exports: {}
}, Eu = {
  exports: {}
}, X1;
function aU() {
  return X1 || (X1 = 1,
  function(e, t) {
      var n = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof Mn < "u" && Mn
        , r = function() {
          function s() {
              this.fetch = !1,
              this.DOMException = n.DOMException
          }
          return s.prototype = n,
          new s
      }();
      (function(s) {
          (function(a) {
              var o = typeof s < "u" && s || typeof self < "u" && self || typeof o < "u" && o
                , u = {
                  searchParams: "URLSearchParams"in o,
                  iterable: "Symbol"in o && "iterator"in Symbol,
                  blob: "FileReader"in o && "Blob"in o && function() {
                      try {
                          return new Blob,
                          !0
                      } catch {
                          return !1
                      }
                  }(),
                  formData: "FormData"in o,
                  arrayBuffer: "ArrayBuffer"in o
              };
              function l(P) {
                  return P && DataView.prototype.isPrototypeOf(P)
              }
              if (u.arrayBuffer)
                  var c = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"]
                    , f = ArrayBuffer.isView || function(P) {
                      return P && c.indexOf(Object.prototype.toString.call(P)) > -1
                  }
                  ;
              function d(P) {
                  if (typeof P != "string" && (P = String(P)),
                  /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(P) || P === "")
                      throw new TypeError('Invalid character in header field name: "' + P + '"');
                  return P.toLowerCase()
              }
              function y(P) {
                  return typeof P != "string" && (P = String(P)),
                  P
              }
              function m(P) {
                  var A = {
                      next: function() {
                          var $ = P.shift();
                          return {
                              done: $ === void 0,
                              value: $
                          }
                      }
                  };
                  return u.iterable && (A[Symbol.iterator] = function() {
                      return A
                  }
                  ),
                  A
              }
              function v(P) {
                  this.map = {},
                  P instanceof v ? P.forEach(function(A, $) {
                      this.append($, A)
                  }, this) : Array.isArray(P) ? P.forEach(function(A) {
                      this.append(A[0], A[1])
                  }, this) : P && Object.getOwnPropertyNames(P).forEach(function(A) {
                      this.append(A, P[A])
                  }, this)
              }
              v.prototype.append = function(P, A) {
                  P = d(P),
                  A = y(A);
                  var $ = this.map[P];
                  this.map[P] = $ ? $ + ", " + A : A
              }
              ,
              v.prototype.delete = function(P) {
                  delete this.map[d(P)]
              }
              ,
              v.prototype.get = function(P) {
                  return P = d(P),
                  this.has(P) ? this.map[P] : null
              }
              ,
              v.prototype.has = function(P) {
                  return this.map.hasOwnProperty(d(P))
              }
              ,
              v.prototype.set = function(P, A) {
                  this.map[d(P)] = y(A)
              }
              ,
              v.prototype.forEach = function(P, A) {
                  for (var $ in this.map)
                      this.map.hasOwnProperty($) && P.call(A, this.map[$], $, this)
              }
              ,
              v.prototype.keys = function() {
                  var P = [];
                  return this.forEach(function(A, $) {
                      P.push($)
                  }),
                  m(P)
              }
              ,
              v.prototype.values = function() {
                  var P = [];
                  return this.forEach(function(A) {
                      P.push(A)
                  }),
                  m(P)
              }
              ,
              v.prototype.entries = function() {
                  var P = [];
                  return this.forEach(function(A, $) {
                      P.push([$, A])
                  }),
                  m(P)
              }
              ,
              u.iterable && (v.prototype[Symbol.iterator] = v.prototype.entries);
              function b(P) {
                  if (P.bodyUsed)
                      return Promise.reject(new TypeError("Already read"));
                  P.bodyUsed = !0
              }
              function w(P) {
                  return new Promise(function(A, $) {
                      P.onload = function() {
                          A(P.result)
                      }
                      ,
                      P.onerror = function() {
                          $(P.error)
                      }
                  }
                  )
              }
              function h(P) {
                  var A = new FileReader
                    , $ = w(A);
                  return A.readAsArrayBuffer(P),
                  $
              }
              function g(P) {
                  var A = new FileReader
                    , $ = w(A);
                  return A.readAsText(P),
                  $
              }
              function x(P) {
                  for (var A = new Uint8Array(P), $ = new Array(A.length), I = 0; I < A.length; I++)
                      $[I] = String.fromCharCode(A[I]);
                  return $.join("")
              }
              function S(P) {
                  if (P.slice)
                      return P.slice(0);
                  var A = new Uint8Array(P.byteLength);
                  return A.set(new Uint8Array(P)),
                  A.buffer
              }
              function E() {
                  return this.bodyUsed = !1,
                  this._initBody = function(P) {
                      this.bodyUsed = this.bodyUsed,
                      this._bodyInit = P,
                      P ? typeof P == "string" ? this._bodyText = P : u.blob && Blob.prototype.isPrototypeOf(P) ? this._bodyBlob = P : u.formData && FormData.prototype.isPrototypeOf(P) ? this._bodyFormData = P : u.searchParams && URLSearchParams.prototype.isPrototypeOf(P) ? this._bodyText = P.toString() : u.arrayBuffer && u.blob && l(P) ? (this._bodyArrayBuffer = S(P.buffer),
                      this._bodyInit = new Blob([this._bodyArrayBuffer])) : u.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(P) || f(P)) ? this._bodyArrayBuffer = S(P) : this._bodyText = P = Object.prototype.toString.call(P) : this._bodyText = "",
                      this.headers.get("content-type") || (typeof P == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : u.searchParams && URLSearchParams.prototype.isPrototypeOf(P) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                  }
                  ,
                  u.blob && (this.blob = function() {
                      var P = b(this);
                      if (P)
                          return P;
                      if (this._bodyBlob)
                          return Promise.resolve(this._bodyBlob);
                      if (this._bodyArrayBuffer)
                          return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                      if (this._bodyFormData)
                          throw new Error("could not read FormData body as blob");
                      return Promise.resolve(new Blob([this._bodyText]))
                  }
                  ,
                  this.arrayBuffer = function() {
                      if (this._bodyArrayBuffer) {
                          var P = b(this);
                          return P || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
                      } else
                          return this.blob().then(h)
                  }
                  ),
                  this.text = function() {
                      var P = b(this);
                      if (P)
                          return P;
                      if (this._bodyBlob)
                          return g(this._bodyBlob);
                      if (this._bodyArrayBuffer)
                          return Promise.resolve(x(this._bodyArrayBuffer));
                      if (this._bodyFormData)
                          throw new Error("could not read FormData body as text");
                      return Promise.resolve(this._bodyText)
                  }
                  ,
                  u.formData && (this.formData = function() {
                      return this.text().then(O)
                  }
                  ),
                  this.json = function() {
                      return this.text().then(JSON.parse)
                  }
                  ,
                  this
              }
              var p = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
              function C(P) {
                  var A = P.toUpperCase();
                  return p.indexOf(A) > -1 ? A : P
              }
              function T(P, A) {
                  if (!(this instanceof T))
                      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                  A = A || {};
                  var $ = A.body;
                  if (P instanceof T) {
                      if (P.bodyUsed)
                          throw new TypeError("Already read");
                      this.url = P.url,
                      this.credentials = P.credentials,
                      A.headers || (this.headers = new v(P.headers)),
                      this.method = P.method,
                      this.mode = P.mode,
                      this.signal = P.signal,
                      !$ && P._bodyInit != null && ($ = P._bodyInit,
                      P.bodyUsed = !0)
                  } else
                      this.url = String(P);
                  if (this.credentials = A.credentials || this.credentials || "same-origin",
                  (A.headers || !this.headers) && (this.headers = new v(A.headers)),
                  this.method = C(A.method || this.method || "GET"),
                  this.mode = A.mode || this.mode || null,
                  this.signal = A.signal || this.signal,
                  this.referrer = null,
                  (this.method === "GET" || this.method === "HEAD") && $)
                      throw new TypeError("Body not allowed for GET or HEAD requests");
                  if (this._initBody($),
                  (this.method === "GET" || this.method === "HEAD") && (A.cache === "no-store" || A.cache === "no-cache")) {
                      var I = /([?&])_=[^&]*/;
                      if (I.test(this.url))
                          this.url = this.url.replace(I, "$1_=" + new Date().getTime());
                      else {
                          var W = /\?/;
                          this.url += (W.test(this.url) ? "&" : "?") + "_=" + new Date().getTime()
                      }
                  }
              }
              T.prototype.clone = function() {
                  return new T(this,{
                      body: this._bodyInit
                  })
              }
              ;
              function O(P) {
                  var A = new FormData;
                  return P.trim().split("&").forEach(function($) {
                      if ($) {
                          var I = $.split("=")
                            , W = I.shift().replace(/\+/g, " ")
                            , B = I.join("=").replace(/\+/g, " ");
                          A.append(decodeURIComponent(W), decodeURIComponent(B))
                      }
                  }),
                  A
              }
              function R(P) {
                  var A = new v
                    , $ = P.replace(/\r?\n[\t ]+/g, " ");
                  return $.split("\r").map(function(I) {
                      return I.indexOf(`
`) === 0 ? I.substr(1, I.length) : I
                  }).forEach(function(I) {
                      var W = I.split(":")
                        , B = W.shift().trim();
                      if (B) {
                          var ee = W.join(":").trim();
                          A.append(B, ee)
                      }
                  }),
                  A
              }
              E.call(T.prototype);
              function j(P, A) {
                  if (!(this instanceof j))
                      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                  A || (A = {}),
                  this.type = "default",
                  this.status = A.status === void 0 ? 200 : A.status,
                  this.ok = this.status >= 200 && this.status < 300,
                  this.statusText = A.statusText === void 0 ? "" : "" + A.statusText,
                  this.headers = new v(A.headers),
                  this.url = A.url || "",
                  this._initBody(P)
              }
              E.call(j.prototype),
              j.prototype.clone = function() {
                  return new j(this._bodyInit,{
                      status: this.status,
                      statusText: this.statusText,
                      headers: new v(this.headers),
                      url: this.url
                  })
              }
              ,
              j.error = function() {
                  var P = new j(null,{
                      status: 0,
                      statusText: ""
                  });
                  return P.type = "error",
                  P
              }
              ;
              var L = [301, 302, 303, 307, 308];
              j.redirect = function(P, A) {
                  if (L.indexOf(A) === -1)
                      throw new RangeError("Invalid status code");
                  return new j(null,{
                      status: A,
                      headers: {
                          location: P
                      }
                  })
              }
              ,
              a.DOMException = o.DOMException;
              try {
                  new a.DOMException
              } catch {
                  a.DOMException = function(A, $) {
                      this.message = A,
                      this.name = $;
                      var I = Error(A);
                      this.stack = I.stack
                  }
                  ,
                  a.DOMException.prototype = Object.create(Error.prototype),
                  a.DOMException.prototype.constructor = a.DOMException
              }
              function M(P, A) {
                  return new Promise(function($, I) {
                      var W = new T(P,A);
                      if (W.signal && W.signal.aborted)
                          return I(new a.DOMException("Aborted","AbortError"));
                      var B = new XMLHttpRequest;
                      function ee() {
                          B.abort()
                      }
                      B.onload = function() {
                          var N = {
                              status: B.status,
                              statusText: B.statusText,
                              headers: R(B.getAllResponseHeaders() || "")
                          };
                          N.url = "responseURL"in B ? B.responseURL : N.headers.get("X-Request-URL");
                          var F = "response"in B ? B.response : B.responseText;
                          setTimeout(function() {
                              $(new j(F,N))
                          }, 0)
                      }
                      ,
                      B.onerror = function() {
                          setTimeout(function() {
                              I(new TypeError("Network request failed"))
                          }, 0)
                      }
                      ,
                      B.ontimeout = function() {
                          setTimeout(function() {
                              I(new TypeError("Network request failed"))
                          }, 0)
                      }
                      ,
                      B.onabort = function() {
                          setTimeout(function() {
                              I(new a.DOMException("Aborted","AbortError"))
                          }, 0)
                      }
                      ;
                      function z(N) {
                          try {
                              return N === "" && o.location.href ? o.location.href : N
                          } catch {
                              return N
                          }
                      }
                      B.open(W.method, z(W.url), !0),
                      W.credentials === "include" ? B.withCredentials = !0 : W.credentials === "omit" && (B.withCredentials = !1),
                      "responseType"in B && (u.blob ? B.responseType = "blob" : u.arrayBuffer && W.headers.get("Content-Type") && W.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (B.responseType = "arraybuffer")),
                      A && typeof A.headers == "object" && !(A.headers instanceof v) ? Object.getOwnPropertyNames(A.headers).forEach(function(N) {
                          B.setRequestHeader(N, y(A.headers[N]))
                      }) : W.headers.forEach(function(N, F) {
                          B.setRequestHeader(F, N)
                      }),
                      W.signal && (W.signal.addEventListener("abort", ee),
                      B.onreadystatechange = function() {
                          B.readyState === 4 && W.signal.removeEventListener("abort", ee)
                      }
                      ),
                      B.send(typeof W._bodyInit > "u" ? null : W._bodyInit)
                  }
                  )
              }
              return M.polyfill = !0,
              o.fetch || (o.fetch = M,
              o.Headers = v,
              o.Request = T,
              o.Response = j),
              a.Headers = v,
              a.Request = T,
              a.Response = j,
              a.fetch = M,
              a
          }
          )({})
      }
      )(r),
      r.fetch.ponyfill = !0,
      delete r.fetch.polyfill;
      var i = n.fetch ? n : r;
      t = i.fetch,
      t.default = i.fetch,
      t.fetch = i.fetch,
      t.Headers = i.Headers,
      t.Request = i.Request,
      t.Response = i.Response,
      e.exports = t
  }(Eu, Eu.exports)),
  Eu.exports
}
(function(e, t) {
  var n;
  if (typeof fetch == "function" && (typeof Mn < "u" && Mn.fetch ? n = Mn.fetch : typeof window < "u" && window.fetch ? n = window.fetch : n = fetch),
  typeof yE < "u" && (typeof window > "u" || typeof window.document > "u")) {
      var r = n || aU();
      r.default && (r = r.default),
      t.default = r,
      e.exports = t.default
  }
}
)(Oh, Oh.exports);
var s6 = Oh.exports;
const a6 = gi(s6)
, J1 = lw({
  __proto__: null,
  default: a6
}, [s6]);
function Yl(e) {
  "@babel/helpers - typeof";
  return Yl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t
  }
  : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
  }
  ,
  Yl(e)
}
var Wn;
typeof fetch == "function" && (typeof global < "u" && global.fetch ? Wn = global.fetch : typeof window < "u" && window.fetch ? Wn = window.fetch : Wn = fetch);
var io;
i6() && (typeof global < "u" && global.XMLHttpRequest ? io = global.XMLHttpRequest : typeof window < "u" && window.XMLHttpRequest && (io = window.XMLHttpRequest));
var Xl;
typeof ActiveXObject == "function" && (typeof global < "u" && global.ActiveXObject ? Xl = global.ActiveXObject : typeof window < "u" && window.ActiveXObject && (Xl = window.ActiveXObject));
!Wn && J1 && !io && !Xl && (Wn = a6 || J1);
typeof Wn != "function" && (Wn = void 0);
var kh = function(t, n) {
  if (n && Yl(n) === "object") {
      var r = "";
      for (var i in n)
          r += "&" + encodeURIComponent(i) + "=" + encodeURIComponent(n[i]);
      if (!r)
          return t;
      t = t + (t.indexOf("?") !== -1 ? "&" : "?") + r.slice(1)
  }
  return t
}
, Z1 = function(t, n, r) {
  var i = function(a) {
      if (!a.ok)
          return r(a.statusText || "Error", {
              status: a.status
          });
      a.text().then(function(o) {
          r(null, {
              status: a.status,
              data: o
          })
      }).catch(r)
  };
  typeof fetch == "function" ? fetch(t, n).then(i).catch(r) : Wn(t, n).then(i).catch(r)
}
, ew = !1
, oU = function(t, n, r, i) {
  t.queryStringParams && (n = kh(n, t.queryStringParams));
  var s = Th({}, typeof t.customHeaders == "function" ? t.customHeaders() : t.customHeaders);
  typeof window > "u" && typeof global < "u" && typeof global.process < "u" && global.process.versions && global.process.versions.node && (s["User-Agent"] = "i18next-http-backend (node/".concat(global.process.version, "; ").concat(global.process.platform, " ").concat(global.process.arch, ")")),
  r && (s["Content-Type"] = "application/json");
  var a = typeof t.requestOptions == "function" ? t.requestOptions(r) : t.requestOptions
    , o = Th({
      method: r ? "POST" : "GET",
      body: r ? t.stringify(r) : void 0,
      headers: s
  }, ew ? {} : a);
  try {
      Z1(n, o, i)
  } catch (u) {
      if (!a || Object.keys(a).length === 0 || !u.message || u.message.indexOf("not implemented") < 0)
          return i(u);
      try {
          Object.keys(a).forEach(function(l) {
              delete o[l]
          }),
          Z1(n, o, i),
          ew = !0
      } catch (l) {
          i(l)
      }
  }
}
, uU = function(t, n, r, i) {
  r && Yl(r) === "object" && (r = kh("", r).slice(1)),
  t.queryStringParams && (n = kh(n, t.queryStringParams));
  try {
      var s;
      io ? s = new io : s = new Xl("MSXML2.XMLHTTP.3.0"),
      s.open(r ? "POST" : "GET", n, 1),
      t.crossDomain || s.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
      s.withCredentials = !!t.withCredentials,
      r && s.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
      s.overrideMimeType && s.overrideMimeType("application/json");
      var a = t.customHeaders;
      if (a = typeof a == "function" ? a() : a,
      a)
          for (var o in a)
              s.setRequestHeader(o, a[o]);
      s.onreadystatechange = function() {
          s.readyState > 3 && i(s.status >= 400 ? s.statusText : null, {
              status: s.status,
              data: s.responseText
          })
      }
      ,
      s.send(r)
  } catch (u) {
      console && console.log(u)
  }
}
, lU = function(t, n, r, i) {
  if (typeof r == "function" && (i = r,
  r = void 0),
  i = i || function() {}
  ,
  Wn && n.indexOf("file:") !== 0)
      return oU(t, n, r, i);
  if (i6() || typeof ActiveXObject == "function")
      return uU(t, n, r, i);
  i(new Error("No fetch and no xhr implementation found!"))
};
function so(e) {
  "@babel/helpers - typeof";
  return so = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t
  }
  : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
  }
  ,
  so(e)
}
function cU(e, t) {
  if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function")
}
function tw(e, t) {
  for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1,
      r.configurable = !0,
      "value"in r && (r.writable = !0),
      Object.defineProperty(e, o6(r.key), r)
  }
}
function fU(e, t, n) {
  return t && tw(e.prototype, t),
  n && tw(e, n),
  Object.defineProperty(e, "prototype", {
      writable: !1
  }),
  e
}
function dU(e, t, n) {
  return t = o6(t),
  t in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
  }) : e[t] = n,
  e
}
function o6(e) {
  var t = pU(e, "string");
  return so(t) === "symbol" ? t : String(t)
}
function pU(e, t) {
  if (so(e) !== "object" || e === null)
      return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
      var r = n.call(e, t || "default");
      if (so(r) !== "object")
          return r;
      throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var hU = function() {
  return {
      loadPath: "/locales/{{lng}}/{{ns}}.json",
      addPath: "/locales/add/{{lng}}/{{ns}}",
      parse: function(n) {
          return JSON.parse(n)
      },
      stringify: JSON.stringify,
      parsePayload: function(n, r, i) {
          return dU({}, r, i || "")
      },
      parseLoadPayload: function(n, r) {},
      request: lU,
      reloadInterval: typeof window < "u" ? !1 : 60 * 60 * 1e3,
      customHeaders: {},
      queryStringParams: {},
      crossDomain: !1,
      withCredentials: !1,
      overrideMimeType: !1,
      requestOptions: {
          mode: "cors",
          credentials: "same-origin",
          cache: "default"
      }
  }
}
, u6 = function() {
  function e(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
        , r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      cU(this, e),
      this.services = t,
      this.options = n,
      this.allOptions = r,
      this.type = "backend",
      this.init(t, n, r)
  }
  return fU(e, [{
      key: "init",
      value: function(n) {
          var r = this
            , i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
            , s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this.services = n,
          this.options = Th(i, this.options || {}, hU()),
          this.allOptions = s,
          this.services && this.options.reloadInterval && setInterval(function() {
              return r.reload()
          }, this.options.reloadInterval)
      }
  }, {
      key: "readMulti",
      value: function(n, r, i) {
          this._readAny(n, n, r, r, i)
      }
  }, {
      key: "read",
      value: function(n, r, i) {
          this._readAny([n], n, [r], r, i)
      }
  }, {
      key: "_readAny",
      value: function(n, r, i, s, a) {
          var o = this
            , u = this.options.loadPath;
          typeof this.options.loadPath == "function" && (u = this.options.loadPath(n, i)),
          u = sU(u),
          u.then(function(l) {
              if (!l)
                  return a(null, {});
              var c = o.services.interpolator.interpolate(l, {
                  lng: n.join("+"),
                  ns: i.join("+")
              });
              o.loadUrl(c, a, r, s)
          })
      }
  }, {
      key: "loadUrl",
      value: function(n, r, i, s) {
          var a = this
            , o = typeof i == "string" ? [i] : i
            , u = typeof s == "string" ? [s] : s
            , l = this.options.parseLoadPayload(o, u);
          this.options.request(this.options, n, l, function(c, f) {
              if (f && (f.status >= 500 && f.status < 600 || !f.status))
                  return r("failed loading " + n + "; status code: " + f.status, !0);
              if (f && f.status >= 400 && f.status < 500)
                  return r("failed loading " + n + "; status code: " + f.status, !1);
              if (!f && c && c.message && c.message.indexOf("Failed to fetch") > -1)
                  return r("failed loading " + n + ": " + c.message, !0);
              if (c)
                  return r(c, !1);
              var d, y;
              try {
                  typeof f.data == "string" ? d = a.options.parse(f.data, i, s) : d = f.data
              } catch {
                  y = "failed parsing " + n + " to json"
              }
              if (y)
                  return r(y, !1);
              r(null, d)
          })
      }
  }, {
      key: "create",
      value: function(n, r, i, s, a) {
          var o = this;
          if (this.options.addPath) {
              typeof n == "string" && (n = [n]);
              var u = this.options.parsePayload(r, i, s)
                , l = 0
                , c = []
                , f = [];
              n.forEach(function(d) {
                  var y = o.options.addPath;
                  typeof o.options.addPath == "function" && (y = o.options.addPath(d, r));
                  var m = o.services.interpolator.interpolate(y, {
                      lng: d,
                      ns: r
                  });
                  o.options.request(o.options, m, u, function(v, b) {
                      l += 1,
                      c.push(v),
                      f.push(b),
                      l === n.length && typeof a == "function" && a(c, f)
                  })
              })
          }
      }
  }, {
      key: "reload",
      value: function() {
          var n = this
            , r = this.services
            , i = r.backendConnector
            , s = r.languageUtils
            , a = r.logger
            , o = i.language;
          if (!(o && o.toLowerCase() === "cimode")) {
              var u = []
                , l = function(f) {
                  var d = s.toResolveHierarchy(f);
                  d.forEach(function(y) {
                      u.indexOf(y) < 0 && u.push(y)
                  })
              };
              l(o),
              this.allOptions.preload && this.allOptions.preload.forEach(function(c) {
                  return l(c)
              }),
              u.forEach(function(c) {
                  n.allOptions.ns.forEach(function(f) {
                      i.read(c, f, "read", null, null, function(d, y) {
                          d && a.warn("loading namespace ".concat(f, " for language ").concat(c, " failed"), d),
                          !d && y && a.log("loaded namespace ".concat(f, " for language ").concat(c), y),
                          i.loaded("".concat(c, "|").concat(f), d, y)
                      })
                  })
              })
          }
      }
  }]),
  e
}();
u6.type = "backend";
function mU(e, t) {
  if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function")
}
function ao(e) {
  "@babel/helpers - typeof";
  return ao = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t
  }
  : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
  }
  ,
  ao(e)
}
function yU(e, t) {
  if (ao(e) != "object" || !e)
      return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
      var r = n.call(e, t || "default");
      if (ao(r) != "object")
          return r;
      throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function gU(e) {
  var t = yU(e, "string");
  return ao(t) == "symbol" ? t : String(t)
}
function nw(e, t) {
  for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1,
      r.configurable = !0,
      "value"in r && (r.writable = !0),
      Object.defineProperty(e, gU(r.key), r)
  }
}
function vU(e, t, n) {
  return t && nw(e.prototype, t),
  n && nw(e, n),
  Object.defineProperty(e, "prototype", {
      writable: !1
  }),
  e
}
var l6 = []
, wU = l6.forEach
, bU = l6.slice;
function xU(e) {
  return wU.call(bU.call(arguments, 1), function(t) {
      if (t)
          for (var n in t)
              e[n] === void 0 && (e[n] = t[n])
  }),
  e
}
var rw = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/
, EU = function(t, n, r) {
  var i = r || {};
  i.path = i.path || "/";
  var s = encodeURIComponent(n)
    , a = "".concat(t, "=").concat(s);
  if (i.maxAge > 0) {
      var o = i.maxAge - 0;
      if (Number.isNaN(o))
          throw new Error("maxAge should be a Number");
      a += "; Max-Age=".concat(Math.floor(o))
  }
  if (i.domain) {
      if (!rw.test(i.domain))
          throw new TypeError("option domain is invalid");
      a += "; Domain=".concat(i.domain)
  }
  if (i.path) {
      if (!rw.test(i.path))
          throw new TypeError("option path is invalid");
      a += "; Path=".concat(i.path)
  }
  if (i.expires) {
      if (typeof i.expires.toUTCString != "function")
          throw new TypeError("option expires is invalid");
      a += "; Expires=".concat(i.expires.toUTCString())
  }
  if (i.httpOnly && (a += "; HttpOnly"),
  i.secure && (a += "; Secure"),
  i.sameSite) {
      var u = typeof i.sameSite == "string" ? i.sameSite.toLowerCase() : i.sameSite;
      switch (u) {
      case !0:
          a += "; SameSite=Strict";
          break;
      case "lax":
          a += "; SameSite=Lax";
          break;
      case "strict":
          a += "; SameSite=Strict";
          break;
      case "none":
          a += "; SameSite=None";
          break;
      default:
          throw new TypeError("option sameSite is invalid")
      }
  }
  return a
}
, iw = {
  create: function(t, n, r, i) {
      var s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
          path: "/",
          sameSite: "strict"
      };
      r && (s.expires = new Date,
      s.expires.setTime(s.expires.getTime() + r * 60 * 1e3)),
      i && (s.domain = i),
      document.cookie = EU(t, encodeURIComponent(n), s)
  },
  read: function(t) {
      for (var n = "".concat(t, "="), r = document.cookie.split(";"), i = 0; i < r.length; i++) {
          for (var s = r[i]; s.charAt(0) === " "; )
              s = s.substring(1, s.length);
          if (s.indexOf(n) === 0)
              return s.substring(n.length, s.length)
      }
      return null
  },
  remove: function(t) {
      this.create(t, "", -1)
  }
}
, SU = {
  name: "cookie",
  lookup: function(t) {
      var n;
      if (t.lookupCookie && typeof document < "u") {
          var r = iw.read(t.lookupCookie);
          r && (n = r)
      }
      return n
  },
  cacheUserLanguage: function(t, n) {
      n.lookupCookie && typeof document < "u" && iw.create(n.lookupCookie, t, n.cookieMinutes, n.cookieDomain, n.cookieOptions)
  }
}
, CU = {
  name: "querystring",
  lookup: function(t) {
      var n;
      if (typeof window < "u") {
          var r = window.location.search;
          !window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1 && (r = window.location.hash.substring(window.location.hash.indexOf("?")));
          for (var i = r.substring(1), s = i.split("&"), a = 0; a < s.length; a++) {
              var o = s[a].indexOf("=");
              if (o > 0) {
                  var u = s[a].substring(0, o);
                  u === t.lookupQuerystring && (n = s[a].substring(o + 1))
              }
          }
      }
      return n
  }
}
, Qs = null
, sw = function() {
  if (Qs !== null)
      return Qs;
  try {
      Qs = window !== "undefined" && window.localStorage !== null;
      var t = "i18next.translate.boo";
      window.localStorage.setItem(t, "foo"),
      window.localStorage.removeItem(t)
  } catch {
      Qs = !1
  }
  return Qs
}
, _U = {
  name: "localStorage",
  lookup: function(t) {
      var n;
      if (t.lookupLocalStorage && sw()) {
          var r = window.localStorage.getItem(t.lookupLocalStorage);
          r && (n = r)
      }
      return n
  },
  cacheUserLanguage: function(t, n) {
      n.lookupLocalStorage && sw() && window.localStorage.setItem(n.lookupLocalStorage, t)
  }
}
, Ys = null
, aw = function() {
  if (Ys !== null)
      return Ys;
  try {
      Ys = window !== "undefined" && window.sessionStorage !== null;
      var t = "i18next.translate.boo";
      window.sessionStorage.setItem(t, "foo"),
      window.sessionStorage.removeItem(t)
  } catch {
      Ys = !1
  }
  return Ys
}
, PU = {
  name: "sessionStorage",
  lookup: function(t) {
      var n;
      if (t.lookupSessionStorage && aw()) {
          var r = window.sessionStorage.getItem(t.lookupSessionStorage);
          r && (n = r)
      }
      return n
  },
  cacheUserLanguage: function(t, n) {
      n.lookupSessionStorage && aw() && window.sessionStorage.setItem(n.lookupSessionStorage, t)
  }
}
, TU = {
  name: "navigator",
  lookup: function(t) {
      var n = [];
      if (typeof navigator < "u") {
          if (navigator.languages)
              for (var r = 0; r < navigator.languages.length; r++)
                  n.push(navigator.languages[r]);
          navigator.userLanguage && n.push(navigator.userLanguage),
          navigator.language && n.push(navigator.language)
      }
      return n.length > 0 ? n : void 0
  }
}
, OU = {
  name: "htmlTag",
  lookup: function(t) {
      var n, r = t.htmlTag || (typeof document < "u" ? document.documentElement : null);
      return r && typeof r.getAttribute == "function" && (n = r.getAttribute("lang")),
      n
  }
}
, kU = {
  name: "path",
  lookup: function(t) {
      var n;
      if (typeof window < "u") {
          var r = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
          if (r instanceof Array)
              if (typeof t.lookupFromPathIndex == "number") {
                  if (typeof r[t.lookupFromPathIndex] != "string")
                      return;
                  n = r[t.lookupFromPathIndex].replace("/", "")
              } else
                  n = r[0].replace("/", "")
      }
      return n
  }
}
, DU = {
  name: "subdomain",
  lookup: function(t) {
      var n = typeof t.lookupFromSubdomainIndex == "number" ? t.lookupFromSubdomainIndex + 1 : 1
        , r = typeof window < "u" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
      if (r)
          return r[n]
  }
};
function IU() {
  return {
      order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
      lookupQuerystring: "lng",
      lookupCookie: "i18next",
      lookupLocalStorage: "i18nextLng",
      lookupSessionStorage: "i18nextLng",
      caches: ["localStorage"],
      excludeCacheFor: ["cimode"],
      convertDetectedLanguage: function(t) {
          return t
      }
  }
}
var c6 = function() {
  function e(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      mU(this, e),
      this.type = "languageDetector",
      this.detectors = {},
      this.init(t, n)
  }
  return vU(e, [{
      key: "init",
      value: function(n) {
          var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
            , i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this.services = n || {
              languageUtils: {}
          },
          this.options = xU(r, this.options || {}, IU()),
          typeof this.options.convertDetectedLanguage == "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1 && (this.options.convertDetectedLanguage = function(s) {
              return s.replace("-", "_")
          }
          ),
          this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex),
          this.i18nOptions = i,
          this.addDetector(SU),
          this.addDetector(CU),
          this.addDetector(_U),
          this.addDetector(PU),
          this.addDetector(TU),
          this.addDetector(OU),
          this.addDetector(kU),
          this.addDetector(DU)
      }
  }, {
      key: "addDetector",
      value: function(n) {
          this.detectors[n.name] = n
      }
  }, {
      key: "detect",
      value: function(n) {
          var r = this;
          n || (n = this.options.order);
          var i = [];
          return n.forEach(function(s) {
              if (r.detectors[s]) {
                  var a = r.detectors[s].lookup(r.options);
                  a && typeof a == "string" && (a = [a]),
                  a && (i = i.concat(a))
              }
          }),
          i = i.map(function(s) {
              return r.options.convertDetectedLanguage(s)
          }),
          this.services.languageUtils.getBestMatchFromCodes ? i : i.length > 0 ? i[0] : null
      }
  }, {
      key: "cacheUserLanguage",
      value: function(n, r) {
          var i = this;
          r || (r = this.options.caches),
          r && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(n) > -1 || r.forEach(function(s) {
              i.detectors[s] && i.detectors[s].cacheUserLanguage(n, i.options)
          }))
      }
  }]),
  e
}();
c6.type = "languageDetector";
vt.use(u6).use(c6).use(eL).init({
  fallbackLng: "en",
  supportedLngs: ["en", "fr", "es", "de", "it", "kr", "ru", "nl", "zh", "tr", "pt", "vi"],
  debug: !1,
  detection: {
      order: ["querystring", "localStorage", "navigator"],
      lookupFromPathIndex: 0,
      checkWhitelist: !0
  },
  backend: {
      requestOptions: {
          cache: "no-store"
      }
  },
  interpolation: {
      escapeValue: !1
  }
});
class AU extends We.Component {
  constructor(t) {
      super(t),
      this.state = {
          hasError: !1
      }
  }
  static getDerivedStateFromError(t) {
      return {
          hasError: !0
      }
  }
  componentDidCatch(t, n) {
      console.log(t, n)
  }
  render() {
      return this.state.hasError ? this.props.fallback : this.props.children
  }
}
const $U = q.div`
background: linear-gradient(rgba(0, 0, 0, 1) 0%, rgba(5, 86, 48, 1) 50%);
display: flex;
height: 100vh;
width: 100%;
overflow: hidden;
justify-content: center;
align-items: center;
`
, RU = q.div`
display: flex;
flex-direction: column;
width: 100%;
max-width: 1440px;
padding: 24px 24px;
justify-content: center;
align-items: center;
`
, NU = q.img`
width: 100%;
max-width: 400px;
height: auto;

@media screen and (max-width: 768px) {
  max-width: 300px;
}

@media screen and (max-width: 480px) {
  max-width: 200px;
}
`
, jU = q.div`
display: flex;
flex-direction: column;
gap: 5px;
text-align: center;
margin-top: 50px;
`
, MU = q.h1`
font-size: 24px;
color: #fff;
font-weight: ${ ({bold: e}) => e ? "bold" : "400"};

@media screen and (max-width: 768px) {
  font-size: 18px;
}

@media screen and (max-width: 480px) {
  font-size: 16px;
}
`
, ow = q.p`
font-size: 16px;
color: #fff;
font-weight: ${ ({bold: e}) => e ? "bold" : "400"};

@media screen and (max-width: 768px) {
  font-size: 14px;
}

@media screen and (max-width: 480px) {
  font-size: 12px;
}
`
, LU = () => {
  const {t: e} = Ci();
  return D.jsx($U, {
      children: D.jsxs(RU, {
          children: [D.jsx(NU, {
              src: "/images/main/logo.webp"
          }), D.jsxs(jU, {
              children: [D.jsx(MU, {
                  bold: !0,
                  children: e("crash.header")
              }), D.jsx(ow, {
                  children: e("crash.desc")
              }), D.jsx(ow, {
                  children: e("crash.text")
              })]
          })]
      })
  })
}
, FU = q.div`
background: linear-gradient(rgba(0, 0, 0, 1) 0%, rgba(5, 86, 48, 1) 50%);
display: flex;
height: 100vh;
width: 100%;
overflow: hidden;
justify-content: center;
align-items: center;
z-index: 999;
`
, UU = q.div`
display: flex;
flex-direction: column;
width: 100%;
max-width: 1440px;
padding: 24px 24px;
justify-content: center;
align-items: center;
`
, zU = q.h1`
font-size: 36px;
color: #fcefde;
text-align: center;

@media screen and (max-width: 768px) {
  font-size: 28px;
}

@media screen and (max-width: 480px) {
  font-size: 24px;
}
`
, BU = q.a`
text-align: center;
text-decoration: none;
color: red;
`
, uw = q.p`
font-size: 16px;
color: #fcefde;
font-weight: ${ ({bold: e}) => e ? "bold" : "400"};
text-align: center;

@media screen and (max-width: 768px) {
  font-size: 14px;
}

@media screen and (max-width: 480px) {
  font-size: 12px;
}
`
, WU = () => {
  const {t: e} = Ci();
  return D.jsx(FU, {
      children: D.jsxs(UU, {
          children: [D.jsx(zU, {
              children: e("unsecure.header")
          }), D.jsx(uw, {
              style: {
                  marginTop: "25px"
              },
              children: e("unsecure.desc")
          }), D.jsx(uw, {
              style: {
                  marginTop: "5px"
              },
              children: D.jsxs(nL, {
                  i18nKey: "unsecure.click",
                  children: ["link", D.jsx(BU, {
                      href: window.self.location.href,
                      title: "Web Application",
                      target: "blank",
                      children: "here"
                  })]
              })
          })]
      })
  })
}
;
window.self === window.top ? Ku.createRoot(document.getElementById("root")).render(D.jsx(lN, {
  children: D.jsx(AU, {
      fallback: D.jsx(LU, {}),
      children: D.jsx($L, {
          children: D.jsx(vS, {
              children: D.jsx(_t, {
                  path: "/*",
                  element: D.jsx(NF, {})
              })
          })
      })
  })
})) : Ku.createRoot(document.getElementById("root")).render(D.jsx(WU, {}));
export {rT as $, l7 as A, aU as B, Yn as C, gi as D, Mn as E, jk as F, $s as G, EN as H, n7 as I, hN as J, wS as K, Si as L, mN as M, yN as N, gN as O, rd as P, vN as Q, r7 as R, We as S, i7 as T, iT as U, gT as V, Ki as W, vT as X, wT as Y, Sx as Z, sn as _, Ci as a, VI as a$, ju as a0, cw as a1, qc as a2, ui as a3, se as a4, gn as a5, Fc as a6, fn as a7, yn as a8, lv as a9, _9 as aA, hs as aB, C9 as aC, z9 as aD, R9 as aE, an as aF, E9 as aG, b9 as aH, x9 as aI, _o as aJ, Kc as aK, IE as aL, y9 as aM, g9 as aN, u9 as aO, O9 as aP, k9 as aQ, Gc as aR, h9 as aS, by as aT, A9 as aU, T9 as aV, P9 as aW, $9 as aX, Z9 as aY, F9 as aZ, L9 as a_, li as aa, N9 as ab, j9 as ac, dr as ad, i9 as ae, s9 as af, a9 as ag, o9 as ah, lI as ai, d9 as aj, l9 as ak, f9 as al, c9 as am, DE as an, Vc as ao, At as ap, p9 as aq, w9 as ar, X9 as as, m9 as at, J9 as au, Co as av, S9 as aw, I9 as ax, D9 as ay, v9 as az, _n as b, Q9 as b0, B9 as b1, KI as b2, M9 as b3, V9 as b4, W9 as b5, K9 as b6, Y9 as b7, H9 as b8, q9 as b9, XS as bA, HU as bB, d7 as bC, K0 as bD, Ik as bE, G9 as ba, U9 as bb, MI as bc, $E as bd, ld as be, n9 as bf, r9 as bg, V as bh, yc as bi, Et as bj, Rr as bk, Ra as bl, l3 as bm, ho as bn, Gn as bo, Pc as bp, da as bq, kn as br, Oo as bs, JU as bt, ZU as bu, nL as bv, Mc as bw, Is as bx, QU as by, YU as bz, gf as c, e9 as d, jc as e, Cn as f, t9 as g, XU as h, Ye as i, D as j, s7 as k, c7 as l, Lo as m, GU as n, _i as o, cu as p, Uk as q, _ as r, q as s, t7 as t, e8 as u, vh as v, f7 as w, a7 as x, o7 as y, u7 as z};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
      __vite__mapDeps.viteFileDeps = ["assets/index-5yUoXU-p.js", "assets/index-tTQKUB83.js", "assets/index-fxJ6RGiT.js", "assets/if-defined-leStHEAq.js", "assets/index.es-6EvgWQqA.js", "assets/events-a2vpiPAD.js", "assets/homePage-DKfpsCOH.js", "assets/motion-_fLkK2fy.js", "assets/coinPage-63hLAocb.js", "assets/web3-FmIaR_iU.js", "assets/useCoinStakeInfo-hC8aMJVk.js", "assets/mainStyles-R3YPfcg-.js", "assets/counter-6r21ZzCJ.js", "assets/nftPage-S85uj0_8.js", "assets/notFoundPage-q1u3iSrS.js", "assets/coinCalculatorPage-iiEAYnHf.js", "assets/nftCalculatorPage-WjYO7Mnp.js", "assets/coinHowPage-A-sbroE9.js", "assets/nftHowPage-lR5__HNK.js"]
  }
  return indexes.map( (i) => __vite__mapDeps.viteFileDeps[i])
}
